{
  "key": "solidity-course",
  "title": "Solidity Course",
  "summary": "Smart contracts allow users to implement conditions, rules and policies of the blockchain applications. \nIn this course you will learn how to write smart contracts and all the features of Solidity language.\n",
  "details": "\"Line1\" \n\"Line2\" \n\"Line3\"\n",
  "duration": "4 - 6 hours",
  "highlights": [
    "Solidity smart contracts",
    "All the features of Solidity",
    "Advanced Solidity concepts",
    "Summaries and questions for each chapter"
  ],
  "publishStatus": "Live",
  "thumbnail": "https://d31h13bdjwgzxs.cloudfront.net/courses/DoDAO/Solidity/Solidity.png",
  "topics": [
    {
      "title": "Your First Solidity Smart Contract",
      "key": "intro-solidity",
      "details": "This chapter explains the solidity compiler and how to get started with solidity . Further it explores the layout of a solidity source file and also the structure of smart contracts in solidity.",
      "order": 0,
      "questions": [
        {
          "uuid": "0dfd7a32-7eb3-4751-b35e-7f3b9ca775bc",
          "type": "MultipleChoice",
          "content": "Which of the following is a valid pragma verion declaration in Solidity?",
          "hint": "noHint",
          "explanation": "pragma solidity 0.6.12  - Only compiles with version 0.6.12\npragma solidity ^0.6.12 - Compiles with version 0.6.12 and above\npragma solidity >=0.4.0 <0.6.0 - Compiles with all versions between 0.4.0 and 0.6.0.\n",
          "answerKeys": [
            "A",
            "B",
            "C"
          ],
          "subTopics": [
            "solidity-compiler"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`pragma solidity 0.6.12;`",
              "key": "A",
              "order": 0
            },
            {
              "content": "`pragma solidity ^0.6.12;`",
              "key": "B",
              "order": 1
            },
            {
              "content": "`pragma solidity >=0.4.0 <0.6.0;`",
              "key": "C",
              "order": 2
            },
            {
              "content": "`pragma solidity -0.5.2;`",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "85f2abbc-9acb-4ebe-a624-3c952da70b22",
          "type": "SingleChoice",
          "content": "A Solidity Contract file has a pragma versioning `pragma solidity ^0.5.2;`. With which of the following compilers will the contract run?",
          "hint": "Think of what condition is applicable with `^` symbol in solidity versioning.",
          "explanation": "A source file with the line above does not compile with a compiler earlier than version 0.5.2, and it also does not work on a compiler starting from version 0.6.0 (this second condition is added by using ^).",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "solidity-compiler"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Compiler version 0.5.1",
              "key": "A",
              "order": 0
            },
            {
              "content": "Compiler version 0.4.1",
              "key": "B",
              "order": 1
            },
            {
              "content": "Compiler version 0.5.5",
              "key": "C",
              "order": 2
            },
            {
              "content": "Compiler version 0.6.1",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "6bc53ece-fffd-4f7f-bb54-c8200d629d16",
          "type": "MultipleChoice",
          "content": "Which of the following statements is incorrect regarding pragmas in solidity?",
          "hint": "ABI coder pragma can be used to select between the two implementations of the ABI encoder and decoder and experimental pragma can be used to enable features of the compiler or language that are not yet enabled by default.",
          "explanation": "The pragma keyword is used to enable certain compiler features or checks. A pragma directive is always local to a source file, so you have to add the pragma to all your files if you want to enable it in your whole project. If you import another file, the pragma from that file does not automatically apply to the importing file.\nBy using pragma abicoder v1 or pragma abicoder v2 you can select between the two implementations of the ABI encoder and decoder. It can be used to enable features of the compiler or language that are not yet enabled by default. The following experimental pragmas are currently supported: ABIEncoderV2 , SMTChecker.\n",
          "answerKeys": [
            "A",
            "D"
          ],
          "subTopics": [
            "file-layout"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "In Solidity `pragma` keyword is only used to specify the version of the compiler the code should compile with.",
              "key": "A",
              "order": 0
            },
            {
              "content": "The `pragma` keyword is used to enable certain compiler features or checks.",
              "key": "B",
              "order": 1
            },
            {
              "content": "The following code will only compile with compiler version 0.6.12, `pragma solidity 0.6.12;`.",
              "key": "C",
              "order": 2
            },
            {
              "content": "If you import another file, the pragma from that file will automatically apply to the importing file.",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "d336edf3-75ef-43c7-b77d-74bafcaa92b9",
          "type": "SingleChoice",
          "content": "Which of the following pragma declarations is incorrect?",
          "hint": "noHint",
          "explanation": "By using pragma abicoder v1 or pragma abicoder v2 you can select between the two implementations of the ABI encoder and decoder.\nIf you use pragma experimental SMTChecker;, then you get additional safety warnings which are obtained by querying an SMT solver.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "file-layout"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "pragma experimental SMTChecker;",
              "key": "A",
              "order": 0
            },
            {
              "content": "pragma abicoder v1;",
              "key": "B",
              "order": 1
            },
            {
              "content": "pragma solidity ^0.5.2;",
              "key": "C",
              "order": 2
            },
            {
              "content": "pragma version 0.6.2;",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "1e3de4e3-fd09-446a-ba8a-2d223b59f587",
          "type": "SingleChoice",
          "content": "If you want to import a sile in your solidity code which of the following will be a correct but inefficient way to do so?",
          "hint": "All import statements are correct.",
          "explanation": "The statement `import \"filename\";` imports all global symbols from “filename” into the current global scope. This form is not recommended for use, because it unpredictably pollutes the namespace. If you add new top-level items inside “filename”, they automatically appear in all files that import like this from “filename”. It is better to import specific symbols explicitly.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "file-layout"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "import * as symbolName from \"filename\";",
              "key": "A",
              "order": 0
            },
            {
              "content": "import \"filename\" as symbolName;",
              "key": "B",
              "order": 1
            },
            {
              "content": "import {symbol1 as alias, symbol2} from \"filename\";",
              "key": "C",
              "order": 2
            },
            {
              "content": "import \"filename\";",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "f3f566ee-680f-40e0-be77-d8b3572c154c",
          "type": "SingleChoice",
          "content": "In the context of the following comment `// SPDX-License-Identifier: MIT` which of the following statements is incorrect?",
          "hint": "noHint",
          "explanation": "The compiler does not validate that the license is part of the list allowed by SPDX, but it does include the supplied string in the bytecode metadata.\nThe comment is recognized by the compiler anywhere in the file at the file level, but it is recommended to put it at the top of the file.\nThe liscense should be one from the the list given in the SPDX. \n",
          "answerKeys": [
            "A",
            "C"
          ],
          "subTopics": [
            "file-layout"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "This comment gets validated by the solidity compiler and then supplies the string in the bytecode metadata.",
              "key": "A",
              "order": 0
            },
            {
              "content": "The comment is recognized by the compiler anywhere in the file at the file level.",
              "key": "B",
              "order": 1
            },
            {
              "content": "Only MIT liscense should be used to validate smart contracts.",
              "key": "C",
              "order": 2
            },
            {
              "content": "If you do not want to specify a license or if the source code is not open-source, you can use the special value UNLICENSED.",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "70f2e739-5097-4606-be32-9fc2dc766c0e",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "file-layout"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "25239107-bb81-48b8-9485-9c8df81a5514",
          "type": "MultipleChoice",
          "content": "Which of the following comments is invalid in a Solidity Code?",
          "hint": "noHint",
          "explanation": "Single-line comments (//) and multi-line comments (/*...*/) are possible in Solidity. \nAdditionally, there is another type of comment called a NatSpec comment, they are written with a triple slash (///) or a double asterisk block (/** ... */) and they should be used directly above function declarations or statements.\n",
          "answerKeys": [
            "A",
            "D"
          ],
          "subTopics": [
            "file-layout"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "/This is a single line comment.",
              "key": "A",
              "order": 0
            },
            {
              "content": "//This is a single line comment.",
              "key": "B",
              "order": 1
            },
            {
              "content": "///This is a single line comment.",
              "key": "C",
              "order": 2
            },
            {
              "content": "/*This is a single line comment.",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "6de1c98d-d533-4b04-937c-6f90db4fc63e",
          "type": "MultipleChoice",
          "content": "In the context of NatSpec comments which of the following is true?",
          "hint": "Solidity supports NatSpec comments in addition to the simple single/multi line comments.",
          "explanation": "NatSpec stands for Ethereum Natural Language Specification Format.\nIf no tags are used then the Solidity compiler will interpret a /// or /** comment in the same way as if it were tagged with @notice.\nThe Solidity compiler only interprets tags if they are external or public. You can use similar comments for internal and private functions, but those will not be parsed.\n",
          "answerKeys": [
            "A",
            "C"
          ],
          "subTopics": [
            "file-layout"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "NatSpec stands for Ethereum Natural Language Specification Format.",
              "key": "A",
              "order": 0
            },
            {
              "content": "NatSpec comments provide tags and in case if no tags are used , the solidity compiler will interpret (///) as (//).",
              "key": "B",
              "order": 1
            },
            {
              "content": "The Solidity compiler only interprets tags if they are external or public.",
              "key": "C",
              "order": 2
            },
            {
              "content": "Comments in solidity can only be made using (//) for Single-line and (/*...*/) for multi-line.",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "e854f94d-5e49-4e3f-9e2a-0f8a1a4d1f83",
          "type": "SingleChoice",
          "content": "Regarding constructors in solidity which statement is correct?",
          "hint": "Only one constructor is allowed.",
          "explanation": "A constructor is optional. Only one constructor is allowed, which means overloading is not supported.\nAfter the constructor has executed, the final code of the contract is stored on the blockchain. \nThe deployed code does not include the constructor code or internal functions only called from the constructor.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "contract-structure"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Constructor overloading is supported.",
              "key": "A",
              "order": 0
            },
            {
              "content": "A constructor is optional.",
              "key": "B",
              "order": 1
            },
            {
              "content": "The contract deployed on the blockchain will also contain the constructor code.",
              "key": "C",
              "order": 2
            },
            {
              "content": "None of these",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "611c7208-9eb2-4c4a-8d10-160081de6710",
          "type": "SingleChoice",
          "content": "Which of the options regarding the statements below are correct?\nStatement 1 - A contract in the sense of Solidity is a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain.\nStatement 2 - Contracts in Solidity are similar to classes in object-oriented languages.\n",
          "hint": "noHint",
          "explanation": "Contracts in Solidity are similar to classes in object-oriented languages. They contain persistent data in state variables, and functions that can modify these variables.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "contract-structure"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement 1 is correct but Statement 2 is incorrect.",
              "key": "A",
              "order": 0
            },
            {
              "content": "Statement 2 is correct but Statement 1 is incorrect.",
              "key": "B",
              "order": 1
            },
            {
              "content": "Both are correct.",
              "key": "C",
              "order": 2
            },
            {
              "content": "Neither is correct.",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "b8e4a65e-683e-43a0-b0c1-7f6271177181",
          "type": "SingleChoice",
          "content": "Which of the following options are correct based on the code snippet below?\n```\ncontract OriginCoordinates {\n    uint constant x_coordinate;\n    uint immutable y_coordinate;\n\n    constructor(){\n        x_coordinate=0;\n        y_coordinate=0;\n    }\n\n\n    function get() public view returns (uint,uint) {\n        return (x_coordinate,y_coordinate);\n    }\n}\n```\n",
          "hint": "Check the declaration of the state variables.",
          "explanation": "The state variable x_coordinate cannot be initialized in the constructor as it is declared as constant.\nFor constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "contract-structure"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "This code will not compile as solidity functions cannot have multipe return values.",
              "key": "A",
              "order": 0
            },
            {
              "content": "This code will not compile because State Variables declared immutable cannot be initialised in a constructor.",
              "key": "B",
              "order": 1
            },
            {
              "content": "This code will not compile because State Variables declared constant cannot be initialised in a constructor.",
              "key": "C",
              "order": 2
            },
            {
              "content": "The code has no errors and can be deployed.",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "5e40d1c1-0bbc-45f6-ae2e-eeee3715168b",
          "type": "MultipleChoice",
          "content": "Which of the following statements is correct regarding functions ?",
          "hint": "noHint",
          "explanation": "Functions can be declared view in which case they promise not to modify the state, they can also be declared pure in which case they promise not to read from or modify the state.\n",
          "answerKeys": [
            "A",
            "C",
            "D"
          ],
          "subTopics": [
            "contract-structure"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Functions outside of a contract are also called 'free functions'.",
              "key": "A",
              "order": 0
            },
            {
              "content": "Functions declared as view can modify the state variables.",
              "key": "B",
              "order": 1
            },
            {
              "content": "In Solidity the function is simply invoked by writing the name of the function where it has to be called.",
              "key": "C",
              "order": 2
            },
            {
              "content": "Functions can have multiple return values.",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "c60393ac-3492-4d4b-a7c7-ecee0e09e9d7",
          "type": "MultipleChoice",
          "content": "Which of the following options is correct regarding \"free functions\"?",
          "hint": "Free functions in Solidity are functions created outside of the scope of a contract.",
          "explanation": "A free function behaves like an internal function of the contract that called it. \nThe main difference is that a free function cannot directly access state variables and internal functions of contracts.\n",
          "answerKeys": [
            "B",
            "D"
          ],
          "subTopics": [
            "contract-structure"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "Free functions in solidity are functions declared inside a contract with public Visibility.",
              "key": "A",
              "order": 0
            },
            {
              "content": "Their code is included in all contracts that call them.",
              "key": "B",
              "order": 1
            },
            {
              "content": "They can access state variables and internal functions directly.",
              "key": "C",
              "order": 2
            },
            {
              "content": "A free function behaves like an internal function of the contract that called it.",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "c97bee69-c7c1-4932-a6f8-60c2cf4df840",
          "type": "SingleChoice",
          "content": "What does the following syntax do? \n`import * as symbolName from \"filename\";`\n",
          "hint": "noHint",
          "explanation": "The following example creates a new global symbol symbolName whose members are all the global symbols from \"filename\":\n`import * as symbolName from \"filename\";` which results in all global symbols being available in the format symbolName.symbol.\n",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "file-layout"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "This statement imports all global symbols from “filename” into the current global scope.",
              "key": "A",
              "order": 0
            },
            {
              "content": "This statement creates a new global symbol symbolName whose members are all the global symbols from \"filename\".",
              "key": "B",
              "order": 1
            },
            {
              "content": "This statement imports symbolName member from \"filename\".",
              "key": "C",
              "order": 2
            },
            {
              "content": "None of these.",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "985403b3-673a-4017-9099-76a5cc0d5f10",
          "type": "SingleChoice",
          "content": "In which scenarios is a fallback function triggered?",
          "hint": "noHint",
          "explanation": "A fallback function is called in two cases- A contract receives only Ether and no data,\nor when no function calls matched even though the account received data.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "contract-structure"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Contract received ether and no data.",
              "key": "A",
              "order": 0
            },
            {
              "content": "Contract received data but no function matched the function called.",
              "key": "B",
              "order": 1
            },
            {
              "content": "Contract sent insufficient gas.",
              "key": "C",
              "order": 2
            },
            {
              "content": "Both A & B",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "2f2949ba-7998-425b-adf0-8f5fac5541bc",
          "type": "SingleChoice",
          "content": "Remix IDE is used for the development of small contracts. What does IDE stand for?",
          "hint": "noHint",
          "explanation": "Remix IDE is part of the Remix Project which can be used for the development of small contracts and for quickly learning Solidity. IDE stands for Integrated Development Environment.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "solidity-compiler"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Integrated Development Engine",
              "key": "A",
              "order": 0
            },
            {
              "content": "Integrated Development Environment",
              "key": "B",
              "order": 1
            },
            {
              "content": "Integrated DApp Engin",
              "key": "C",
              "order": 2
            },
            {
              "content": "Internet Development Environment",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "e288ce1e-aa2e-48b1-9878-f7133359198c",
          "type": "SingleChoice",
          "content": "What happens when an event is called ?",
          "hint": "noHint",
          "explanation": "Events are inheritable members of contracts. When you call them, they cause the arguments to be stored in the transactions log - a special data structure in the blockchain.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "contract-structure"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "When called, events flag an error to the caller.",
              "key": "A",
              "order": 0
            },
            {
              "content": "They provide a condition under which event a function calling the event should be executed.",
              "key": "B",
              "order": 1
            },
            {
              "content": "They cause the arguments to be stored in the transactions log - a special data structure in the blockchain.",
              "key": "C",
              "order": 2
            },
            {
              "content": "None of these.",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "138e8326-fe39-421f-ae9e-ac5a6cfb0ad0",
          "type": "MUltipleChoice",
          "content": "What are events used for?",
          "hint": "When called, events cause the arguments to be stored in the transactions log - a special data structure in the blockchain.",
          "explanation": "Events are used to inform external users that something happened on the blockchain. Smart contracts themselves cannot listen to any events.\nAll information in the blockchain is public and any actions can be found by looking into the transactions close enough but events are a shortcut to ease the development of outside systems in cooperation with smart contracts. \n",
          "answerKeys": [
            "A",
            "C"
          ],
          "subTopics": [
            "contract-structure"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Events can be used to communicate with external users about a transaction that happened on the blockchain.",
              "key": "A",
              "order": 0
            },
            {
              "content": "They are used for error handling.",
              "key": "B",
              "order": 1
            },
            {
              "content": "They can be used to inform a user of any action that happened on the blockchain and can thus ease the development of outside systems in cooperation with smart contracts.",
              "key": "C",
              "order": 2
            },
            {
              "content": "None of these.",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "42d7664b-47e1-4f1e-9162-af63a8c0db22",
          "type": "MultipleChoice",
          "content": "In the following snippet, what is the purpose of the code?\n```\naddress owner;\nstring private name;\nconstructor() {\n  owner = msg.sender;\n}\nmodifier onlyOwner() {\n  require(msg.sender == owner, 'Not Owner');\n  _;\n}\nfunction setName(string memory newName) public onlyOwner{\n  name = newName;\n}\n```\n",
          "hint": "Function modifiers can be used to change the behaviour of functions in a declarative way.",
          "explanation": "In the code, constructor sets the creator of the contract to the owner variable . The `onlyOwner` modifier checks that the caller of the function is the owner. the function `setName` uses the modifier `onlyOwner`. If the caller of the function is not the owner then the function does not execute.",
          "answerKeys": [
            "A",
            "B",
            "D"
          ],
          "subTopics": [
            "contract-structure"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "Upon contract creation, the owner address is initialized to the user who deployed the contract.",
              "key": "A",
              "order": 0
            },
            {
              "content": "The function setName can only be called by the owner of the contract.",
              "key": "B",
              "order": 1
            },
            {
              "content": "onlyOwner is a function which will throw an error each time it is called by a non-owner.",
              "key": "C",
              "order": 2
            },
            {
              "content": "onlyOwner can be used to modify the behaviour of a function.",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "d8609639-3532-48ff-8f33-7ae8ce2ade62",
          "type": "SingleChoice",
          "content": "Which of the following can be used to restrict access of a function?",
          "hint": "noHint",
          "explanation": "Modifiers assist in the execution of a functions behavior. They can be used to restrict access of a function.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "contract-structure"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "function",
              "key": "A",
              "order": 0
            },
            {
              "content": "function modifier",
              "key": "B",
              "order": 1
            },
            {
              "content": "event",
              "key": "C",
              "order": 2
            },
            {
              "content": "constructor",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "33eab1f8-3a7c-4cd9-8c0d-f42a2f9f4fd3",
          "type": "SingleChoice",
          "content": "Where is `_;` instruction used in Solidity?",
          "hint": "noHint",
          "explanation": "In Solidity, `_;` is used inside a modifier to specify when the function should be executed.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "contract-structure"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It is used in a function.",
              "key": "A",
              "order": 0
            },
            {
              "content": "It is used in aconstructor.",
              "key": "B",
              "order": 1
            },
            {
              "content": "It is used in a modifier.",
              "key": "C",
              "order": 2
            },
            {
              "content": "It can be used anywhere at the file level.",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "aa3caf4e-b9d8-46f9-95ac-d588df2558a7",
          "type": "SingleChoice",
          "content": "What is the returned value when `set` is called first then `get`.\n```\ncontract UnderScore {\n    uint a;\n    constructor(){\n        a=10;\n    }\n    modifier m(){\n      _;\n      if(a<=15){\n          a=a+10;\n      }\n    }\n    function set() public m {\n        a=a+10;\n    }\n    function get() public view returns (uint) {\n        return a;\n    }\n}\n```\n",
          "hint": "Notice how the function set will execute because of the modifier m.",
          "explanation": "In Solidity, `_;` is used inside a modifier to specify when the function should be executed. As the modifier has `_;` before the modifier statements, so the function code will execute first and then the modifier code. The function set will update the value of a to 20 and then the modifier code will check if the value is greater than 15 or not.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "contract-structure"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "10",
              "key": "A",
              "order": 0
            },
            {
              "content": "15",
              "key": "B",
              "order": 1
            },
            {
              "content": "20",
              "key": "C",
              "order": 2
            },
            {
              "content": "30",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "07881a7f-600c-4bfc-baf9-787f3fa70700",
          "type": "SingleChoice",
          "content": "Which of the following is a correct declaration of a function ?",
          "hint": "noHint",
          "explanation": "The basic syntax of a function is shown below.\n```\n  function function-name(parameter-list) scope returns() {\n    //statements\n  }\n```\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "contract-structure"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "public function foo() view returns(){}",
              "key": "A",
              "order": 0
            },
            {
              "content": "public view function foo() returns(){}",
              "key": "B",
              "order": 1
            },
            {
              "content": "function foo() view returns() public{}",
              "key": "C",
              "order": 2
            },
            {
              "content": "function foo() public view returns(){}",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "0767755b-6790-44cd-8364-7c56acb77457",
          "type": "SingleChoice",
          "content": "Which of the following options are true regarding the statements below.  \nStatement 1 - A constructor can be either public or internal.  \nStatement 2 - A constructor code is executed once when a contract is created and it is used to initialize contract state.\n",
          "hint": "noHint",
          "explanation": "A constructor is an optional funtion and is used to initialize state variables of a contract.\nIt is executed once when a contract is created and it is used to initialize contract state.\nA constructor can be either public or internal.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement 1 is true but Statement 2 is false.",
              "key": "A",
              "order": 0
            },
            {
              "content": "Statement 2 is true but Statement 1 is false.",
              "key": "B",
              "order": 1
            },
            {
              "content": "Both are true.",
              "key": "C",
              "order": 2
            },
            {
              "content": "Neither is true.",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "77cd176f-04d5-464d-86fa-64992e2d4db8",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "421abb3d-6f87-4e4a-a22f-af467d34035b",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "2fb21e8c-429e-4229-817b-6077c945fca0",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "f6d9abaf-0f05-4376-ad34-58c366ebee76",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "437f24c0-fa13-4ac8-bd39-3c4649aadb0c",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "38d84a22-7517-4aaf-9018-75b533aa3e7e",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "d73be206-d0fe-4f75-b6d3-693275d1b069",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "a8f4d89b-bfc8-4dc0-8f9e-5aab0088f13a",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "61bc26de-8555-40ef-8f26-8235ada76c94",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "4b1b0494-f540-4a22-af9a-bdd791fb2834",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "411289f8-19ca-4f57-8bd1-c55aea028b5a",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "c513ceac-7031-4473-aaa0-d17870eeeb0a",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "3c2e68b2-0577-411b-8980-2389c0d859ac",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "734e92a7-07e9-43d6-b346-3be5d5e20109",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "c3b40fc3-0ff1-49d8-aa2b-9a454ef568f0",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "c4123a41-b80e-4a83-adc7-7a189e1a6041",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "fea2cad9-970c-40cc-8fa9-ec46f0b3155a",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "6c484192-0531-42ec-a0fc-494132dea432",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "f6231249-cc8e-402b-9536-20dedb877205",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "4ac8bea3-1844-4e91-babf-5cd065d14b4e",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "285aa1cb-75de-4cf8-9d33-8987e14955a7",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "84c2a59c-64aa-4e9b-922d-7ed4ce76b92f",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "3a266ee5-43fc-4cae-b4fd-a32f91375537",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "5ffdf81e-6254-439f-aa8e-2e2fbf7414d6",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        },
        {
          "uuid": "d0a9daba-7de0-4b4a-9714-d71f25a21472",
          "type": "SingleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "option 1",
              "key": "A",
              "order": 0
            },
            {
              "content": "option 2",
              "key": "B",
              "order": 1
            },
            {
              "content": "option 3",
              "key": "C",
              "order": 2
            },
            {
              "content": "option 4",
              "key": "D",
              "order": 3
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "be0f341e-e428-401c-98a0-d08061b3dadd",
          "title": "title",
          "shortTitle": "short title",
          "type": "YoutubeVideo",
          "url": "url",
          "subTopics": [
            "solidity-compiler"
          ],
          "details": "details\n"
        }
      ],
      "summaries": [
        {
          "title": "Installing Solidity Compiler",
          "shortTitle": "Solidity Compiler",
          "key": "solidity-compiler",
          "details": "- Versoning \n  * Solidity versions follow 'Semantic Versioning' which is essential to avoid 'dependency hell' while programming in Solidity.\n    'Dependency hell' in software management occurs when version specifications are made too tight or too loose due to which releasing new versions becomes a nightmare as it becomes difficult to resolve conflicts. To avoid this solidity \n    releases its versions with version number MAJOR.MINOR.PATCH .eg Solidity compiler version 0.8.15 indicates major release 0 with 8th minor release and 15th patch fix.\n  * Patch level releases with major release 0 (i.e. 0.x.y) does not contain breaking changes. That means code that compiles with version 0.x.y can be expected to compile with 0.x.z where z > y.\n- Remix IDE is part of the Remix Project which can be used for the development of small contracts and for quickly learning Solidity. [Access Remix Online](https://remix.ethereum.org) .\n- npm/Node.js\n  * npm can be used for a convenient and portable way to install solcjs, a Solidity compiler. \n  * Use the command `npm install -g solc` , to install the Solidity compiler.\n  * Using `solcjs --help` provides you with an explanation of all available options.\n  * To compile a contract that imports other contracts via relative paths:      \n    `solcjs --bin --include-path node_modules/ --base-path . MainContract.sol`\n    Use the `--base-path` and `--include-path` options to describe the layout of your project. `--base-path` represents the root of your own source tree while `--include-path` allows you to specify extra locations containing external code (e.g. libraries installed with a package manager).\n"
        },
        {
          "title": "Layout of a Source File",
          "shortTitle": "File Layout",
          "key": "file-layout",
          "details": "- SPDX License Identifier\n  * Trust in smart contracts is better established if their source code is available and open source. Since making it available always touches on legal problems with regards to copyright, the Solidity compiler encourages the use of machine-readable SPDX license identifiers.\n  * Every solidity source file should start with a comment indicating its license. eg. `// SPDX-License-Identifier: MIT` .\n  * The Software Package Data Exchange (SPDX) is an open standard used for communicating licenses , copyrights and security references.\n\n- Pragmas\n  * pragma is a directive used to configure compiler features and checks.\n  * A pragma directive is always local to a source file, so you have to add the pragma to all your files if you want to enable it in your whole project.\n  * If you import another file, the pragma from that file does not automatically apply to the importing file.\n  * A Version pragma is a directive that specifies the compiler version to be used for current Solidity file.\n  * For example, `pragma solidity ^0.4.0;`,  the pragma for a file using the above statement will not compile earlier than version 0.4.0 and it will also not work on a compiler starting from version 0.5.0, this condition is taken care off by ^. \n  * Another example is, `pragma solidity >=0.6.0 <0.8.0;` where the pragma directive instructs the compiler to compile code for Solidity version greater than equal to 0.6.0 till up to but not including 0.8.0.\n  * #TODO - ABI encoder pragma\n\n- Comments\n  * Single-line comments (//) and multi-line comments (/*...*/) are possible. Any text after // or between /* and */ is ignored by the compiler.\n    ```\n    // This is a single-line comment.\n\n    /*\n    This is a\n    multi-line comment.\n    */\n    ```\n  * You can also write your Solidity comments in the Ethereum Natural Language Specification Format (NatSpec). It defines a special form of comments in Solidity contracts. Developers use it for documenting return variables, functions, and so on.\n  * You should insert all documentation using comments before class, interface, and function keywords.\n  * You can write single or multi-line comments in Solidity, and use two types of syntax, start the line with /// to include a single-line comment and start with /**and end with /* to include a multi-line comment.\n    ```\n    /// @author ishaan\n\n    /**\n    @notice introducing Solidity NAtSpec comments.\n    This is a\n    multi-line comment.\n    /*\n    ```\n  * NAtSpec comments ca be used with oprional tags , in the above code snippet @author shows the name of the author and @notice explain to an end user what it does.\n  * The Solidity compiler only interprets tags if they are external or public. You can use similar comments for internal and private functions, but those will not be parsed.\n\n- Imports\n  * Solidity supports import statements to modularise code similar to those available in JavaScript (from ES6 on).\n  * At a global level, you can use import statements of the following form: `import \"filename\";`. This statement imports all global symbols from “filename” into the current global scope. This form is not recommended for use, because it unpredictably pollutes the namespace. If you add new top-level items inside “filename”, they automatically appear in all files that import like this from “filename”. \n  * The following example creates a new global symbol symbolName whose members are all the global symbols from \"filename\": `import * as symbolName from \"filename\";`\n    which results in all global symbols being available in the format symbolName.symbol.\n  * If there is a naming collision, you can rename symbols while importing. `import {symbol1 as alias, symbol2} from \"filename\";`. \n"
        },
        {
          "title": "Structure of a Smart Contract",
          "shortTitle": "Contract Structure",
          "key": "contract-structure",
          "details": "Contracts in Solidity are similar to classes in object-oriented languages. \nEach contract can contain declarations of State Variables, Functions, Function Modifiers, Events, Errors, Struct Types and Enum Types.\n\n- State Variables\n  * State variables are variables whose values are permanently stored in contract storage.\n  * In the following code snippet `storedData` is an example of a state variable.\n  ```\n  // SPDX-License-Identifier: GPL-3.0\n  pragma solidity >=0.4.0 <0.9.0;\n\n  contract SimpleStorage {\n      uint storedData; // State variable\n      // ...\n  }\n  ```\n  * State variables can be declared as `constant` or `immutable`. In both cases, the variables cannot be modified after the contract has been constructed.\n  * For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. Constant variables can also be declared at the file level.\n  * Not all types for constants and immutables are implemented at this time. The only supported types are strings (only for constants) and value types.\n  * The example below shows the use of constant and immutable state variables.\n    ```\n    // SPDX-License-Identifier: GPL-3.0\n    pragma solidity >=0.7.4;\n\n    uint constant X = 32**22 + 8;\n\n    contract C {\n        string constant TEXT = \"abc\";\n        bytes32 constant MY_HASH = keccak256(\"abc\");\n        uint immutable decimals;\n        uint immutable maxBalance;\n        address immutable owner = msg.sender;\n\n        constructor(uint decimals_, address ref) {\n            decimals = decimals_;\n            maxBalance = ref.balance;\n        }\n    }\n    ```\n\n- Functions \n  * Functions are the executable units of code. \n    Functions are usually defined inside a contract, but they can also be defined outside of contracts.\n  * In the code below helper function is defined outside the contract whearas arithmetic function is declared inside the contract.\n    ```\n    // SPDX-License-Identifier: GPL-3.0\n    pragma solidity >=0.7.1 <0.9.0;\n\n    contract Simple {\n        function arithmetic(uint a, uint b)\n            public\n            pure\n            returns (uint sum, uint product)\n        {\n            return (a + b, a * b);\n        }\n    }\n\n    // Helper function defined outside of a contract\n    function helper(uint x) pure returns (uint) {\n        return x * 2;\n    }\n    ```\n  * Functions outside of a contract are also called 'free function' and their code is included in all contracts that call them.\n  * The main difference to functions defined inside a contract is that free functions do not have direct access to storage variables and functions not in their scope.\n  * Functions take typed parameters as input and can also return an arbitrary number of values as output.\n  * In the code snippet above , the contract `Simple` has a function arithmetic which takes two input parameters `uint a` and `uint b`.\n  * The function arithmetic also returns two values `uint sum` and `uint product`.\n  * the return values in a function can also be explicitly assigned to return variables instead of a return statememnt like in the code below.\n    ```\n    function arithmetic(uint a, uint b)\n        public\n        pure\n        returns (uint sum, uint product)\n    {\n        sum = a + b;\n        product = a * b;\n    }\n    ```\n  * Solidity has a fallback function which is executed if none of the other functions match the function identifier or no data was provided with the function call. \n  * Only one unnamed function can be assigned to a contract and it is executed whenever the contract receives plain Ether without any data. To receive Ether and add it to the total balance of the contract, the fallback function must be marked payable. If no such function exists, the contract cannot receive Ether through regular transactions and will throw an exception.\n  * Check the following code to declare a fallback function.\n    ```\n    function() public payable\n    {\n        balance[msg.sender] += msg.value;\n    }\n    ```\n    The above fallback function is called in two cases- A contract receives only Ether and no data,\n    or when no function calls matched even though the account received data.\n  * Functions can be declared view in which case they promise not to modify the state, they can also be declared pure in which case they promise not to read from or modify the state.\n    ```\n    contract ViewAndPure {\n        uint public x = 1;\n\n        // Promise not to modify the state.\n        function addToX(uint y) public view returns (uint) {\n            return x + y;\n        }\n\n        // Promise not to modify or read from the state.\n        function add(uint i, uint j) public pure returns (uint) {\n            return i + j;\n        }\n    }\n    ```\n    The above view function `addToX` can read the state variable x but cannot update its state whearas the pure function `add` can neither read nor update the state.\n\n- Constructors \n  * A constructor is an optional function declared with the constructor keyword which is executed upon contract creation, and where you can run contract initialisation code.\n  * Before the constructor code is executed, state variables are initialised to their specified value if you initialise them inline, or their default value if you do not.\n  * If there is no constructor, the contract will assume the default constructor, which is equivalent to constructor() {}.\n  * The code snippet below explains the use of a constructor, \n    ```\n      uint public x;\n      uint public y;\n      address public owner;\n      uint public createdAt;\n      Constructor (uint _x, uint _y) public {\n                  x=_x;\n                  y=_y;\n                  owner = msg.sender;\n                  createdAt = block.timestamp;\n    ```\n  * Constructors are very useful in Solidity , if you do not implement a function to change the state variable it will remain as long as the block chain is running. So using a constructor is a way to set a state variable that you do not want to change.\n\n- Events\n  * Events are inheritable members of contracts. When you call them, they cause the arguments to be stored in the transactions log - a special data structure in the blockchain.\n  * Events are defined within the contracts as global and called within their functions. Events are declared by using the event keyword as follows , `event <eventName>(parameters) ;`.\n  * The example below shows the declaration of an event and its use in its function. In this example, the Deposit event is emitted when a user sends Ether to the smart contract with the deposit function.\n\n   ```\n    event Deposit(\n    address indexed from,\n    bytes32 indexed id,\n    uint value\n    );\n\n    function deposit(bytes32 id) public payable {\n        emit Deposit(msg.sender, id, msg.value);\n    }\n  ```\n  * Events are ways to communicate with a client application or front-end website that something has happened on the blockchain. The above event Deposit can be detected from\n    the JavaScript API by filtering for `Deposit`.\n\n- Function Modifiers\n  * Function modifiers can be used to change the behaviour of functions in a declarative way.\n  * A modifier can be used automatically to check a condition prior to execution of the function.\n  * In the code snippet below constructor sets the creator of the contract to the owner variable . The `onlyOwner` modifier checks that the caller of the function is the owner. \n    the function `setName` uses the modifier `onlyOwner`. If the caller of the function is not the owner then the function does not execute.\n    ```\n    pragma solidity ^0.7.0;\n    contract C {\n        address owner;\n        string private name;\n        constructor() {\n            owner = msg.sender;\n        }\n        modifier onlyOwner() {\n            require(msg.sender == owner, 'Not Owner');\n            _;\n        }\n        function setName(string memory newName) public onlyOwner{\n            name = newName;\n        }\n    }\n    ```\n\n  * “_;” is a special code only used in the function modifier. It instructs solidity to run the code in the function. It' indicates where “the rest” of the function code should go by merging the function source with the modifier code.\n  * \"_;\" can be used to execute the function modifier and then the function or execute the function and then the function modifier by placing \"_;\" before or after the modifier code;\n"
        },
        {
          "title": "Error Handling",
          "shortTitle": "Error Handling",
          "key": "errors",
          "details": "- Solidity uses state-reverting exceptions to handle errors. Such an exception undoes all changes made to the state in the current call (and all its sub-calls) and flags an error to the caller.\n- Solidity has many functions for error handling. Errors can occur at compile time or runtime.\n  Solidity is compiled to byte code and there a syntax error check happens at compile-time, while runtime errors occur mainly while executing the contracts. Some of the runtime errors are out-of-gas error, data type overflow error, divide by zero error, array-out-of-index error, etc.\n- Error handling in solidity is done using revert, require, assert and try/catch.\n- Solidity has built-in errors `Error(string)` and `Panic(uint256)` which are handled by functions `require` and `assert`.\n  Error is used for “regular” error conditions while Panic is used for errors that should not be present in bug-free code.\n\n- Panic via `assert`\n  * The assert function creates an error of type Panic(uint256).\n  * Assert should only be used to test for internal errors, and to check invariants. Properly functioning code should never create a Panic, not even on invalid external input. If this happens, then there is a bug in your contract which you should fix.\n  * A Panic exception is generated in the following situations.\n    * If you call assert with an argument that evaluates to false.\n    * If an arithmetic operation results in underflow or overflow.\n    * If you divide or modulo by zero.\n    * If you convert a value that is too big or negative into an enum type.\n    * If you call .pop() on an empty array.\n    * If you access an array or an array slice at an out-of-bounds or negative index.\n    * If you allocate too much memory or create an array that is too large.\n    * If you call a zero-initialized variable of internal function type.\n  * In the code snippet below , For large vaues of variables a and b , a+b might give an overflow and hence make the statement `c<=a` false resulting in a Panic generated by the assert statement.\n   ```\n   contract Assert {\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\n            uint256 c = a + b;\n            assert(c >= a);\n            \n            return c;\n        }\n    }\n   ```\n\n- Error via require\n  * The require function is used to guarantee valid conditions that cannot be detected before execution. It checks conditions on input, contract state variables or return values from calls to external contracts.\n  * It accepts a single argument and returns a boolean value after evaluation, it also has a custom string message option. If false then exception is raised and execution is terminated. The unused gas is returned back to the caller and the state is reversed to its original state.\n  * An Error exception is generated by the compiler in the following cases-\n    * Calling require(x) where x evaluates to false.\n    * If you perform an external function call targeting a contract that contains no code.\n    * If you use revert() or revert(\"description\").\n    * If your contract receives Ether via a public function without payable modifier.\n    * If your contract receives Ether via a public getter function.\n  * For the following cases, the error data from the external call (if provided) is forwarded. This means that it can either cause an Error or a Panic (or whatever else was given):\n    * If a .transfer() fails.\n    * If you call a function via a message call but it does not finish properly (i.e., it runs out of gas, has no matching function, or throws an exception itself).\n    * f you create a contract using the new keyword but the contract creation does not finish properly.\n  * In the code snippet below , the account that invokes the function `idGenerator` must be an owner otherwise, require statement creates an error 'Only owner!'.\n    ```\n    function idGenerator() external view returns (uint) {\n    \n        require(msg.sender == lawyer, 'Only owner!');\n        \n        return uint(keccak256(abi.encode(block.timestamp, block.difficulty)));\n    }\n    ```\n\n- revert \n  * This statement is similar to the require statement. It does not evaluate any condition and does not depends on any state or statement. It is used to generate exceptions, display errors, and revert the function call.\n  * Calling a revert statement implies an exception is thrown, the unused gas is returned and the state reverts to its original state.  Revert is used to handle the same exception types as require handles, but with little bit more complex logic.\n  * In the code snippet below, the function checkOverflow throws an error exception with the string \"Overflow Exist\" in case the sum variable is out of bounds.\n    ```\n    function checkOverflow(uint _num1, uint _num2) public view returns(string memory, uint){\n        uint sum = _num1 + _num2;\n        if(sum < 0 || sum > 255){\n            revert(\" Overflow Exist\");\n        }\n        else{\n            return (\"No Overflow\", sum);\n        }\n          \n    }\n    ```\n\n- try/catch\n  * A failure in an external call can be caught using a try/catch statement.\n  * The try/ catch feature is only available for external calls.\n  * The try keyword has to be followed by an expression representing an external function call or a contract creation (new ContractName()).\n  * Code shown belows shows an example usage of a try/catch block.\n    ```\n      // SPDX-License-Identifier: GPL-3.0\n      pragma solidity >=0.8.1;\n\n      interface DataFeed { function getData(address token) external returns (uint value); }\n\n      contract FeedConsumer {\n          DataFeed feed;\n          uint errorCount;\n          function rate(address token) public returns (uint value, bool success) {\n              // Permanently disable the mechanism if there are\n              // more than 10 errors.\n              require(errorCount < 10);\n              try feed.getData(token) returns (uint v) {\n                  return (v, true);\n              } catch Error(string memory /*reason*/) {\n                  // This is executed in case\n                  // revert was called inside getData\n                  // and a reason string was provided.\n                  errorCount++;\n                  return (0, false);\n              } catch Panic(uint /*errorCode*/) {\n                  // This is executed in case of a panic,\n                  // i.e. a serious error like division by zero\n                  // or overflow. The error code can be used\n                  // to determine the kind of error.\n                  errorCount++;\n                  return (0, false);\n              } catch (bytes memory /*lowLevelData*/) {\n                  // This is executed in case revert() was used.\n                  errorCount++;\n                  return (0, false);\n              }\n          }\n      }\n    ```\n  * Solidity supports different kinds of catch blocks depending on the type of errors.\n  * `catch Error(string memory reason) { ... }`, This catch clause is executed if the error was caused by `revert(\"reasonString\")` or `require(false, \"reasonString\")` (or an internal error that causes such an exception).\n  * `catch Panic(uint errorCode) { ... }`, If the error was caused by a panic, i.e. by a failing assert, division by zero, invalid array access, arithmetic overflow and others, this catch clause will be run.\n  * `catch (bytes memory lowLevelData) { ... }`, This clause is executed if the error signature does not match any other clause, if there was an error while decoding the error message, or if no error data was provided with the exception. The declared variable provides access to the low-level error data in that case.\n  * We can just use catch { … } if we are not interested in error data.\n\n- custom errors\n  * Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors.\n  * You can already use strings to give more information about failures (e.g., revert(\"Insufficient funds.\");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.\n  * Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).\n  * They have to be used together with the revert statement which causes all changes in the current call to be reverted and passes the error data back to the caller.\n  * The example below shows use of error with the revert statement.\n    ```\n      // SPDX-License-Identifier: GPL-3.0\n      pragma solidity ^0.8.4;\n\n      error InsufficientBalance(uint256 available, uint256 required);\n\n      contract TestToken {\n          mapping(address => uint) balance;\n          function transfer(address to, uint256 amount) public {\n              if (amount > balance[msg.sender])\n                  revert InsufficientBalance({\n                      available: balance[msg.sender],\n                      required: amount\n                  });\n              balance[msg.sender] -= amount;\n              balance[to] += amount;\n          }\n      }\n    ```\n\n\n\n\n  \n"
        }
      ]
    },
    {
      "title": "Types",
      "key": "data-types",
      "details": "This chapter explains the basics of data types used in Solidity.",
      "order": 1,
      "questions": [
        {
          "uuid": "89128b13-bd0f-4887-85c4-1308dfbc3234",
          "type": "MultipleChoice",
          "content": "Which of the following are not valid data types in solidity?",
          "hint": "noHint",
          "explanation": "floating point data and character data types are not valid in solidity.",
          "answerKeys": [
            "B",
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "bool",
              "key": "A"
            },
            {
              "content": "float",
              "key": "B"
            },
            {
              "content": "address",
              "key": "C"
            },
            {
              "content": "char",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "5413170f-f8c0-40fd-b17a-9481650eaa72",
          "type": "SingleChoice",
          "content": "What is the default value of int data type in solidity?",
          "hint": "noHint",
          "explanation": "null and undefined do not exist in solidity.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "null",
              "key": "A"
            },
            {
              "content": "0",
              "key": "B"
            },
            {
              "content": "undefined",
              "key": "C"
            },
            {
              "content": "1",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "165cc35e-7d95-4273-a61a-621916e5ef05",
          "type": "SingleChoice",
          "content": "Which of the following statements is incorrect regarding data types in solidity?",
          "hint": "noHint",
          "explanation": "The range of uintx in solidity is $[0,2^x -1]$, the range of intx is $[-2^{x-1},2^{x-1}-1]$ , boolean values only take true/false values and address literals take 20 bytes hexadecimal values.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "The range of uint32 data type is from 0 upto $2^{32} -1$",
              "key": "A"
            },
            {
              "content": "Bool data type can only take true and false values.",
              "key": "B"
            },
            {
              "content": "The range of int256 data type is from $-2^{256}+1$ to $2^{256}-1$",
              "key": "C"
            },
            {
              "content": "address data type holds a 20 byte value",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f54382c5-2dfc-4cd8-9e29-5d764cf59d53",
          "type": "SingleChoice",
          "content": "Which of the following statements about address data type in solidity are not correct?",
          "hint": "address holds a 20 byte value.",
          "explanation": "address payable is same as address but with aditional members send and transfer.",
          "answerKeys": [
            "A",
            "B",
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "Address payable has a larger size compared to address.",
              "key": "A"
            },
            {
              "content": "Implicit type conversion from address payable to address are not allowed.",
              "key": "B"
            },
            {
              "content": "If you need a variable of type address and plan to send Ether to it, then declare its type as address payable.",
              "key": "C"
            },
            {
              "content": "Explicit conversion of data type byte 32 to address is allowed.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d5773538-949b-4909-b91e-5f035808b8bc",
          "type": "SingleChoice",
          "content": "Which of the following is not a valid member of type `address`?",
          "hint": "noHint",
          "explanation": "keccak256 is a globally available function in solidity used to calculate the `keccak256` hash of an input . balance , codehash and transfer are methods of the address type.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "balance",
              "key": "A"
            },
            {
              "content": "keccak256",
              "key": "B"
            },
            {
              "content": "codehash",
              "key": "C"
            },
            {
              "content": "transfer",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b6a45240-74b1-4243-b3b1-9c42c154be7e",
          "type": "MultipleChoice",
          "content": "Which of the following are true regarding constant and immutable variables in solidity?",
          "hint": "these variables cannot be modified after the contract has been constructed.",
          "explanation": "For constant variables, the value has to be a constant at compile time and it has to be assigned where the variable is declared whearas immutables are a little less restrictive and can be assigned an arbitrary value in the constructor of the contract or at the point of their declaration.",
          "answerKeys": [
            "A",
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "For constant variables, the value has to be fixed at compile-time. For immutable, value can be assigned at construction time.",
              "key": "A"
            },
            {
              "content": "Compared to regular state variables, the gas costs of constant & immutable variables are much higher.",
              "key": "B"
            },
            {
              "content": "Variables declared as immutable are a bit less restricted than those declared as constant.",
              "key": "C"
            },
            {
              "content": "Immutable variables can be assigned more than once.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b0c8e946-2740-499a-9863-3173f1dc8a52",
          "type": "SingleChoice",
          "content": "in solidity `0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF` is an example of-",
          "hint": "noHint",
          "explanation": "addresses holds 20 byte hexadecimal literals.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "address",
              "key": "A"
            },
            {
              "content": "uint",
              "key": "B"
            },
            {
              "content": "string",
              "key": "C"
            },
            {
              "content": "array",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "944228da-440e-43d3-b0b8-a9a3751aa5b9",
          "type": "SingleChoice",
          "content": "which of the following is not a valid `array` declaration?",
          "hint": "noHint",
          "explanation": "`type arrayName [ arraySize ];` declares an array of fixed size in Solidity,\n`type[] arrayName;` declares an array of dynamic size in solidity.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`uint arr[10];`",
              "key": "A"
            },
            {
              "content": "`int []arr;`",
              "key": "B"
            },
            {
              "content": "`uint arr[] = [1,2,3];`",
              "key": "C"
            },
            {
              "content": "`int [3]arr;`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "42d6e1ad-75b3-41a8-88d7-7aa7f958619f",
          "type": "SingleChoice",
          "content": "What will be the value of `arr[arr.length-2]` after execution of the following code?\n```\n        uint[] arr;\n        arr = [1,2,3];\n        arr.push(1);\n        arr.push(2);\n        delete arr[1];\n        arr.pop();\n```\n",
          "hint": "delete method does not change the length of the array.",
          "explanation": "`array.push(x)` is used to add element x to the end of the array , `array.length` returns the length of the array \nand `delete array[x]` deletes the item at index x of the array and leaves all other elements and the length of \nthe array untouched.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "1",
              "key": "A"
            },
            {
              "content": "undefined",
              "key": "B"
            },
            {
              "content": "2",
              "key": "C"
            },
            {
              "content": "3",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2865fa2d-80a9-468d-9332-ab73613c216e",
          "type": "MultipeChoice",
          "content": "Which of the following statements is correct about arrays in solidity ?",
          "hint": "arrays in solidity are homogenous.",
          "explanation": "`arrays` in solidity can store \"value-types\" like boolean , integers etc and can be declared with the new keyword. \nArray indexing in solidity starts with 0 like most other programming languages.\n",
          "answerKeys": [
            "B",
            "C",
            "D"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "They can hold values of different data types.",
              "key": "A"
            },
            {
              "content": "They can hold primitive data types like uint, bool , address , or string.",
              "key": "B"
            },
            {
              "content": "Array indexing in solidity starts with 0.",
              "key": "C"
            },
            {
              "content": "`uint arr[] = new uint[](3)` is a valid array declaration.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b16b49ad-c70d-4c19-a19f-b51521a8f3b0",
          "type": "MultipleChoice",
          "content": "Which of the following statements is correct about enums?",
          "hint": "Enums can have a maximum of 256 members.",
          "explanation": "The options in enum are represented by subsequent unsigned integer values starting from 0. Using `type(NameOfEnum).min` and `type(NameOfEnum).max` you can get the smallest and respectively largest value of the given enum.",
          "answerKeys": [
            "A",
            "C",
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "They require at least one member, and its default value when declared is the first member.",
              "key": "A"
            },
            {
              "content": "They cannot have more than 128 members.",
              "key": "B"
            },
            {
              "content": "Their options are represented by subsequent unsigned integer values starting from 0.",
              "key": "C"
            },
            {
              "content": "`type(NameOfEnum).min` gives the smallest value in the enum.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "663929a6-3a12-43fd-b0ff-ac07c2e34467",
          "type": "SingleChoice",
          "content": "Which of the following is not a reference type?",
          "hint": "noHint",
          "explanation": "enum is a value type.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "arrays",
              "key": "A"
            },
            {
              "content": "mapping",
              "key": "B"
            },
            {
              "content": "struct",
              "key": "C"
            },
            {
              "content": "enum",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d118157f-2d86-4ee3-bedc-de508017477a",
          "type": "MultipleChoice",
          "content": "Which of the following is not a valid data location for a reference data type in solidity?",
          "hint": "noHint",
          "explanation": "address is a value type in solidity whearas memory , storage and calldata are data locations for \"reference-types\".",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "memory",
              "key": "A"
            },
            {
              "content": "storage",
              "key": "B"
            },
            {
              "content": "address",
              "key": "C"
            },
            {
              "content": "calldata",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1e3a6ea0-7b36-4e11-98c5-d4fd9f3e49e1",
          "type": "SingleChoice",
          "content": "`uint[][5]` in solidity is -",
          "hint": "two dimensional arrays can be initialized in solidity.",
          "explanation": "An array of 5 dynamic arrays of uint is written as `uint[][5]`. The notation is reversed compared to some other \nlanguages. In Solidity, X[3] is always an array containing three elements of type X, even if X is itself an array. \nThis is not the case in other languages such as C.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "Incorrect way to initialize array",
              "key": "A"
            },
            {
              "content": "A dynamic array of 5 arrays",
              "key": "B"
            },
            {
              "content": "An array of 5 dynamic arrays",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "723b95b6-504c-41ff-9b16-22f22756fadd",
          "type": "SingleChoice",
          "content": "Which of the following is the correct way to compare two strings str1 and str2 in solidity?",
          "hint": "noHint",
          "explanation": "Solidity does not have string manipulation functions, but there are third-party string libraries. You can also \ncompare two strings by their keccak256-hash using  `keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))` \nand concatenate two strings using `string.concat(s1, s2)`.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`str1 == str2`",
              "key": "A"
            },
            {
              "content": "`keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))`",
              "key": "B"
            },
            {
              "content": "`string.concat(s1, s2)`",
              "key": "C"
            },
            {
              "content": "All of above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b4b39948-5ba0-4791-886f-84ebae031b46",
          "type": "SingleChoice",
          "content": "What does the following syntax do?\n```\n      using SafeMath for uint;\n```\n",
          "hint": "SafeMath is a library and can be imported in solidity.",
          "explanation": "Arithmetic operations in Solidity wrap on overflow. This can easily result in bugs. Using SafeMath reverts the transaction when an operation overflows.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Imports the SafeMath library",
              "key": "A"
            },
            {
              "content": "Makes uint variable immutable",
              "key": "B"
            },
            {
              "content": "Links SafeMath to uint types",
              "key": "C"
            },
            {
              "content": "Sets the SafeMath variable to an uint",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6d21e243-1d81-4946-8c3d-1e19df119599",
          "type": "SingleChoice",
          "content": "Which of the following is an example of int8?",
          "hint": "What is the range of values int8 can take?",
          "explanation": "int8 can take values from -127 to 128.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Null",
              "key": "A"
            },
            {
              "content": "-255",
              "key": "B"
            },
            {
              "content": "0",
              "key": "C"
            },
            {
              "content": "1000",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "9e320266-d211-42d2-9931-c3bc2e7401ac",
          "type": "SingleChoice",
          "content": "Which of the following is an example of a byte value?",
          "hint": "bytes can accept hexadecimal values.",
          "explanation": "The bytes data type in Solidity is a dynamically sized `byte[]` array and can accept hexadecimal values beginning with 0x.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`0x65`",
              "key": "A"
            },
            {
              "content": "True/False",
              "key": "B"
            },
            {
              "content": "Hello World!",
              "key": "C"
            },
            {
              "content": "`[10,20,30]`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "0251f4f5-c96b-4018-b33c-cf570ebfe638",
          "type": "SingleChoice",
          "content": "What is wrong with the following code ?\n```\n// SPDX-License-Identifier: GPL-3.0\n  pragma solidity >=0.4.16 <0.9.0;\n\n  contract C {\n      function f(uint len) public pure {\n          uint[] memory a = new uint[](7);\n          b[6] = 8;\n          b.push(5);\n  }\n}\n```\n",
          "hint": "noHint",
          "explanation": "Memory arrays cannot be extended during runtime. The member function push does not exist. If you need to resize your memory array, you need to create a new array with the desired length and copy every element from the old array.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It is not not possible to declare an array with new keyword",
              "key": "A"
            },
            {
              "content": "`b[6]=8` is incorrect assignment for a memory array",
              "key": "B"
            },
            {
              "content": "It is not not possible to use push function with a memory array",
              "key": "C"
            },
            {
              "content": "The code is correct",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f92bdc52-4d0f-44de-b763-0462f3fe65c7",
          "type": "SingleChoice",
          "content": "Statement 1- The array literal `[-1,1]` is invalid. \nStatement 2- Calling `push()` member function on an array can be used to append a zero-initialized element at the end of the array.\nWhich of the following options is correct?\n",
          "hint": "noHint",
          "explanation": "The array literal `[1, -1]` is invalid because the type of the first expression is uint8 while the type of the \nsecond is int8 and they cannot be implicitly converted to each other. To make it work, you can use `[int8(1), -1]`, \nfor example. Methods `.push()` and `.push(value)` can be used to append a new element at the end of the array, \nwhere .push() appends a zero-initialized element and returns a reference to it.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement 1 is true.",
              "key": "A"
            },
            {
              "content": "Statement 2 is true.",
              "key": "B"
            },
            {
              "content": "Both are true.",
              "key": "C"
            },
            {
              "content": "Neither is true.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8adbf18e-9fbb-416b-b0a0-b319e642b936",
          "type": "MultipleChoice",
          "content": "Which of the following statements is correct?",
          "hint": "noHint",
          "explanation": "It is not possible for a struct to contain a member of its own type, although the struct itself can be the value type of a mapping member or it can contain a dynamically-sized array of its type. Struct types can be used inside mappings and arrays and they can themselves contain mappings and arrays.",
          "answerKeys": [
            "B",
            "C"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It is possible for a struct to contain a member of its own type.",
              "key": "A"
            },
            {
              "content": "The dot operator is used to access members of a struct.",
              "key": "B"
            },
            {
              "content": "Struct types can be used inside mappings and arrays and they can themselves contain mappings and arrays.",
              "key": "C"
            },
            {
              "content": "None of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "49928b3a-750a-42e3-a358-274275fa82a8",
          "type": "SingleChoice",
          "content": "Which of the following statements is correct about mapping data type?",
          "hint": "noHint",
          "explanation": "Mappings can only have a data location of storage. The KeyType can be any built-in value type, bytes, string, or any contract or enum type. Other user-defined or complex types, such as mappings, structs or array types are not allowed. ValueType can be any type, including mappings, arrays and structs.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "User-defined or complex types, such as mappings, structs or array types are not allowed as key and \"value-types\" in a mapping.",
              "key": "A"
            },
            {
              "content": "Mappings can have any data location.",
              "key": "B"
            },
            {
              "content": "All primitive data types are allowed as key and value pairs.",
              "key": "C"
            },
            {
              "content": "All of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "861e7d61-22e2-48db-b6e9-5f95c4b0fbaa",
          "type": "SingleChoice",
          "content": "In the following code snippets where is implicit type conversion possible?",
          "hint": "noHint",
          "explanation": "In the example below, y and z, the operands of the addition, do not have the same type, but uint8 can be implicitly converted to uint16 and not vice-versa.  uint8 is convertible to uint16 and int128 to int256, but int8 is not convertible to uint256, because uint256 cannot hold values such as -1.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "uint8 x; uint16 y; uint32 z=x+y;",
              "key": "A"
            },
            {
              "content": "uint8 x; uint16 y; uint8 z=x+y;",
              "key": "B"
            },
            {
              "content": "int8 x; uint16 y; uint32 z=x+y;",
              "key": "C"
            },
            {
              "content": "Implicit Type conversion is not possible in Solidity.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e383c36b-6272-4467-ae2e-c69c22ce60bc",
          "type": "SingleChoice",
          "content": "What is the correct declaration for a mapping type ?",
          "hint": "noHint",
          "explanation": "mapping types use the syntax `mapping(KeyType => ValueType)` and variables of mapping type are declared using \nthe syntax `mapping(KeyType => ValueType)` VariableName`. The KeyType can be any built-in value type, bytes, string, \nor any contract or enum type. Other user-defined or complex types, such as mappings, structs or array types are \nnot allowed. ValueType can be any type, including mappings, arrays and structs.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "mapping-type"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`mapping(uint -> address) someMapping;`",
              "key": "A"
            },
            {
              "content": "`mapping(struct -> address) someMapping;`",
              "key": "B"
            },
            {
              "content": "`mapping (uint => address) someMapping;`",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "63af76dd-2db1-4b0b-bc49-9fa5deb0b6a5",
          "type": "MultipleChoice",
          "content": "Which of the following statements is correct about fixed point numbers?",
          "hint": "noHint",
          "explanation": "Signed and unsigned fixed point number of various sizes. Keywords ufixedMxN and fixedMxN, where M represents the number of bits taken by the type and N represents how many decimal points are available. M must be divisible by 8 and goes from 8 to 256 bits. N must be between 0 and 80, inclusive. ufixed and fixed are aliases for ufixed128x18 and fixed128x18, respectively.",
          "answerKeys": [
            "A",
            "B",
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "They can be declared with Keywords `ufixedMxN` and `fixedMxN`.",
              "key": "A"
            },
            {
              "content": "Fixed point numbers are not fully supported by Solidity yet. They can be declared, but cannot be assigned to or from.",
              "key": "B"
            },
            {
              "content": "M represents the number of bits taken by the type and N represents how many decimal points are available.",
              "key": "C"
            },
            {
              "content": "M must be divisible by 8 and goes from 2 to 128 bits. N must be between 0 and 16, inclusive.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "794197c0-6a38-49af-a8ce-52c116ee3cee",
          "type": "SingleChoice",
          "content": "Comparison operators like <= , >= are not applicable to which of the following value types?",
          "hint": "noHint",
          "explanation": " '!' , '&&' , '||' , '==' , '!=' work with booleans. Comparison operators like <=, < etc do not work with booleans in solidity .",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "bool",
              "key": "A"
            },
            {
              "content": "uint",
              "key": "B"
            },
            {
              "content": "int",
              "key": "C"
            },
            {
              "content": "address",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "68640698-1c5f-4afb-8164-fe55360e698a",
          "type": "SingleChoice",
          "content": "Regarding comparison of strings in solidity , based on the statements below , which of the following options is correct?\nStatement 1 - Compare with the use of hashes. \nStatement 2 - Check by comparing each character including the length check.\n",
          "hint": "Solidity does not have string manipulation functions.",
          "explanation": "For longer strings it is cost efficient to hash the string and then compare the byte value of the hashes.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement 1 is more gas efficient for longer strings than statement 2.",
              "key": "A"
            },
            {
              "content": "Statement 2 is more gas efficient for longer strings than statement 1.",
              "key": "B"
            },
            {
              "content": "Both statements give almost the same gas cost.",
              "key": "C"
            },
            {
              "content": "There is no gas cost in comparison between strings.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "05680353-3068-486e-ac07-ddc278b06a20",
          "type": "SingleChoice",
          "content": "Which of the following is not a valid address ?",
          "hint": "noHint",
          "explanation": "addresses hold 20 byte hexadecimal values.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9`",
              "key": "A"
            },
            {
              "content": "`0x577a6E294505A797976f218eFd751aB5557E1522`",
              "key": "B"
            },
            {
              "content": "`0xc0ffee254729296a45a3885639AC7E10F9d54979`",
              "key": "C"
            },
            {
              "content": "`0x1011526z3H3fg4445xx556tuoa72288884869aAzl`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "26ca32d3-bc08-41b9-b24a-9cee819a6a34",
          "type": "MultipleChoice",
          "content": "Which of the following is true about address in ethereum and solidity?",
          "hint": "address takes hexadecimal values . what are hexadecimal values?",
          "explanation": "An address is always prefixed with 0x as it is represented in hexadecimal format (base 16 notation). Numbers 0-9 and alphabets a-f are all valid characters in an ethereum address.",
          "answerKeys": [
            "A",
            "B",
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It corresponds to the last 20 bytes of the Keccak-256 hash of the public key.",
              "key": "A"
            },
            {
              "content": "An address is always prefixed with 0x as it is represented in hexadecimal format (base 16 notation).",
              "key": "B"
            },
            {
              "content": "Numbers 0-9 and alphabets a-z are all valid characters in an ethereum address.",
              "key": "C"
            },
            {
              "content": "The case sensitivity is used for checksum validation.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8b5b134a-af35-478c-bd53-8ddfb5471646",
          "type": "MultipleChoice",
          "content": "Which of the following statements is correct about send and transfer functions of the address value type?",
          "hint": "noHint",
          "explanation": "It is possible to query the balance of an address using the property balance and to send Ether (in units of wei) to a payable address using the transfer function. Send is the low-level counterpart of transfer.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Transfer is the low level counterpart of send.",
              "key": "A"
            },
            {
              "content": "Transfer and send are used to send ether (in units of ETH) to a payable address.",
              "key": "B"
            },
            {
              "content": "In order to make a safe ether transaction it is better to use transfer.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "939f30f4-dcfd-4dea-8c48-94e32a0079c5",
          "type": "SingleChoice",
          "content": "Consider the following statements.\nStatement 1 - code is used to get the EVM bytecode as a byte memory, codehash is used to get the Keccak-256 hash of that code (as a bytes32).\nStatement 2 - `keccak256(address.code)` is cheaper than using `address.codehash`.\nWhich of the following options is correct considering the code and codehash methods of the address type.\n",
          "hint": "noHint",
          "explanation": "Use .code to get the EVM bytecode as a bytes memory, which might be empty. Use .codehash get the Keccak-256 hash of that code (as a bytes32). Note that addr.codehash is cheaper than using keccak256(addr.code).",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Both Statement 1 and Statement 2 are correct.",
              "key": "A"
            },
            {
              "content": "Statement 1 is correct but Statement 2 is incorrect.",
              "key": "B"
            },
            {
              "content": "Statement 2 is correct but Statement 1 is incorrect.",
              "key": "C"
            },
            {
              "content": "Neither of the statements is correct.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "caa00c9b-61e5-4224-82fa-9a0bb613d436",
          "type": "MultipleChoice",
          "content": "Which of the following options is correct regarding a user defined value type defined by the syntax `type C is V ;` in solidity.",
          "hint": "noHint",
          "explanation": "A user defined value type is defined using type C is V, where C is the name of the newly introduced type and V has to be a built-in value type (the “underlying type”). The function C.wrap is used to convert from the underlying type to the custom type. Similarly, the function C.unwrap is used to convert from the custom type to the underlying type.The type C does not have any operators or bound member functions. In particular, even the operator == is not defined. Explicit and implicit conversions to and from other types are disallowed.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "V is the name of the newly introduced data type.",
              "key": "A"
            },
            {
              "content": "The type V does not have any operators or bound member functions. In particular, even the operator == is not defined.",
              "key": "B"
            },
            {
              "content": "The function `C.wrap` is used to convert from the underlying type to the custom type. Similarly, the function `C.unwrap` is used to convert from the custom type to the underlying type.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b0134cbb-b413-4e42-8030-7221df128b4e",
          "type": "MultipleChoice",
          "content": "In solidity , contract types are -",
          "hint": "noHint",
          "explanation": "Solidity Contracts are like a class in any other object-oriented programming language.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Similar to classes in object oriented languages.",
              "key": "A"
            },
            {
              "content": "Similar to functions in object oriented languages.",
              "key": "B"
            },
            {
              "content": "Reference types.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "9c4a6edd-ee00-43f2-a097-05fc166e243b",
          "type": "SingleChoice",
          "content": "Which of the following statements are correct regarding variable declaration in solidity?",
          "hint": "noHint",
          "explanation": "A variable name should not match with reserved keywords. Variable names must start with a letter or an underscore (_), and may contain letters from “a to z” or “A to Z” or digits from “0 to 9” and characters also. The name of variables are case sensitive.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "A variable name should not match with reserved keywords.",
              "key": "A"
            },
            {
              "content": "Variable names cannot start with underscore.",
              "key": "B"
            },
            {
              "content": "variables are case insensitive , var123 and VAR123 are same variables.",
              "key": "C"
            },
            {
              "content": "none of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "69254f63-d913-4863-a7b2-8398986ccd09",
          "type": "MultipleChoice",
          "content": "Which of the following is correct about contract types in solidity?",
          "hint": "hint",
          "explanation": "explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Contracts support comparison operators.",
              "key": "A"
            },
            {
              "content": "The members of contract types are all the functions of the contract including all state variables.",
              "key": "B"
            },
            {
              "content": "A contract cannot create other contracts using the new keyword.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "270dfe5f-a833-472c-ad07-3ce1942780b0",
          "type": "MultipleChoice",
          "content": "Which among the following is  a valid data storage location for mapping type?",
          "hint": "noHint",
          "explanation": "Mappings can only have a data location of storage.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "mapping-type"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "memory",
              "key": "A"
            },
            {
              "content": "storage",
              "key": "B"
            },
            {
              "content": "calldata",
              "key": "C"
            },
            {
              "content": "staticcall",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "653b974e-d79d-4103-a2ff-57a86506ada3",
          "type": "MultipleChoice",
          "content": "The declaration below in solidity is an example of which type? \n   `function f() public payable returns (bytes4){}`\n",
          "hint": "noHint",
          "explanation": "`function f() public payable returns (bytes4){}` is a fuction declaration.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Contract type",
              "key": "A"
            },
            {
              "content": "Function type",
              "key": "B"
            },
            {
              "content": "Reference type",
              "key": "C"
            },
            {
              "content": "Mapping type",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "fec5256b-0f13-49b3-a01f-dd9c40543497",
          "type": "MultipleChoice",
          "content": "Which access classifier is used with a function type to only access it in the contract it is declared in ?",
          "hint": "private is a subset of internal and external is a subset of public.",
          "explanation": "public - all can access\nexternal - Cannot be accessed internally, only externally\ninternal - only this contract and contracts deriving from it can access\nprivate - can be accessed only from this contract\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "public",
              "key": "A"
            },
            {
              "content": "private",
              "key": "B"
            },
            {
              "content": "internal",
              "key": "C"
            },
            {
              "content": "external",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b6b96712-83df-49b7-8b54-cab1d3630e3d",
          "type": "MultipleChoice",
          "content": "In the context of memory arrays which of the following statements are true?",
          "hint": "hint",
          "explanation": "Memory arrays with dynamic length can be created using the new operator. As opposed to storage arrays, it is not possible to resize memory arrays (e.g. the .push member functions are not available). The Solidity Smart Contract can use any amount of memory during the execution but once the execution stops, the Memory is completely wiped off for the next execution.",
          "answerKeys": [
            "A",
            "D"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "they can be declared with the syntax , `uint[] memory a = new uint[](size);`",
              "key": "A"
            },
            {
              "content": "to add an element to the array , `push()` function is used.",
              "key": "B"
            },
            {
              "content": "You can acess values in a memory array after execution of the smart contract.",
              "key": "C"
            },
            {
              "content": "They cost less gas compared to storage arrays.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "bb55a93a-05b2-4ea5-83b4-bd307cdf6c51",
          "type": "MultipleChoice",
          "content": "\"What will be the value of the following syntax executed in solidity?\n   `255 + (true ? 1 : 0)`\n",
          "hint": "The ternary operator is used in expressions of the form <expression> ? <trueExpression> : <falseExpression>. It evaluates one of the latter two given expressions depending upon the result of the evaluation of the main <expression>. If <expression> evaluates to true, then <trueExpression> will be evaluated, otherwise <falseExpression> is evaluated.",
          "explanation": "The result type is determined from the types of the two operands in the ternary operator, converting to their mobile type first if required. As a consequence, 255 + (true ? 1 : 0) will revert due to arithmetic overflow. The reason is that (true ? 1 : 0) is of uint8 type, which forces the addition to be performed in uint8 as well, and 256 exceeds the range allowed for this type.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "255",
              "key": "A"
            },
            {
              "content": "256",
              "key": "B"
            },
            {
              "content": "0",
              "key": "C"
            },
            {
              "content": "the above statement will revert.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "a2bc4929-787b-4184-959c-480659493663",
          "type": "SingleChoice",
          "content": "In the following code snippet which line will result in an error-\n  ```\n  // SPDX-License-Identifier: MIT\n  pragma solidity ^0.8.10;\n  contract C {\n\n      //line 1\n      uint public x = 1;\n\n      // line 2\n      function addToX(uint y) public pure returns (uint) {\n          return x + y;\n      }\n\n      // line 3\n      function add(uint i, uint j) public pure returns (uint) {\n          return i + j;\n      }\n  }\n```\n",
          "hint": "Check whether the function declaration is correct.",
          "explanation": "Pure declares that no state variable will be changed or read in a function. view tells us that by running the function, no data will be saved/changed. Here in line 2 a pure function is trying to read the data from a state variable. The declaration should have a view instead of pure.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Line 1",
              "key": "A"
            },
            {
              "content": "Line 2",
              "key": "B"
            },
            {
              "content": "Line 3",
              "key": "C"
            },
            {
              "content": "The code snippet will not give any error",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "487d03f1-4e30-447e-86e3-ec74ef4984bc",
          "type": "MultipleChoice",
          "content": "You have a list of teams and their respective scores in a tournament. You are trying to work up some logic in a contract in solidity to efficiently retrieve the scores . Which of the following data types should you use to keep track of the scores?",
          "hint": "Which data type can be used to store a grouping of data and has greater efficiency when you want to fetch some unique value.",
          "explanation": "A mapping is a table of keys and values (each with a pre-defined type). Fetching a piece of data from a mapping is far more efficient than fetching the same data from an array. To fetch data from an array requires iterating over the whole array until you find the element you're looking for.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "reference-types",
            "mapping-type"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "enum",
              "key": "A"
            },
            {
              "content": "Multi dimensional arrays",
              "key": "B"
            },
            {
              "content": "strings",
              "key": "C"
            },
            {
              "content": "mappings",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "4e60aee2-0a82-44f1-a173-17cf88872017",
          "type": "SingleChoice",
          "content": "On execution of the following code what will be the value of balance?\n```solidity\n   uint8 balance = 255;\n   balance++;\n```\n",
          "hint": "Think of the range of values uint 8 can have .",
          "explanation": "If you execute the code above the \"balance\" will be 0. This is a simple example of overflow. If you add 1 to binary 11111111, it resets back to 00000000. In Solidity 0.8, the compiler will automatically take care of checking for overflows and underflows.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "256",
              "key": "A"
            },
            {
              "content": "0",
              "key": "B"
            },
            {
              "content": "255",
              "key": "C"
            },
            {
              "content": "-255",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d9e1ab62-0af2-457b-b770-d21dc954b76d",
          "type": "MultipleChoice",
          "content": "Which of the following statements are correct in the context of storage and memory data locations ?",
          "hint": "Think of how storage and memory affects the gas cost and how the code can be optimized.",
          "explanation": "Every transaction on Ethereum Virtual Machine costs us some amount of Gas. The lower the Gas consumption the better is your Solidity code. The Gas consumption of Memory is not very significant as compared to the gas consumption of Storage. Therefore, it is always better to use Memory for intermediate calculations and store the final result in Storage.",
          "answerKeys": [
            "A",
            "B",
            "C"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Hard",
          "choices": [
            {
              "content": "Memory in solidity is a temporary storage.",
              "key": "A"
            },
            {
              "content": "Storage is persistent and holds data between function calls.",
              "key": "B"
            },
            {
              "content": "State variables and Local Variables of structs, array are always stored in storage by default. Function arguments are in memory.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "94432d54-9f7c-4b53-be49-314a4aa94d5a",
          "type": "SingleChoice",
          "content": "Look at the code snippet below,\n```solidity\n           pragma solidity ^0.5.0;\n           contract SolidityTest {\n             uint storedData;     \n             constructor() public {\n                 storedData = 10;   \n             }\n           }\n```\nWhat type of variable is storedData declared in the SolidityTest contract?\"\n",
          "hint": "noHint",
          "explanation": "State Variables , Variables whose values are permanently stored in a contract storage.\nLocal Variables , Variables whose values are present till function is executing.\nGlobal Variables , Special variables which exist in the global namespace used to get information about the blockchain.\n",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "State Variables",
              "key": "A"
            },
            {
              "content": "Local Variables",
              "key": "B"
            },
            {
              "content": "global Variables",
              "key": "C"
            },
            {
              "content": "None of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6b728a07-8caf-47d0-b62d-2e97c5b2ff32",
          "type": "MultipeChoice",
          "content": "Which of the following is a valid enum declaration in solidity?",
          "hint": "there must be atleast one option in enum.",
          "explanation": "you cant use numbers (positive or negative) or boolean (true or false in lowercase) as members for an enum. However, True and False (Capitalized) are accepted.",
          "answerKeys": [
            "B",
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "`enum integers {  1 , 2 , 3 , 4 }`",
              "key": "A"
            },
            {
              "content": "`enum values { one , two , three }`",
              "key": "B"
            },
            {
              "content": "`enum myEnums { }`",
              "key": "C"
            },
            {
              "content": "`enum booleans { True , False }`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "3648ad26-bb00-458d-afaa-0762e70a5dbe",
          "type": "SingleChoice",
          "content": "Consider the following code snippet ,\n```solidity\n              pragma solidity ^0.5.0;\n              contractC {\n                function foo(uint a) pure public returns (uint){\n                  return a << 2;\n                }\n              }\n```\nWhat will be the output when a uint value 3 is passed in the function foo of the contract C?\"\n",
          "hint": "The Left Shift operator (<<) moves all the bits in its first operand to the left by the number of places specified in the second operand.",
          "explanation": "x << y is equivalent to the mathematical expression x * 2**y.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Hard",
          "choices": [
            {
              "content": "0",
              "key": "A"
            },
            {
              "content": "1",
              "key": "B"
            },
            {
              "content": "8",
              "key": "C"
            },
            {
              "content": "12",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "203d97e1-7194-4373-b943-d89d06e35126",
          "type": "MultipleChoice",
          "content": "Which of the following are valid literals for solidity data types?",
          "hint": "noHint",
          "explanation": "2.5e1 is an integer literal , \"foo\" \"bar\" is equivalent to “foobar” which is a string literal and hex\"001122FF\" is an example of  hexadecimal literal which are prefixed with the keyword hex.",
          "answerKeys": [
            "A",
            "B",
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`2.5e1`",
              "key": "A"
            },
            {
              "content": " `'foo' 'bar'` ",
              "key": "B"
            },
            {
              "content": "`hex\"001122FF\"`",
              "key": "C"
            },
            {
              "content": "None of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2bb12876-aee8-4cbd-8662-e193bb5503aa",
          "type": "SingleChoice",
          "content": "Variable packing is one way solidity optimizes gas costs in storage state variables . Consider the following two examples of variable declarations.\nExample 1 -\n  ```solidity\n         uint128 a;\n         uint256 b;\n         uint128 c;\n  ```\nExample 2 -\n  ```solidity\n         uint128 a;\n         uint128 c;\n         uint256 b;\n  ```\nWhich of the following statements are correct regarding variable packing in the above examples.\"\n",
          "hint": "Solidity contracts have contiguous 32 byte (256 bit) slots used for storage.",
          "explanation": "In example 1 the variables are not packed. If b was packed with a, it would exceed the 32 byte limit so it is instead placed in a new storage slot. The same thing happens with c and b. In example 2 the  variables are packed. Because packing c with a does not exceed the 32 byte limit, they are stored in the same slot.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Hard",
          "choices": [
            {
              "content": "Variables in both examples 1 and 2 are packed.",
              "key": "A"
            },
            {
              "content": "Variables in example 1 are packed but not in example 2.",
              "key": "B"
            },
            {
              "content": "Variables in example 2 are packed but not in example 1.",
              "key": "C"
            },
            {
              "content": "Variables in neither examples 1 and 2 are packed.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "47e3f7e4-b2e6-4c0f-acd7-e7c960203710",
          "type": "SingleChoice",
          "content": "Consider the following code snippet ,\n  ```solidity\n  // SPDX-License-Identifier: GPL-3.0\n  pragma solidity ^0.8.8;\n  contract test {\n    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\n\n    function foo() public pure returns (ActionChoices) {\n        return type(ActionChoices).max;\n    }\n  }\n  ```\nWhat will be the output when the function foo is called?\n",
          "hint": ".max is used to get the largest value of the given enum.",
          "explanation": "Under the hood, enums are integers, not strings. Solidity will automatically handle converting enums to ints.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "`0:uint8: 3`",
              "key": "A"
            },
            {
              "content": "`0:uint8: 0`",
              "key": "B"
            },
            {
              "content": "`0:string: “SitStill”`",
              "key": "C"
            },
            {
              "content": "`0:string: “GoLeft”`",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "a150cd2d-1888-4210-8bee-9411eb25e3bf",
          "title": "Introduction to Solidity Data types",
          "shortTitle": "Data Types Intro - 1",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=N1Jeeei_wtw",
          "subTopics": [
            "value-types",
            "reference-types",
            "mapping-type"
          ],
          "details": "In this video we're looking at the data types available in Solidity.\nThis video explains about the use of -\n* Value Types - Integers , Booleans etc \n* Reference Types - Structs , Arrays .\n* Mapping Type - Mapping.\n"
        },
        {
          "uuid": "ee869939-2186-42bb-a8a0-de3fd366862e",
          "title": "Solidity Tutorial - Variable Types",
          "shortTitle": "Variable Types",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=TNZLonjrLYE",
          "subTopics": [
            "value-types",
            "reference-types",
            "mapping-type"
          ],
          "details": "In this video we are looking at an overview of all the variable types in Solidity and how to declare them.\nThis video explains about all the variables that can be declared using types : \n* uint\n* bytes32\n* string\n* bytes\n* arrays\n* mappings\n* structs\n* enums\n"
        },
        {
          "uuid": "747a3dca-1ba1-421e-adc0-b75f32b5ae99",
          "title": "Master Solidity Variables, Data Types, and Structs Master Solidity",
          "shortTitle": "Data Types Intro - 2",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=HxlxNwgoN8w",
          "subTopics": [
            "value-types",
            "reference-types",
            "mapping-type"
          ],
          "details": "In this video we are looking at different solidity types and variables.\nThis video explains all the different variables that can be declared (state variables and Local Variables).\n"
        },
        {
          "uuid": "cb6cf918-b9ac-4c65-8506-f5a0bb3564bf",
          "title": "Solidity Tutorial, Arrays (Declare, Read, Update, Delete).",
          "shortTitle": "Arrays",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=MPBOnChpi0c&list=PLbbtODcOYIoE0D6fschNU4rqtGFRpk3ea&index=14",
          "subTopics": [
            "reference-types"
          ],
          "details": "This video explains how to - \n- Declare arrays\n- Add elements\n- Read elements\n- Update elements\n- Delete elements\n- Iterate through elements  \n\nThis video further explores the differences between-\n- Fixed-size and Dynamic size\n- Storage and memory arrays  \n\nand it also covers how to accept arrays argument in Solidity functions and return arrays from solidity functions.\n"
        },
        {
          "uuid": "f936c72d-9d71-4c05-bf38-3b827b0d95f5",
          "title": "Solidity Tutorial: Mappings (simple mappings, nested mappings, array in mappings...)",
          "shortTitle": "Mappings",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=U-wWqTq1zoQ&list=PLbbtODcOYIoE0D6fschNU4rqtGFRpk3ea&index=15",
          "subTopics": [
            "mapping-type"
          ],
          "details": "This video explains how to declare and manipulate mappings in Solidity. It also covers simple mappings but also advanced mappings like nested mappings and array inside mappings. \n"
        },
        {
          "uuid": "7834704f-0749-4457-bd5b-7531ea34ff99",
          "title": "Solidity Tutorial, Arrays (Declare, Read, Update, Delete).",
          "shortTitle": "Arrays",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=UkdU0cuAp9U&list=PLbbtODcOYIoE0D6fschNU4rqtGFRpk3ea&index=16",
          "subTopics": [
            "reference-types"
          ],
          "details": "Solidity Structs allow you to represent structured data. This video explains how to declare, instantiate (create), read, update and delete structs in Solidity.\nIt will also show some more advanced struct manipulation like how to declare an array of structs and how to declare a mapping of structs.\n"
        },
        {
          "uuid": "83565016-2bf9-4b07-a0a3-938cbe86749f",
          "title": "Solidity Tutorial, Arrays (Declare, Read, Update, Delete).",
          "shortTitle": "Arrays",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=5ED_6FasZ68&list=PLbbtODcOYIoE0D6fschNU4rqtGFRpk3ea&index=17",
          "subTopics": [
            "reference-types"
          ],
          "details": "Solidity Enums allow you to represent optional data.\nThis video covers how to declare enums, use enums, accept enums as argument in solidity functions.\n"
        }
      ],
      "summaries": [
        {
          "title": "Value Types",
          "shortTitle": "Value Types",
          "key": "value-types",
          "details": "The following types are called value types because variables of these types will always be passed by value, i.e. unlike reference types they are always copied when used in function arguments or asssignments.\n- Booleans\n  * They are declared using the keyword `bool`.\n  * The possible values are constants true and false.\n\n- Integers\n  * They are declared using keywords `int` , `uint` for signed and unsigned integers.\n  * Keywords `uint8` to `uint256` in steps of 8 are used to store unsigned integers with varying sizes in bits. Similarly , `int8` to `int256` for signed integers.\n  * For Example, uint32 is a 32 bit unsigned integer having range from 0 to $2^{32}-1$ whearas int32 is a 32 bit signed integer having range from $-2^{31}$ to $2^{31}-1$.\n  * For an integer type X, you can use `type(X).min` and `type(X).max` to access the minimum and maximum value representable by the type.\n  * Integers allow the use of comparision (<=, <, ==, !=, >=, >) , bit (&, |, ^ , ~) , arithmetic (+, -, *, /, %, ** ) and shift (<< , >>) operators.\n  * `x << y` is equivalent to the mathematical expression $x * 2^y$. `x >> y` is equivalent to the mathematical expression $x / 2^y$.\n\n- Fixed Point Numbers\n  * They are declared using keywords `fixed` , `ufixed`.\n  * Keywords ufixedMxN and fixedMxN, where M represents the number of bits taken by the type and N represents how many decimal points are available. M must be divisible by 8 and goes from 8 to 256 bits. N must be between 0 and 80, inclusive.\n  * Fixed point numbers are not fully supported by Solidity yet. They can be declared, but cannot be assigned to or from.\n\n- Addresses\n  * They can be declared using keywords `address` and `address payable`.\n  * address type hold a 20 byte value (size of an Ethereum address).\n  * address payable is same as address, but with the additional members transfer and send.\n  * address payable is an address you can send Ether to.\n  * Implicit conversions from `address payable` to `address` are allowed, whereas conversions from address to address payable must be explicit via` payable(<address>)`.\n  * It is possible to query the balance of an address using the property `balance` and to send Ether (in units of wei) to a payable address using the `transfer` function.\n  * `send` is the low-level counterpart of `transfer`.\n\n- Contract types\n  * Every contract defines its own type.\n  * You can implicitly convert contracts to contracts they inherit from.\n\n- Enums\n  * Enums are used create a user-defined type in Solidity.\n  * Enums restrict the variable with one of a few predefined values, these values of the enumerated list are called enums.\n  * Syntax to declare an enum is `enum <enumerator_name> {element 1, element 2,....,element n}`\n  * Enums require at least one member, and its default value when declared is the first member.\n  * Enums cannot have more than 256 members.\n  * The options in an enum are represented by subsequent unsigned integer values starting from 0.\n  * The default value of an enum when declared is its first member. \n\n- User Defined Value Types\n  * A user defined value type is defined using `type C is V`, where C is the name of the newly introduced type and V has to be a built-in value type (the “underlying type”). \n  * The function C.wrap is used to convert from the underlying type to the custom type.\n  * The function C.unwrap is used to convert from the custom type to the underlying type.\n  * The type C does not have any operators or bound member functions. \n\n- Function Types \n  * Function types are the types of functions.\n  * Function types are declared as `function (<parameter types>) {internal|external} [pure|view|payable] [returns (<return types>)]`.\n  * Internal functions can only be called inside the current contract.\n  * External functions consist of an address and a function signature and they can be passed via and returned from external function calls.\n  * View functions are read only function and do not modify the state of the block chain (view data on the block chain).\n  * Pure functions do not read and do not modify state of the block chain.   \n"
        },
        {
          "title": "Reference Types",
          "shortTitle": "Reference Types",
          "key": "reference-types",
          "details": "In Solidity, unlike value types that stores it own data, reference types do not store the data directly to the variable, they contain a pointer to another memory location that holds the real data.\nValues of reference type can be modified through multiple different names in contrast to value types where an independent copy is maintained whenever a variable of value type is used.\nWhile using a reference type a data location(where the variable is stored) has to be provided explicitly. Currently, reference types comprise of structs, arrays and mappings.\n \n - arrays\n   * Arrays can have a compile-time fixed size, or they can have a dynamic size.\n   * `type arrayName [ arraySize ];` declares an array of fixed size in Solidity.\n   * `type[] arrayName;` declares an array of dynamic size in solidity.\n   * Memory arrays with dynamic length can be created using the new operator eg `uint[] memory a = new uint[](7);` . As opposed to storage arrays, it is not possible to resize memory arrays.\n   * Arrays inside a function can only be declared with memory data location and are always of fixed size, so `uint[] memory newArray = new uint[](10);` is a valid array declaration inside a function.\n\n - bytes and strings as arrays\n   * Variables of type bytes and string are special arrays.\n   * The bytes type is similar to bytes1[], but it is packed tightly in calldata and memory. \n   * string is equal to bytes but does not allow length or index access.\n   * Solidity does not have string manipulation functions, but there are third-party string libraries.\n   * You can compare two strings by their keccak256-hash using `keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))` and concatenate two strings using `string.concat(s1, s2)`.\n\n - structs\n   * Structs in Solidity are used to create more complicated data types that have multiple properties.\n   * They are useful for grouping together related data.\n   * Syntax to declare a struct is -\n     ```solidity\n       struct <structure_name> {  \n         <data type> variable_1;  \n         <data type> variable_2; \n       }\n     ```\n   * For accessing any element of the structure the dot operator is used.\n   * The below example shows how to initialize a struct in solidity.\n       ```solidity\n         pragma solidity 0.8.15;\n         contract test {\n           // Declaring a structure\n           struct Course {\n               string title;\n               string subTopic;\n               uint id;\n           }\n           // Declaring a structure object\n           Course course1;\n         \n           // declaring a struct and assigning values to the fields\n           Course course2\n             = Course(\"Solidity Course\",\n                     \"No topic\",1);\n           \n           function setSubTopicopic() public{\n               course2.subTopic=\"Reference Types\";\n           }\n           function viewSubTopic() public view returns(string memory){\n               return course2.subTopic;\n           }\n         }\n       ```  \n   * In the above example the dot operator can be used inside the setTopic function to update the subtopic of Course struct.\n"
        },
        {
          "title": "Data location",
          "shortTitle": "Data location",
          "key": "data-location",
          "details": "* There are three data locations: memory, storage and calldata.\n* When placed in storage, a variable is written on the blockchain. Every contract has its own storage, so these variables are persistent. \n* If we want to store variables and later update or make changes to its state, we have to declare it using storage. We can update the variables declared with memory data location aswell inside a function but the data can be used only within the function and any modification will not persist outside the function execution. \n* State variables and Local Variables of structs, array are always stored in storage by default.\n* Variables stored in memory are declared inside a function. They are temporary and their lifetime is dependent on the runtime of the function they correspond to.\n* Calldata is also a temporary data location in Solidity. \n* Calldata acts like memory, in terms of its dependence on the functions execution however it is only available for external function call parameters.\n* When we call a function which takes an array with memory keword, the array is copied. This leads to more gas fee. However with calldata, the array is not copied, but also the data cannot be modified when declared with keyword calldata.     \n* Variables declared with memory data location are mutable (i.e. they can be overwritten and changed) whearas variables declared with calldata location are immutable and cannot be overwritten or changed.\n* The below example explains the differences between memory and calldata.\n  ```solidity\n    pragma solidity 0.8.15;\n\n    contract Test {\n        function memoryTest(string memory _exampleString) public pure returns (string memory) {\n            _exampleString = \"example\";  // You can modify memory\n            string memory newString = _exampleString;  // You can use memory within a function's logic\n            return newString;  // You can return memory\n        }\n        function calldataTest(string calldata _exampleString) external pure returns (string memory) {\n            // cannot modify _exampleString\n            return _exampleString; // but can return it\n        }\n    }\n  ```\n* Storage is the most expensive data location one can use. Then there is memory, with the cheapest being calldata.\n"
        },
        {
          "title": "Mapping Type",
          "shortTitle": "Mapping Type",
          "key": "mapping-type",
          "details": "Mapping in Solidity acts like a hash table or a dictionary. These are used to store the data in the form of key-value pairs.\n- Mapping types use the syntax `mapping(KeyType => ValueType)` and variables of mapping type are declared using the syntax `mapping(KeyType => ValueType) VariableName`.\n- The KeyType can be any built-in value type, bytes, string, or any contract or enum type. Other user-defined or complex types, such as mappings, structs or array types are not allowed.\n- ValueType can be any type, including mappings, arrays and structs.\n- Mappings can only have a data location of storage.\n"
        }
      ]
    },
    {
      "title": "Units and variables",
      "key": "units-variables",
      "details": "This chapter covers the units used in solidity and also discusses various functions available globally in Solidity and their properties.",
      "order": 2,
      "questions": [
        {
          "uuid": "47a244a5-80b1-4653-bc5d-9b0d3c8b5a83",
          "type": "MultipleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "B",
            "D"
          ],
          "subTopics": [
            "variables"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "1",
              "key": "A"
            },
            {
              "content": "2",
              "key": "B"
            },
            {
              "content": "3",
              "key": "C"
            },
            {
              "content": "4",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "1b6f7a4a-5f9e-40f0-8259-7a029e372747",
          "title": "title",
          "shortTitle": "short title",
          "type": "YoutubeVideo",
          "url": "url",
          "subTopics": [
            "variables"
          ],
          "details": "details\n"
        }
      ],
      "summaries": [
        {
          "title": "Units",
          "shortTitle": "Units",
          "key": "units",
          "details": "- time units\n- ether units\n"
        },
        {
          "title": "Globally available Variables",
          "shortTitle": "Global Variables",
          "key": "variables",
          "details": "- Block and transaction methods\n- ABi Encoding and Decoding methods\n- Error handling methods\n- Mathematic and cryptographic functions\n- others\n"
        }
      ]
    },
    {
      "title": "Expressions and Control Structures",
      "key": "expression-control",
      "details": "This chapter covers how to write expressions and covers the various Control Structures like if/else , for etc.",
      "order": 3,
      "questions": [
        {
          "uuid": "b3bd428b-7fd9-44b7-8139-c3a9f577793b",
          "type": "MultipleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "B",
            "D"
          ],
          "subTopics": [
            "control-structure"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "1",
              "key": "A"
            },
            {
              "content": "2",
              "key": "B"
            },
            {
              "content": "3",
              "key": "C"
            },
            {
              "content": "4",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "5bfe6b20-4efc-48f8-a981-49d86534ff19",
          "title": "title",
          "shortTitle": "short title",
          "type": "YoutubeVideo",
          "url": "url",
          "subTopics": [
            "control-structure"
          ],
          "details": "details\n"
        }
      ],
      "summaries": [
        {
          "title": "Control Structure",
          "shortTitle": "Control Structure",
          "key": "control-structure",
          "details": "- if/else\n- for\n- while\n- do\n- break,continue\n- return\n"
        },
        {
          "title": "Function Calls",
          "shortTitle": "Function Calls",
          "key": "func-call",
          "details": "- Internal Function Calls\n- External Function Calls\n"
        }
      ]
    },
    {
      "title": "Object Oriented Programming (OOP) Concepts in Solidity",
      "key": "oops",
      "details": "Solidity is an object oriented programming language . This chapters explains how solidity implements various object oriented paradigms like abstraction , inheritance , polymorphism , encapsulation etc.",
      "order": 4,
      "questions": [
        {
          "uuid": "9dbcbbce-9235-4a56-9846-aee5ec618532",
          "type": "MultipleChoice",
          "content": "question",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "B",
            "D"
          ],
          "subTopics": [
            "encapsulation"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "1",
              "key": "A"
            },
            {
              "content": "2",
              "key": "B"
            },
            {
              "content": "3",
              "key": "C"
            },
            {
              "content": "4",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "f7a54b96-2fc7-46ef-961e-1ce6a50af8dc",
          "title": "title",
          "shortTitle": "short title",
          "type": "YoutubeVideo",
          "url": "url",
          "subTopics": [
            "encapsulation"
          ],
          "details": "details\n"
        }
      ],
      "summaries": [
        {
          "title": "Understanding Encapsulation in Solidity",
          "shortTitle": "Encapsulation",
          "key": "encapsulation",
          "details": "It refers to the bundling of data, along with the methods that operate on that data, into a single unit.\nIt refers to the mechanism of manipulating the scope of variables, i.e., restricting the variable's access outside the scope.\n\nSyntax\n  ```solidity\n  // Unlike in Java,\n  // the data type comes before the visibility modifier in Solidity\n  uint public num;\n  // <data type> <visibility> <variale name>;\n  ```\n\n- Public\n  * These objects can be accessed internally and externally as well as via messages also.\n  * External methods can inherit public elements.\n  * A getter function is generated automatically when a public variable is created.\n  * However, no setter function is created, implying that the external function can not modify the variable.\n\n- Internal\n  * As the name suggests, Internal objects can be accessed by internal or derived methods but cannot be accessed by external.\n  * Only a base contract and a derived contract have their access.\n\n- Private\n  * Private objects can only be accessed internally from the current contract instances.\n  * They cannot be accessed by derived methods also.\n\n- External\n  * These objects can be accessed externally but not internally, i.e., current contract instances cannot access it.\n  * They cannot be inherited.\n\nState Variable visibility\n  - Public\n  - Internal\n  - Private\n\nFunction visibility\n  - External\n  - Public\n  - Internal\n  - Private\n\nOne should always use the principle of least privilege when determining which level of visibility to use.\n"
        },
        {
          "title": "Understanding Inheritance in Solidity",
          "shortTitle": "Inheritance",
          "key": "inheritance",
          "details": "Inheritance is the process of defining multiple contracts related to each other through parent-child relationships.\n\nSolidity supports inheritance between smart contracts.\n  * Base contract: The contract from which other contracts inherit features.\n  * Derived contract: The contract which inherits the features.\n  * Simply, they are referred to as parent-child contracts.\n\nSyntax\n  ```solidity\n    contract <Derived Contract Name> is <Base Contract Name>{\n  }\n  ```\n\nSolidity provides different types of inheritance.\n  - Single Inheritance\n    * In Single or single-level inheritance, the functions, and variables of one base contract are inherited to only one derived contract.\n    \n  - Multi-level Inheritance\n    * Very similar to single inheritance.\n    * Instead of just a single parent-child relationship, there are multiple levels of the parent-child relationship.\n\n  - Hierarchical Inheritance\n    * Here, a single contract acts as a base contract for multiple derived contracts.\n    * It is mostly used when a common functionality is used in different places.\n\n  - Multiple Inheritance\n    * Here, a single contract can be inherited from one or more contracts.\n  \nNote : Solidity follows the path of Python and uses C3 Linearization, also known as Method Resolution Order (MRO), to force a specific order in graphs of base contracts. The order of execution is determined by order of the declaration at the contract level. It has nothing to do with the order you call/pass arguments up from the constructor's signature.\n"
        },
        {
          "title": "Polymorphism in Solidity",
          "shortTitle": "Polymorphism",
          "key": "polymorphism",
          "details": "It is an ability to process data in more than one form.\n\nSolidity supports two types of polymorphism.\n  - Note\n    - Function overriding\n      * When the base class and derived class have member functions with exactly the same name, same return-type, and same arguments list.\n    \n    - Function overloading\n      * A set of different functions that happen to have the same name differ by their parameters.\n\n  - Function polymorphism\n    * It is also known as method overloading.\n    * Multiple functions are declared to have the same name within the same contract or inheriting the contract.\n    * Functions differ based on the number of parameters or parameter datatypes.\n    * Declaration of function cannot be overloaded by functions that differ only in return type.\n  \n    ```solidity\n      // Solidity program to demonstrate\n      // Function Polymorphism\n      pragma solidity ^0.5.0;\n        \n      // Contract definition\n      contract methodOverloading {\n        \n          // function to get value of \n          // the unsigned integer variable \n          function getData(uint _n) public pure returns(uint){\n              return _n;\n          }\n            \n          // Function to get value \n          // of the string variable\n          function getData(string memory _str) public pure returns(string memory){\n              return _str;\n          }\n      }\n    ```\n  - Contract polymorphism\n    * Using multiple contract instances interchangeably when they are related to each other by using inheritance.\n\n    ```solidity\n    // Solidity program to demonstrate Contract Polymorphism\n    pragma solidity >=0.4.22 <0.6.0;\n\n    contract parent{  \n      uint internal sum;\n      \n      // Function to set the value of\n      // internal state variable sum\n      function setValue(uint _num1, uint _num2) public {\n        sum = _num1 + _num2;\n      }\n\n      // Function to return a value 10\n      function getValue() public view returns(uint) {\n        return 10;\n      }\n    }\n\n    // Defining child contract\n    contract child is parent{\n      \n      // Function getValue overloaded\n      // to return internal state\n      // variable sum defined in the\n      // parent contract\n      function getValue() public view returns(uint) {\n        return sum;\n      }\n    }\n\n    // Defining calling contract\n    contract ContractPolymorphism {\n      \n      // Creating object\n      parent pc = new child();\n        \n      // Function to set values\n      // of 2 unsigned integers\n      function getInput(uint _num1, uint _num2) public {\n        pc.setValue(_num1, _num2);\n      }\n\n      // Function to get value of\n      // internal state variable sum\n      function getSum() public view returns(uint){\n        return pc.getValue();\n      }\n    }\n    ```\n"
        },
        {
          "title": "Constructor for Solidity",
          "shortTitle": "Constructor",
          "key": "constructor",
          "details": "It is a special method in any object-oriented programming language that gets called whenever an object of a class is initialized.\nSolidity provides a constructor declaration inside the smart contract, and it invokes only once when the contract is deployed and is used to initialize the contract state.\nThe compiler creates a default constructor if there is no explicitly defined constructor.\n\nSyntax\n  ```solidity\n  constructor() <Access Modifier> {         \n  }\n  ```\n\nNote\n  * It is very useful in a smart contract, a parameter value can be defined at the run time and can also restrict the method call.\n  * Constructor overloading is not supported in Solidity; it only allows one constructor at a time.\n"
        },
        {
          "title": "Abstraction in Solidity",
          "shortTitle": "Abstraction",
          "key": "abstraction",
          "details": "Hiding the implementation details and showing only important/useful parts to the user.\n\n  - Abstract Contract\n    * These are contracts that have partial function definitions. One cannot create an instance of an abstract contract.\n    * It must be inherited by a child contract for utilizing its functions.\n    * Abstract contracts help define a contract's structure, and any class inheriting from it must ensure to provide an implementation for them.\n    * If the child contract does not provide the implementation for incomplete functions, even its instance cannot be created.\n    * A contract becomes an abstract class if it has functioned without implementation.\n    * There is no Solidity-provided keyword to mark a contract as abstract.\n  \n  - Interface\n    * These are like abstract contracts, but there are differences.\n    * Interfaces cannot contain any definition.\n    * They can only contain function declarations, which means functions in interfaces cannot contain any code.\n    * An interface can contain only the signature of functions.\n\n    ```solidity\n    // Solidity program to\n    // demonstrate the working\n    // of the interface\n\n    pragma solidity ^0.5.0;\n    interface InterfaceExample{\n      function getStr() public view returns(string memory);\n    }\n\n    // Contract that implements interface\n    contract thisContract is InterfaceExample{\n\n      // Function definitions of functions\n      // declared inside an interface\n      function getStr() public view returns(string memory){\n        return \"GeeksForGeeks\";\n      }\n    }\n    ```\n"
        },
        {
          "title": "Libraries in Solidity",
          "shortTitle": "Library",
          "key": "library",
          "details": "- Highlights\n  * A library has functions that can be called by other contracts. \n  * Deploying a common code by creating a library reduces the gas cost. \n  * Functions of the library can be called directly when they do not modify the state variables i.e. only pure and view   functions can be called from outside of the library. \n  * It cannot be destroyed because it is assumed as stateless. \n  * The library does not have state variables, it cannot inherit any element and cannot be inherited.\n\n- Creating library\n  ```solidity\n  library <libraryName> {\n      // block of code\n  }\n  ```\n\n- Deploying library\n\n  ```solidity\n  // import <libraryName> from “./library-file.sol”;\n\n  // Solidity program to demonstrate \n  // how to deploy a library\n  pragma solidity ^0.5.0;\n\n  // Defining Library\n  library LibraryExample {\n      function pow(uint a, uint b) public view returns (uint, address) {\n          return (a ** b, address(this));\n      }\n  }\n\n  // library deployed with for keyword\n\n  contract LibExample {\n      \n    // Deploying library using \n    // \"for\" keyword\n    using LibraryExample for unit;\n    address owner = address(this);\n      \n    function getPow(uint num1, uint num2) public view returns (uint, address) {\n        return num1.pow(num2);\n    }\n  }\n\n  // library can be used without for keyword\n\n  contract LibExample2{\n\n    // Deploying library without using \n    // \"for\" keyword\n    \n    function getPow(uint num1, uint num2) public view returns (uint, address) {\n          return LibraryExample.pow(num1, num2);\n    }\n  }\n  ```\n"
        }
      ]
    }
  ]
}