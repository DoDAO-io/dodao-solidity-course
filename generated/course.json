{
  "key": "solidity-course",
  "title": "Solidity Course (In Progress)",
  "summary": "Smart contracts allow users to implement conditions, rules and policies of the blockchain applications. \nIn this course you will learn how to write smart contracts and all the features of Solidity language.\n",
  "details": "Each smart contract can contain declarations of State Variables, Functions, Function Modifiers, Events, Errors, Struct Types, Enum Types etc. \nSmart Contract development in solidity requires an understanding of the solidity compiler, structure of a smart contract, use of various globally available functions and variables, expressions and control structures and error handling methods.\nIn this course, you will learn all these essentials for programming in Solidity.\nThis course will also cover Object-oriented programming concepts like constructor functions, contract and classes, interfaces, abstract contracts (virtual and override), inheritance etc.\n",
  "duration": "4 - 6 hours",
  "highlights": [
    "Solidity smart contracts",
    "All the features of Solidity",
    "Advanced Solidity concepts",
    "Summaries and questions for each chapter"
  ],
  "publishStatus": "Live",
  "thumbnail": "https://d31h13bdjwgzxs.cloudfront.net/courses/DoDAO/Solidity/Solidity.png",
  "topics": [
    {
      "title": "Your First Solidity Smart Contract",
      "key": "intro-solidity",
      "details": "This chapter explains the solidity compiler and how to get started with solidity . Further it explores the layout of a solidity source file and also the structure of smart contracts in solidity.",
      "order": 0,
      "explanations": [
        {
          "key": "smart-contract",
          "title": "Structure of a smartcontract",
          "shortTitle": "contract structure",
          "details": "#### Versioning of solidity compiler\nThe compiler version will be in the form MAJOR.MINOR.PATCH example(0.8.7) which indicates the major release 0 with 8th minor release and 7th patch. \n\n#### Structure of a smart-contract in solidity\n\n```solidity\n//SPDX-License-Identifier:MIT\npragma solidity ^0.8.2;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ncontract HelloWorld {\n    string word = \"helloworld\";\n    // this is a single line comment\n\n    /* this is a \n        multi line comment */\n}\n```\n\nEvery Solidity source file should have a license identifier in order to avoid legal issues when the code is published as open source. The Solidity compiler recognizes SPDX license identifiers, which are machine-readable. \nYou can specify the license identifier anywhere in the code, but it's recommended to put it at the top of each file.\n\nThe compiler that will be used to compile the Solidity file must be specified using the keyword \"pragma\" followed by the caret (^) symbol and the version number. The caret symbol indicates that any Solidity \ncompiler with a version of the same major and minor value and patch number greater than the specified version can be used to compile the file. Example in the above code version compiler with 0.8.7 can be used to compile the above code but 0.9.2 and 0.8.0 can't be used to compile the above file. \nEvery solidity file must be saved as `.sol` for compiling. Single line comments starts with `//`. Multiline comments starts with `/*` and ends with `*/`.\n\n`import` keyword is used for importing files from other resources. Solidity also include constructor functions. Constructors are functions which will be executed automatically for one time when a contract is deployed.\nYou can also write your Solidity comments in the Ethereum Natural Language Specification Format (NatSpec). It defines a special form of comments in Solidity contracts. Developers use it for documenting return variables, functions, and so on.\nYou can write single or multi-line comments in Solidity, and use two types of syntax, start the line with /// to include a single-line comment and start with /**and end with /* to include a multi-line comment.\nexample code snippet.\n\n```solidity\n//SPDX-License-Identifier:MIT\npragma solidity ^0.8.2;\n\nimport \"priceconverter.sol\"; // this is normal importing\nimport \"priceconverter.sol\" as pc; // if you want to import one file but with different name\nimport { price1 as p1, price2 } from \"storagefactory.sol\"; // If we want to import only specific variables or functions from a file\n\ncontract SolidityStructure {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /* msg.sender is the address that has called or initiated a function or created a transaction. \n            But at the time of deployment it will be the address of the deployer of the contract */\n\n    /// @author admin\n}\n```\n\nIn the above snippet, the constructor function will only be called once when the contract is deployed. This function will assign the deployer address to the `owner`. `msg.sender` is the address that has called or \ninitiated a function or created a transaction. But at the time of deployment it will be the address of the deployer of the contract.\n"
        },
        {
          "title": "Statevariables and Functions",
          "shortTitle": "Functions",
          "key": "state-variables-and-functions",
          "details": "\nState variables are variables whose values are permanently stored in contract storage. State variables can be declared as `constant` or `immutable`. The constant variables cannot be redeclared after assigning but immutable variables\ncan be redeclared using constructor. Constant or immutable can be declared only for variables of the type string, int or uint, boolean, address and enums. Using constant and immutable can reduce the gas cost.\n\nFunctions in Solidity are like small pieces of code that can be executed. The way you write a function in Solidity is similar to how you would write one in c, c++, or JavaScript, except for a few small differences. \nFunctions are usually written inside a contract, but they can also be written outside of contracts. These functions that are written outside of contracts are called \"free functions\". Free functions don't have \naccess to variables inside the contracts, but other contracts can call them. Free functions also don't have visibility, which means we cannot use the public or external keyword for them. We need to define the \ndata type for function arguments and return types. \n\nWe can return values from a function in two ways:\nOne way is to normally return the value using the return keyword. Another way is to define a return variable and assign the return value to that variable. The function `add` below defines a return variable `sum`. \nTherefore, we can return the value by just assigning the value to the sum as shown in the below snippet.\n\n\n```solidity\ncontract SimpleProgram {\n    uint public constant value = 23;\n    uint public answer = add(value, 1);\n    address immutable owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    uint public product = multiply(value, 2);\n\n    function multiply(uint a, uint b) public returns (uint) {\n        return a * b;\n    }\n}\n\nfunction add(uint a, uint b) pure returns (uint sum) {\n    sum = a + b;\n}\n\n```\nThe above code snippet shows that the owner variable is assigned the deployer or contract owner address during the constructor time. However, you cannot reassign a constant variable like an immutable variable. \nThe simpleProgram contract is calling the free function `add` to add two numbers together and assigning the return value from the function to a variable `answer`.\n\n#### Others functions and features in solidity\nThe `fallback` and `receive` functions are two special types of functions that are often used together. The `fallback` function is a function that is called if none of the other functions match the function \nidentifier or if ether is transferred to the contract with some data. The `receive` function is a function that is called when someone sends ether to a contract. If the contract does not have a `receive` function, \nthen the `fallback` function will be executed. If ether is sent with some data directly to the contract, then the `fallback`function will be executed even if a `receive` function is defined. \nWhile defining the recieve function payable keyword must be added in order to receive ether. Visibility of receive and fallback functions must be defined.\n\nThere are two keywords which can restrict functions: `pure` and `view`. If `pure` is used in a function, that function will not be able to read or write. If `view` is used in a function, \nthat function will not be able to write, but will have read access. \n\nSample code explaining how to use recieve and fallback functions.\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.5;\n\ncontract SolidityCourse {\n    uint public value = 0;\n\n    receive() external payable {\n        setValue(24);\n    }\n\n    function setValue(uint x) internal {\n        value = x;\n    }\n\n    function check_value() public view returns (uint answer) {\n        // view keyword restrict the function check_a to read only\n        answer = value;\n    }\n\n    fallback() external {\n        setValue(12);\n    }\n}\n\n```\n"
        },
        {
          "title": "Events and Function modifiers",
          "shortTitle": "Events and modifiers",
          "key": "modifiers",
          "details": "#### Events\n\nEvents are inheritable members of contracts. When you call them, they cause the arguments to be stored in the transactions log - a special data structure in the blockchain.\nEvents are defined within the contracts as global and called within their functions. Events are declared by using the event keyword as follows , `event <eventName>(parameters) ;`.\n\n```solidity\ncontract Events{\n  event Log(uint value, address member );\n  function deposit() public payable{\n      emit Log(msg.value,msg.sender);\n  }\n}\n\n```\nThe `deposit` function is called whenever a user sends Ether to the contract. The value that is sent and the sender's address are logged and stored in the blockchain as an event. `emit Log(msg.value,msg.sender);` defines emitting of the event with the message value and the senders address. \nThese events are very useful for maintaining transaction logs. They can be viewed in `Etherscan` if the contract is deployed in Ethereum or any of its testnets. Events are ways to communicate with a client application or front-end website that something has happened on the blockchain. \nThe above event Deposit can be detected from the JavaScript API by filtering for `Deposit`.\n\n#### Function Modifiers\n\nFunction modifiers can be used to change the behaviour of functions in a declarative way. A modifier can be used automatically to check a condition prior to execution of the function.\nWe need to use `modifier` keyword in order to define a modifier then we need to give identifier to that modifier, the syntax will look something likje this\n```solidity\nmodifier Identifier {\n    //code comes here\n}\n```\nIn the below snippet, the owner variable is assigned the address of the deployer of the contract as discussed before. The function modifier `onlyOwner` is added to the function `setValue` just by adding the identifier of the \nmodifier as a keyword to the function `setValue`. When the function `setValue` is called, the compiler checks into the keywords and finds the modifier, then jumps to the `onlyOwner` function. If the condition in the require \nstatement is true, the code in the modifier will run. If the condition is false, the transaction will be reverted with a message stating \"not owner\". The `_;` will execute the code of the `setValue` function. \nIf `_;` is declared before the require statement, the parent function's code will be executed first, and then the require statement will be executed. So if the require statement is passed, the parent \nfunction's code will be executed, i.e. the `setValue` function's code will be executed. In simple terms modifier's helps to manupulate the functions.\n\n```solidity\n//SPDX-License-Identifier:MIT\npragma solidity ^0.8.0;\n\ncontract FunctionModifiers {\n    address public immutable owner;\n    uint public favourite_number = 7;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not owner\");\n        _;\n    }\n\n    function setValue(uint x) public onlyOwner returns (uint v) {\n        favourite_number = x;\n        v = x;\n    }\n}\n\n```\n"
        },
        {
          "title": "Error Handling",
          "shortTitle": "Error-handling",
          "key": "errors",
          "details": "Solidity uses state-reverting exceptions to handle errors. Such an exception undoes all changes made to the state in the current call (and all its sub-calls) and flags an error to the caller.\nSolidity has many functions for error handling. Errors can occur at compile time or runtime. Solidity is compiled to byte code and there a syntax error check happens at compile-time, while runtime \nerrors occur mainly while executing the contracts. Some of the runtime errors are out-of-gas error, data type overflow error, divide by zero error, array-out-of-index error, etc.\nError handling can be done using assert, revert, require, \"try-catch\" and custom errors.\n\n#### Assert \nAssert is used to check conditions which should be true always. The assert function creates an error of type Panic(uint256). Assert should only be used to test for internal errors, and to check invariants. Properly functioning code should never create a Panic, \nnot even on invalid external input. If this happens, then there is a bug in your contract which you should fix.\n\nA Panic exception is generated in the following situations.\n* If you call assert with an argument that evaluates to false.\n* If an arithmetic operation results in underflow or overflow.\n* If you divide or modulo by zero.\n* If you convert a value that is too big or negative into an enum type.\n* If you call .pop() on an empty array.\n* If you access an array or an array slice at an out-of-bounds or negative index.\n* If you allocate too much memory or create an array that is too large.\n* If you call a zero-initialized variable of internal function type.\n\n#### Require\nThe require function takes two parameters. The first argument is the condition and the second is the custom string text which will be displayed if the condition returns false. this second parameter is optional.\nIf false then exception is raised and execution is terminated. The unused gas is returned back to the caller and the state is reversed to its original state.\n\nrequire exception is triggered for the following cases:\n* Calling require(x) where x evaluates to false.\n* If you perform an external function call targeting a contract that contains no code.\n* If you use revert() or revert(\"description\").\n* If your contract receives Ether via a public function without payable modifier.\n* If your contract receives Ether via a public getter function.\n\n```solidity\n//SPDX-License-Identifier:MIT\npragma solidity ^0.8.0;\n\ncontract FunctionModifiers {\n    address public owner;\n    uint public favourite_number = 7;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setValue(uint x) public onlyOwner {\n        favourite_number = x;\n    }\n}\n```\nIn the above snippet require exception will be triggered if `msg.sender` is not equal to `owner` i.e, the address which is calling or acessing the function is not equal to the deployer's address. \n\n#### Revert\nThis statement is similar to the require statement. It does not evaluate any condition and does not depends on any state or statement. It is used to generate exceptions, display errors, and revert the function calls.\nCalling a revert statement implies an exception is thrown, the unused gas is returned and the state reverts to its original state. Revert is used to handle the same exception types as require handles, but with little bit more complex logic.\nrevert takes an optional argument of string type.\n\n```solidity\nfunction checker(uint x) public pure returns(bool y){\n    if(x>=10){\n        revert(\"value exceeded\");\n    }\n    else{\n        return true;\n    }\n}\n```\n"
        },
        {
          "title": "Custom Errors and try-catch",
          "shortTitle": "Custom Errors",
          "key": "custom-errors-and-try-catch",
          "details": "#### Try Catch in Solidity\nIn a try catch statement, the try block will execute some code. If it gets any errors, the caught statement will be executed. A failure in an external call can be caught using a try/catch statement.\nA external call is a function calling from one contract to another contract. \nAn example of an external call.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract A {\n    function add(uint x, uint y) public returns (uint sum) {\n        sum = x + y;\n    }\n}\n\ncontract B {\n    A object_of_a; // this is an object of contract A\n    uint public answer = 0;\n\n    function setContract(A addr) public {\n        // we need to pass the address of deployed a contract\n        object_of_a = addr;\n    }\n\n    function callAdd() public {\n        answer = object_of_a.add(12, 3);\n    }\n}\n```\nIn the above code we are creating the object of contract `A` by its address(deployed address of A). Then we are calling the function `add` from contract `B`. This is called as \"external call\". \n\nAn example of try catch block is shown below. The try keyword has to be followed by an expression representing an external function call or a contract creation (new ContractName()). Solidity supports different kinds of catch blocks depending on the type of errors.\none try block can have multiple catch blocks. Different catch blocks are explained in single comments in the below please go through it for better understanding. We can just use catch { … } if we are not interested in error data.\n\n```solidity\ninterface DataFeed { function getData(address token) external returns (uint value); }\n\ncontract FeedConsumer {\n    DataFeed feed;\n    uint errorCount;\n    function rate(address token) public returns (uint value, bool success) {\n        // Permanently disable the mechanism if there are\n        // more than 10 errors.\n        require(errorCount < 10);\n        try feed.getData(token) returns (uint v) {\n            return (v, true);\n        } catch Error(string memory /*reason*/) {\n            // This is executed in case revert was called inside getData and a reason string was provided.\n            errorCount++;\n            return (0, false);\n        } catch Panic(uint /*errorCode*/) {\n            // This is executed in case of a panic,\n            // i.e. a serious error like division by zero\n            // or overflow. The error code can be used\n            // to determine the kind of error.\n            errorCount++;\n            return (0, false);\n        } catch (bytes memory /*lowLevelData*/) {\n            // This is executed in case revert() was used.\n            errorCount++;\n            return (0, false);\n        }\n    }\n}\n```\n\n#### Custom Errors\nCreating custom errors in your code can actually help you conserve gas usage. How? Well, normal errors come with pre-written, lengthy error messages that can really guzzle up a lot of gas. However, when you create a \ncustom error using the `error` keyword, you can specify the message yourself. These custom errors can be called using a conditional and revert statement.\n\nAn example of an custom error is shown below.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.5;\n\ncontract CustomError {\n    error Logic(string message);\n\n    function testCustom_error(uint x) public pure {\n        if (x > 10) {\n            revert Logic(\"the value exceeded 10\");\n        }\n    }\n}\n\n```\nBy using the keyword `error`, we have defined a custom error name called `Logic`. If the value of x exceeds 10, the transaction will be reverted and our custom error message will be shown. \nThe values that need to be logged at the time of an error should be specified/defined in the argument of our custom error.\n"
        }
      ],
      "questions": [
        {
          "uuid": "0dfd7a32-7eb3-4751-b35e-7f3b9ca775bc",
          "type": "MultipleChoice",
          "content": "Which of the following is a valid pragma verion declaration in Solidity?",
          "hint": "noHint",
          "explanation": "pragma solidity 0.6.12  - Only compiles with version 0.6.12\npragma solidity ^0.6.12 - Compiles with version 0.6.12 and above\npragma solidity >=0.4.0 <0.6.0 - Compiles with all versions between 0.4.0 and 0.6.0.\n",
          "answerKeys": [
            "A",
            "B",
            "C"
          ],
          "subTopics": [
            "smart-contract"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`pragma solidity 0.6.12;`",
              "key": "A"
            },
            {
              "content": "`pragma solidity ^0.6.12;`",
              "key": "B"
            },
            {
              "content": "`pragma solidity >=0.4.0 <0.6.0;`",
              "key": "C"
            },
            {
              "content": "`pragma solidity -0.5.2;`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "85f2abbc-9acb-4ebe-a624-3c952da70b22",
          "type": "SingleChoice",
          "content": "A Solidity Contract file has a pragma versioning `pragma solidity ^0.5.2;`. With which of the following compilers will the contract run?",
          "hint": "Think of what condition is applicable with `^` symbol in solidity versioning.",
          "explanation": "A source file with the line above does not compile with a compiler earlier than version 0.5.2, and it also does not work on a compiler starting from version 0.6.0 (this second condition is added by using ^).",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "smart-contract"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Compiler version 0.5.1",
              "key": "A"
            },
            {
              "content": "Compiler version 0.4.1",
              "key": "B"
            },
            {
              "content": "Compiler version 0.5.5",
              "key": "C"
            },
            {
              "content": "Compiler version 0.6.1",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6bc53ece-fffd-4f7f-bb54-c8200d629d16",
          "type": "MultipleChoice",
          "content": "Which of the following statements is incorrect regarding pragmas in solidity?",
          "hint": "ABI coder pragma can be used to select between the two implementations of the ABI encoder and decoder and experimental pragma can be used to enable features of the compiler or language that are not yet enabled by default.",
          "explanation": "The pragma keyword is used to enable certain compiler features or checks. A pragma directive is always local to a source file, so you have to add the pragma to all your files if you want to enable it in your whole project. If you import another file, the pragma from that file does not automatically apply to the importing file.\nBy using pragma abicoder v1 or pragma abicoder v2 you can select between the two implementations of the ABI encoder and decoder. It can be used to enable features of the compiler or language that are not yet enabled by default. The following experimental pragmas are currently supported: ABIEncoderV2 , SMTChecker.\n",
          "answerKeys": [
            "A",
            "D"
          ],
          "subTopics": [
            "smart-contract"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "In Solidity `pragma` keyword is only used to specify the version of the compiler the code should compile with.",
              "key": "A"
            },
            {
              "content": "The `pragma` keyword is used to enable certain compiler features or checks.",
              "key": "B"
            },
            {
              "content": "The following code will only compile with compiler version 0.6.12, `pragma solidity 0.6.12;`.",
              "key": "C"
            },
            {
              "content": "If you import another file, the pragma from that file will automatically apply to the importing file.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d336edf3-75ef-43c7-b77d-74bafcaa92b9",
          "type": "SingleChoice",
          "content": "Which of the following pragma declarations is incorrect?",
          "hint": "noHint",
          "explanation": "By using pragma abicoder v1 or pragma abicoder v2 you can select between the two implementations of the ABI encoder and decoder.\nIf you use pragma experimental SMTChecker;, then you get additional safety warnings which are obtained by querying an SMT solver.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "smart-contract"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "pragma experimental SMTChecker;",
              "key": "A"
            },
            {
              "content": "pragma abicoder v1;",
              "key": "B"
            },
            {
              "content": "pragma solidity ^0.5.2;",
              "key": "C"
            },
            {
              "content": "pragma version 0.6.2;",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1e3de4e3-fd09-446a-ba8a-2d223b59f587",
          "type": "SingleChoice",
          "content": "If you want to import a file in your solidity code which of the following will be a correct but inefficient way to do so?",
          "hint": "All import statements are correct.",
          "explanation": "The statement `import \"filename\";` imports all global symbols from “filename” into the current global scope. This form is not recommended for use, because it unpredictably pollutes the namespace. If you add new top-level items inside “filename”, they automatically appear in all files that import like this from “filename”. It is better to import specific symbols explicitly.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "smart-contract"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "import * as symbolName from \"filename\";",
              "key": "A"
            },
            {
              "content": "import \"filename\" as symbolName;",
              "key": "B"
            },
            {
              "content": "import {symbol1 as alias, symbol2} from \"filename\";",
              "key": "C"
            },
            {
              "content": "import \"filename\";",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "70f2e739-5097-4606-be32-9fc2dc766c0e",
          "type": "SingleChoice",
          "content": "Which of the following statements regarding solidity files is correct?\nStatement 1 - It is a better practice to modularize code by writing contracts in different source files and using imports.\nStatement 2 - The export declaration is used to export functions from a Contract.\n",
          "hint": "noHint",
          "explanation": "Solidity supports import statements to help modularise your code that are similar to those available in JavaScript (from ES6 on). \nHowever, Solidity does not support the concept of a default export.\n",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "smart-contract"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement 1 is true but Statement 2 is false.",
              "key": "A"
            },
            {
              "content": "Statement 2 is true but Statement 1 is false.",
              "key": "B"
            },
            {
              "content": "Both are true.",
              "key": "C"
            },
            {
              "content": "Neither is true.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "25239107-bb81-48b8-9485-9c8df81a5514",
          "type": "MultipleChoice",
          "content": "Which of the following comments is invalid in a Solidity Code?",
          "hint": "noHint",
          "explanation": "Single-line comments (//) and multi-line comments (/*...*/) are possible in Solidity. \nAdditionally, there is another type of comment called a NatSpec comment, they are written with a triple slash (///) or a double asterisk block (/** ... */) and they should be used directly above function declarations or statements.\n",
          "answerKeys": [
            "A",
            "D"
          ],
          "subTopics": [
            "smart-contract"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "/This is a single line comment.",
              "key": "A"
            },
            {
              "content": "//This is a single line comment.",
              "key": "B"
            },
            {
              "content": "///This is a single line comment.",
              "key": "C"
            },
            {
              "content": "/*This is a single line comment.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6de1c98d-d533-4b04-937c-6f90db4fc63e",
          "type": "MultipleChoice",
          "content": "In the context of NatSpec comments which of the following is true?",
          "hint": "Solidity supports NatSpec comments in addition to the simple single/multi line comments.",
          "explanation": "NatSpec stands for Ethereum Natural Language Specification Format.\nIf no tags are used then the Solidity compiler will interpret a /// or /** comment in the same way as if it were tagged with @notice.\nThe Solidity compiler only interprets tags if they are external or public. You can use similar comments for internal and private functions, but those will not be parsed.\n",
          "answerKeys": [
            "A",
            "C"
          ],
          "subTopics": [
            "smart-contract"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "NatSpec stands for Ethereum Natural Language Specification Format.",
              "key": "A"
            },
            {
              "content": "NatSpec comments provide tags and in case if no tags are used , the solidity compiler will interpret (///) as (//).",
              "key": "B"
            },
            {
              "content": "The Solidity compiler only interprets tags if they are external or public.",
              "key": "C"
            },
            {
              "content": "Comments in solidity can only be made using (//) for Single-line and (/*...*/) for multi-line.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "77cd176f-04d5-464d-86fa-64992e2d4db8",
          "type": "SingleChoice",
          "content": "What does the basic structure of a contract contain?",
          "hint": "noHint",
          "explanation": "Each contract can contain declarations of State Variables, Functions, Function Modifiers, Events, Errors, Struct Types and Enum Types.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "smart-contract"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Pragma directive",
              "key": "A"
            },
            {
              "content": "Name of the contract",
              "key": "B"
            },
            {
              "content": "Data and functions",
              "key": "C"
            },
            {
              "content": "All of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "421abb3d-6f87-4e4a-a22f-af467d34035b",
          "type": "SingleChoice",
          "content": "What does a simple function definition in Solidity contain?",
          "hint": "noHint",
          "explanation": "The basic syntax is shown here.\n```\n  function function-name(parameter-list) scope returns() {\n    //statements\n  }\n```\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "state-variables-and-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Modifier definitions",
              "key": "A"
            },
            {
              "content": "Fallback definition",
              "key": "B"
            },
            {
              "content": "Function header and code",
              "key": "C"
            },
            {
              "content": "Event",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e854f94d-5e49-4e3f-9e2a-0f8a1a4d1f83",
          "type": "SingleChoice",
          "content": "Regarding constructors in solidity which statement is correct?",
          "hint": "Only one constructor is allowed.",
          "explanation": "A constructor is optional. Only one constructor is allowed, which means overloading is not supported.\nAfter the constructor has executed, the final code of the contract is stored on the blockchain. \nThe deployed code does not include the constructor code or internal functions only called from the constructor.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "state-variables-and-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Constructor overloading is supported.",
              "key": "A"
            },
            {
              "content": "A constructor is optional.",
              "key": "B"
            },
            {
              "content": "The contract deployed on the blockchain will also contain the constructor code.",
              "key": "C"
            },
            {
              "content": "None of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "611c7208-9eb2-4c4a-8d10-160081de6710",
          "type": "SingleChoice",
          "content": "Which of the options regarding the statements below are correct?\nStatement 1 - A contract in the sense of Solidity is a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain.\nStatement 2 - Contracts in Solidity are similar to classes in object-oriented languages.\n",
          "hint": "noHint",
          "explanation": "Contracts in Solidity are similar to classes in object-oriented languages. They contain persistent data in state variables, and functions that can modify these variables.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "smart-contract"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement 1 is correct but Statement 2 is incorrect.",
              "key": "A"
            },
            {
              "content": "Statement 2 is correct but Statement 1 is incorrect.",
              "key": "B"
            },
            {
              "content": "Both are correct.",
              "key": "C"
            },
            {
              "content": "Neither is correct.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b8e4a65e-683e-43a0-b0c1-7f6271177181",
          "type": "SingleChoice",
          "content": "Which of the following options are correct based on the code snippet below?\n```\ncontract OriginCoordinates {\n    uint constant x_coordinate;\n    uint immutable y_coordinate;\n\n    constructor(){\n        x_coordinate=0;\n        y_coordinate=0;\n    }\n\n\n    function get() public view returns (uint,uint) {\n        return (x_coordinate,y_coordinate);\n    }\n}\n```\n",
          "hint": "Check the declaration of the state variables.",
          "explanation": "The state variable x_coordinate cannot be initialized in the constructor as it is declared as constant.\nFor constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "state-variables-and-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "This code will not compile as solidity functions cannot have multipe return values.",
              "key": "A"
            },
            {
              "content": "This code will not compile because State Variables declared immutable cannot be initialised in a constructor.",
              "key": "B"
            },
            {
              "content": "This code will not compile because State Variables declared constant cannot be initialised in a constructor.",
              "key": "C"
            },
            {
              "content": "The code has no errors and can be deployed.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "5e40d1c1-0bbc-45f6-ae2e-eeee3715168b",
          "type": "MultipleChoice",
          "content": "Which of the following statements is correct regarding functions?",
          "hint": "noHint",
          "explanation": "Functions can be declared view in which case they promise not to modify the state, they can also be declared pure in which case they promise not to read from or modify the state.\n",
          "answerKeys": [
            "A",
            "C",
            "D"
          ],
          "subTopics": [
            "state-variables-and-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Functions outside of a contract are also called 'free functions'.",
              "key": "A"
            },
            {
              "content": "Functions declared as view can modify the state variables.",
              "key": "B"
            },
            {
              "content": "In Solidity the function is simply invoked by writing the name of the function where it has to be called.",
              "key": "C"
            },
            {
              "content": "Functions can have multiple return values.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "c60393ac-3492-4d4b-a7c7-ecee0e09e9d7",
          "type": "MultipleChoice",
          "content": "Which of the following options is correct regarding \"free functions\"?",
          "hint": "Free functions in Solidity are functions created outside of the scope of a contract.",
          "explanation": "A free function behaves like an internal function of the contract that called it. \nThe main difference is that a free function cannot directly access state variables and internal functions of contracts.\n",
          "answerKeys": [
            "B",
            "D"
          ],
          "subTopics": [
            "state-variables-and-functions"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "Free functions in solidity are functions declared inside a contract with public Visibility.",
              "key": "A"
            },
            {
              "content": "Their code is included in all contracts that call them.",
              "key": "B"
            },
            {
              "content": "They can access state variables and internal functions directly.",
              "key": "C"
            },
            {
              "content": "A free function behaves like an internal function of the contract that called it.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "c97bee69-c7c1-4932-a6f8-60c2cf4df840",
          "type": "SingleChoice",
          "content": "What does the following syntax do? \n`import * as symbolName from \"filename\";`\n",
          "hint": "noHint",
          "explanation": "The following example creates a new global symbol symbolName whose members are all the global symbols from \"filename\":\n`import * as symbolName from \"filename\";` which results in all global symbols being available in the format symbolName.symbol.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "smart-contract"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "This statement imports all global symbols from “filename” into the current global scope.",
              "key": "A"
            },
            {
              "content": "This statement creates a new global symbol symbolName whose members are all the global symbols from \"filename\".",
              "key": "B"
            },
            {
              "content": "This statement imports symbolName member from \"filename\".",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "985403b3-673a-4017-9099-76a5cc0d5f10",
          "type": "SingleChoice",
          "content": "In which scenarios is a fallback function triggered?",
          "hint": "noHint",
          "explanation": "A fallback function is called in two cases- A contract receives only Ether and no data,\nor when no function calls matched even though the account received data.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "state-variables-and-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Contract received ether and no data.",
              "key": "A"
            },
            {
              "content": "Contract received data but no function matched the function called.",
              "key": "B"
            },
            {
              "content": "Contract sent insufficient gas.",
              "key": "C"
            },
            {
              "content": "Both A & B",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e288ce1e-aa2e-48b1-9878-f7133359198c",
          "type": "SingleChoice",
          "content": "What happens when an event is called?",
          "hint": "noHint",
          "explanation": "Events are inheritable members of contracts. When you call them, they cause the arguments to be stored in the transactions log - a special data structure in the blockchain.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "events-modifiers"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "When called, events flag an error to the caller.",
              "key": "A"
            },
            {
              "content": "They provide a condition under which event a function calling the event should be executed.",
              "key": "B"
            },
            {
              "content": "They cause the arguments to be stored in the transactions log - a special data structure in the blockchain.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "138e8326-fe39-421f-ae9e-ac5a6cfb0ad0",
          "type": "MUltipleChoice",
          "content": "What are events used for?",
          "hint": "When called, events cause the arguments to be stored in the transactions log - a special data structure in the blockchain.",
          "explanation": "Events are used to inform external users that something happened on the blockchain. Smart contracts themselves cannot listen to any events.\nAll information in the blockchain is public and any actions can be found by looking into the transactions close enough but events are a shortcut to ease the development of outside systems in cooperation with smart contracts.\n",
          "answerKeys": [
            "A",
            "C"
          ],
          "subTopics": [
            "events-modifiers"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Events can be used to communicate with external users about a transaction that happened on the blockchain.",
              "key": "A"
            },
            {
              "content": "They are used for error handling.",
              "key": "B"
            },
            {
              "content": "They can be used to inform a user of any action that happened on the blockchain and can thus ease the development of outside systems in cooperation with smart contracts.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "42d7664b-47e1-4f1e-9162-af63a8c0db22",
          "type": "MultipleChoice",
          "content": "In the following snippet, what is the purpose of the code?\n```\naddress owner;\nstring private name;\nconstructor() {\n  owner = msg.sender;\n}\nmodifier onlyOwner() {\n  require(msg.sender == owner, 'Not Owner');\n  _;\n}\nfunction setName(string memory newName) public onlyOwner{\n  name = newName;\n}\n```\n",
          "hint": "Function modifiers can be used to change the behaviour of functions in a declarative way.",
          "explanation": "In the code, constructor sets the creator of the contract to the owner variable . The `onlyOwner` modifier checks that the caller of the function is the owner. the function `setName` uses the modifier `onlyOwner`. If the caller of the function is not the owner then the function does not execute.",
          "answerKeys": [
            "A",
            "B",
            "D"
          ],
          "subTopics": [
            "smart-contract"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "Upon contract creation, the owner address is initialized to the user who deployed the contract.",
              "key": "A"
            },
            {
              "content": "The function setName can only be called by the owner of the contract.",
              "key": "B"
            },
            {
              "content": "onlyOwner is a function which will throw an error each time it is called by a non-owner.",
              "key": "C"
            },
            {
              "content": "onlyOwner can be used to modify the behaviour of a function.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d8609639-3532-48ff-8f33-7ae8ce2ade62",
          "type": "SingleChoice",
          "content": "Which of the following can be used to restrict access of a function?",
          "hint": "noHint",
          "explanation": "Modifiers assist in the execution of a functions behavior. They can be used to restrict access of a function.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "events-modifiers"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "function",
              "key": "A"
            },
            {
              "content": "function modifier",
              "key": "B"
            },
            {
              "content": "event",
              "key": "C"
            },
            {
              "content": "constructor",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "33eab1f8-3a7c-4cd9-8c0d-f42a2f9f4fd3",
          "type": "SingleChoice",
          "content": "Where is `_;` instruction used in Solidity?",
          "hint": "noHint",
          "explanation": "In Solidity, `_;` is used inside a modifier to specify when the function should be executed.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "events-modifiers"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It is used in a function.",
              "key": "A"
            },
            {
              "content": "It is used in aconstructor.",
              "key": "B"
            },
            {
              "content": "It is used in a modifier.",
              "key": "C"
            },
            {
              "content": "It can be used anywhere at the file level.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "aa3caf4e-b9d8-46f9-95ac-d588df2558a7",
          "type": "SingleChoice",
          "content": "What is the returned value when `set` is called first then `get`.\n```\ncontract UnderScore {\n    uint a;\n    constructor(){\n        a=10;\n    }\n    modifier m(){\n      _;\n      if(a<=15){\n          a=a+10;\n      }\n    }\n    function set() public m {\n        a=a+10;\n    }\n    function get() public view returns (uint) {\n        return a;\n    }\n}\n```\n",
          "hint": "Notice how the function set will execute because of the modifier m.",
          "explanation": "In Solidity, `_;` is used inside a modifier to specify when the function should be executed. As the modifier has `_;` before the modifier statements, so the function code will execute first and then the modifier code. The function set will update the value of a to 20 and then the modifier code will check if the value is greater than 15 or not.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "events-modifiers"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "10",
              "key": "A"
            },
            {
              "content": "15",
              "key": "B"
            },
            {
              "content": "20",
              "key": "C"
            },
            {
              "content": "30",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "07881a7f-600c-4bfc-baf9-787f3fa70700",
          "type": "SingleChoice",
          "content": "Which of the following is a correct declaration of a function?",
          "hint": "noHint",
          "explanation": "The basic syntax of a function is shown below.\n```\n  function function-name(parameter-list) scope returns() {\n    //statements\n  }\n```\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "state-variables-and-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "public function foo() view returns(){}",
              "key": "A"
            },
            {
              "content": "public view function foo() returns(){}",
              "key": "B"
            },
            {
              "content": "function foo() view returns() public{}",
              "key": "C"
            },
            {
              "content": "function foo() public view returns(){}",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "0767755b-6790-44cd-8364-7c56acb77457",
          "type": "SingleChoice",
          "content": "Which of the following options are true regarding the statements below.  \nStatement 1 - A constructor can be either public or internal.  \nStatement 2 - A constructor code is executed once when a contract is created and it is used to initialize contract state.\n",
          "hint": "noHint",
          "explanation": "A constructor is an optional funtion and is used to initialize state variables of a contract.\nIt is executed once when a contract is created and it is used to initialize contract state.\nA constructor can be either public or internal.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "smart-contract"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement 1 is true but Statement 2 is false.",
              "key": "A"
            },
            {
              "content": "Statement 2 is true but Statement 1 is false.",
              "key": "B"
            },
            {
              "content": "Both are true.",
              "key": "C"
            },
            {
              "content": "Neither is true.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2fb21e8c-429e-4229-817b-6077c945fca0",
          "type": "MultipleChoice",
          "content": "Which of the following is true about function modifier `_;`?",
          "hint": "noHint",
          "explanation": "“_;” is a special code only used in the function modifier. It' indicates where “the rest” of the function code should go by merging the function source with the modifier code.\n\"_;\" can be used to execute the function modifier and then the function or execute the function and then the function modifier by placing \"_;\" before or after the modifier code.\n",
          "answerKeys": [
            "A",
            "B"
          ],
          "subTopics": [
            "events-modifiers"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Specified at the entry of a function and executed after the function ends.",
              "key": "A"
            },
            {
              "content": "Specified at the entry to a function and executed before the function begins.",
              "key": "B"
            },
            {
              "content": "Specified at the exit of a function and executed after the function ends.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f6d9abaf-0f05-4376-ad34-58c366ebee76",
          "type": "SingleChoice",
          "content": "How many constructors can be there in a Solidity contract?",
          "hint": "noHint",
          "explanation": "A contract can have only one constructor.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "smart-contract"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "1",
              "key": "A"
            },
            {
              "content": "2",
              "key": "B"
            },
            {
              "content": "3",
              "key": "C"
            },
            {
              "content": "Many",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "437f24c0-fa13-4ac8-bd39-3c4649aadb0c",
          "type": "SingleChoice",
          "content": "Which of the following is true regarding `_;` used in function modifiers?",
          "hint": "noHint",
          "explanation": "“_;” is a special code only used in the function modifier. Having `_;` more than once in a modifier is valid.\nIt instructs solidity to run the code in the function. It' indicates where “the rest” of the function code should go by merging the function source with the modifier code.\n",
          "answerKeys": [
            "A",
            "B",
            "C"
          ],
          "subTopics": [
            "events-modifiers"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "“_;” is a special code only used in the function modifier.",
              "key": "A"
            },
            {
              "content": "It' indicates where “the rest” of the function code should go by merging the function source with the modifier code.",
              "key": "B"
            },
            {
              "content": "Having `_;` more than once in a modifier is valid.",
              "key": "C"
            },
            {
              "content": "option 4",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "38d84a22-7517-4aaf-9018-75b533aa3e7e",
          "type": "SingleChoice",
          "content": "What will be the value of a,b and c when function func() is called?\n```\ncontract C {\n    uint a;\n    uint b;\n    uint c;\n\n    modifier modA() {\n        a = a + 1;\n        _;\n    }\n\n    modifier modB() {\n        b = b + 1;\n        _;\n        b = b + 1;\n        _;\n    }\n\n    function func() public modA modB {\n        c = c + 1;\n    }\n}\n\n```\n",
          "hint": "noHint",
          "explanation": "The default value of uint is zero so when func() is called modA code will run first, the `_;` will be replaced by modifier's code and the `_;` in the modB modifier's is replaced by the func function's code. Therefore `a=1` , `b=2` and `c=2`.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "events-modifiers"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "0,0,0",
              "key": "A"
            },
            {
              "content": "1,2,2",
              "key": "B"
            },
            {
              "content": "0,0,1",
              "key": "C"
            },
            {
              "content": "1,2,1",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d73be206-d0fe-4f75-b6d3-693275d1b069",
          "type": "SingleChoice",
          "content": "Which of the following is true about modifiers?",
          "hint": "noHint",
          "explanation": "A function can have any number of modifiers.\nVisibility modifiers for a function should come before custom access modifiers.\nModifiers can be without any parameters.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "events-modifiers"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "A function can have any number of modifiers.",
              "key": "A"
            },
            {
              "content": "Visibility modifiers for a function should come before custom access modifiers.",
              "key": "B"
            },
            {
              "content": "Modifiers can be without any parameters.",
              "key": "C"
            },
            {
              "content": "All the above.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "a8f4d89b-bfc8-4dc0-8f9e-5aab0088f13a",
          "type": "SingleChoice",
          "content": "Which of tshe following options is true regarding the below statemens?\nStatement 1 - It is allowed to emit an event in function modifiers.\nStatement 2 - A modifier can update a state variable when used with a function declared as view.\n",
          "hint": "noHint",
          "explanation": "A function declared as view can only read the state variables and not make updates to them , any modifiers attached to such function can also not make changes to the state of variables.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "events-modifiers"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement 1 is true but Statement 2 is false.",
              "key": "A"
            },
            {
              "content": "Statement 2 is true but Statement 1 is false.",
              "key": "B"
            },
            {
              "content": "Both are true.",
              "key": "C"
            },
            {
              "content": "Neither is true.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "61bc26de-8555-40ef-8f26-8235ada76c94",
          "type": "MultipleChoice",
          "content": "What does the indexed keyword do in events?",
          "hint": "noHint",
          "explanation": "You can add the attribute indexed to up to three parameters which adds them to a special data structure known as “topics” instead of the data part of the log. The indexed keyword helps you to filter the logs to find the wanted data.\nAll non-indexed arguments will be stored in the data part of the log.\n",
          "answerKeys": [
            "B",
            "C"
          ],
          "subTopics": [
            "events-modifiers"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "All indexed arguments will be stored in the data part of the log.",
              "key": "A"
            },
            {
              "content": "indexed keyword is used to log values as topics rather than data part of the log.",
              "key": "B"
            },
            {
              "content": "The indexed keyword helps you to filter the logs to find the wanted data.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "4b1b0494-f540-4a22-af9a-bdd791fb2834",
          "type": "SingleChoice",
          "content": "Which of the following scenarios will result in a runtime time errors?",
          "hint": "noHint",
          "explanation": "Some of the runtime errors are out-of-gas error, data type overflow error, divide by zero error, array-out-of-index error, etc.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "errors"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "out-of-gas error",
              "key": "A"
            },
            {
              "content": "data type overflow error",
              "key": "B"
            },
            {
              "content": "divide by zero error",
              "key": "C"
            },
            {
              "content": "All of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "411289f8-19ca-4f57-8bd1-c55aea028b5a",
          "type": "SingleChoice",
          "content": "Error handling and validations in Solidity can be done using which of the following?",
          "hint": "noHint",
          "explanation": "Error handling and validations in solidity is done using revert, require, assert and try/catch.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "errors"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "revert",
              "key": "A"
            },
            {
              "content": "require",
              "key": "B"
            },
            {
              "content": "assert",
              "key": "C"
            },
            {
              "content": "All of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "c513ceac-7031-4473-aaa0-d17870eeeb0a",
          "type": "MultipleChoice",
          "content": "Which of the following scenarios will cause a Panic type exception to be generated?",
          "hint": "noHint",
          "explanation": "A Panic exception is generated in the following situations.\n    * If you call assert with an argument that evaluates to false.\n    * If an arithmetic operation results in underflow or overflow.\n    * If you divide or modulo by zero.\n  Calling require(x) where x evaluates to false will result in an Error exception.\n",
          "answerKeys": [
            "A",
            "B",
            "C"
          ],
          "subTopics": [
            "errors"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "If you call assert with an argument that evaluates to false.",
              "key": "A"
            },
            {
              "content": "If an arithmetic operation results in underflow or overflow.",
              "key": "B"
            },
            {
              "content": "If you divide or modulo by zero.",
              "key": "C"
            },
            {
              "content": "Calling require(x) where x evaluates to false.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "3c2e68b2-0577-411b-8980-2389c0d859ac",
          "type": "SingleChoice",
          "content": "Consider the statements below regarding Error(string) and Panic(uint256) type error signatures.\nStatement 1 - Error(string) is used for regular error conditions while Panic(uint256) is used for errors that should not be present in bug-free code.\nStatement 2 - Panic type exception occurs via require and Error via assert.\n",
          "hint": "noHint",
          "explanation": "Solidity supports two error signatures: Error(string) and Panic(uint256). Error(string) is used for regular error conditions while Panic(uint256) is used for errors that should not be present in bug-free code.\nPanic is generated by calling assert with an argument showing false and error is generated by calling require with an argument showing false.\n",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "errors"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement 1 is true but Statement 2 is false.",
              "key": "A"
            },
            {
              "content": "Statement 2 is true but Statement 1 is false.",
              "key": "B"
            },
            {
              "content": "Neither is true.",
              "key": "C"
            },
            {
              "content": "Both are true.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "734e92a7-07e9-43d6-b346-3be5d5e20109",
          "type": "SingleChoice",
          "content": "Which of the following scenarios will cause an Error type exception to be generated?",
          "hint": "noHint",
          "explanation": "An Error exception is generated by the compiler in the following cases-\n  * Calling require(x) where x evaluates to false.\n  * If you perform an external function call targeting a contract that contains no code.\n  * If you use revert() or revert(\"description\").\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "errors"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Calling require(x) where x evaluates to false.",
              "key": "A"
            },
            {
              "content": "If you perform an external function call targeting a contract that contains no code.",
              "key": "B"
            },
            {
              "content": "If you use revert() or revert(\"description\").",
              "key": "C"
            },
            {
              "content": "All of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "c3b40fc3-0ff1-49d8-aa2b-9a454ef568f0",
          "type": "MultipleChoice",
          "content": "Which of the following options in correct regarding errors?",
          "hint": "noHint",
          "explanation": "Using revert() causes a revert without any error data while revert(\"description\") will create an Error(string) error.\nUsing a custom error instance will usually be much cheaper than a string description, because you can use the name of the error to describe it, which is encoded in only four bytes.\nThe two ways if (!condition) revert(...); and require(condition, ...); are equivalent as long as the arguments to revert and require do not have side-effects, for example if they are just strings.\n",
          "answerKeys": [
            "A",
            "B",
            "C"
          ],
          "subTopics": [
            "errors"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The two ways if (!condition) revert(...); and require(condition, ...); are equivalent.",
              "key": "A"
            },
            {
              "content": "Using a custom error instance will usually be much cheaper than a revert.",
              "key": "B"
            },
            {
              "content": "Using revert() causes a revert without any error data while revert(\"description\") will create an Error(string) error.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "c4123a41-b80e-4a83-adc7-7a189e1a6041",
          "type": "SingleChoice",
          "content": "To check an integer overflow/underflow , which of the following function should be used?",
          "hint": "noHint",
          "explanation": "Assert should only be used to test for internal errors, and to check invariants. \nProperly functioning code should never create a Panic, not even on invalid external input.\nIn this case integer overflow/underflow is undesirable and will lead to a bug wich needs to be fixed.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "errors"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "revert",
              "key": "A"
            },
            {
              "content": "assert",
              "key": "B"
            },
            {
              "content": "require",
              "key": "C"
            },
            {
              "content": "None of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "fea2cad9-970c-40cc-8fa9-ec46f0b3155a",
          "type": "SingleChoice",
          "content": "Which of the following catch blocks is valid ?",
          "hint": "noHint",
          "explanation": "Solidity supports different kinds of catch blocks depending on the type of errors.\n  * `catch Error(string memory reason) { ... }`, This catch clause is executed if the error was caused by `revert(\"reasonString\")` or `require(false, \"reasonString\")`.\n  * `catch Panic(uint errorCode) { ... }`, If the error was caused by a panic, i.e. by a failing assert, division by zero, invalid array access, arithmetic overflow and others, this catch clause will be run.\n  * `catch (bytes memory lowLevelData) { ... }`, This clause is executed if the error signature does not match any other clause, if there was an error while decoding the error message, or if no error data was provided with the exception. The declared variable provides access to the low-level error data in that case.\n  * We can just use catch { … } if we are not interested in error data.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "custom-errors-and-try-catch"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`catch Error(string memory reason) { ... }`",
              "key": "A"
            },
            {
              "content": "`catch Panic(uint errorCode) { ... }`",
              "key": "B"
            },
            {
              "content": "`catch (bytes memory lowLevelData) { ... }`",
              "key": "C"
            },
            {
              "content": "All of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6c484192-0531-42ec-a0fc-494132dea432",
          "type": "SingleChoice",
          "content": "Which of the following options is correct regarding the statements below,\nStatement 1 - Solidity has special functions like the receive ether function and the fallback function.\nStatement 2 - The declaration `receive() external payable { ... }` is not a valid function declaration.\n",
          "hint": "noHint",
          "explanation": "A Receive Ether Function is declared using `receive() external payable { ... }` (without the function keyword). \nThis function cannot have arguments, cannot return anything and must have external visibility and payable state mutability. It can be virtual, can override and can have modifiers.\n",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "state-variables-and-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement 1 is true but Statement 2 is false.",
              "key": "A"
            },
            {
              "content": "Statement 2 is true but Statement 1 is false.",
              "key": "B"
            },
            {
              "content": "Both are true.",
              "key": "C"
            },
            {
              "content": "Neither is true.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f6231249-cc8e-402b-9536-20dedb877205",
          "type": "SingleChoice",
          "content": "Which of the following options is correct?",
          "hint": "noHint",
          "explanation": "Functions can be defined at file-level. Such functions are called “free functions” (as opposed to functions bound to a specific contract).\nFree functions are always internal functions and are meant to replace internal library functions and their very special behaviour.\nA free function behaves like an internal function of the contract that called it. The main difference is that a free function cannot directly access state variables and internal functions of contracts.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "state-variables-and-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It is not necessary for functions to be bound to a specific contract.",
              "key": "A"
            },
            {
              "content": "Free functions cannot have visibility.",
              "key": "B"
            },
            {
              "content": "Free functions are like internal functions.",
              "key": "C"
            },
            {
              "content": "All of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "285aa1cb-75de-4cf8-9d33-8987e14955a7",
          "type": "SingleChoice",
          "content": "What effect does a \"require\" keyword have on an if/else statement when it's false?",
          "hint": "noHint",
          "explanation": "`require` accepts a single argument and returns a boolean value after evaluation, it also has a custom string message option. If false then exception is raised and execution is terminated. The unused gas is returned back to the caller and the state is reversed to its original state.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "errors"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It goes to the next function.",
              "key": "A"
            },
            {
              "content": "It triggers the fallback function.",
              "key": "B"
            },
            {
              "content": "It stops the contract and returns any unused gas.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "be0f341e-e428-401c-98a0-d08061b3dadd",
          "title": "Declaring a function",
          "shortTitle": "Declaring a function",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=71cmPaD_AnQ",
          "subTopics": [
            "state-variables-and-functions"
          ],
          "details": "This video covers \n1) Function declaration in Solidity \n2) View functions (read-only) and non-view functions (can change Blockchain data).\n"
        },
        {
          "uuid": "490e6379-87ca-4827-8a62-f2a42bd66383",
          "title": "Function Modifiers",
          "shortTitle": "Function Modifier",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=b6FBWsz7VaI",
          "subTopics": [
            "events-modifiers"
          ],
          "details": "Function modifiers allow your code to have less repetitive, re-useable code logic. This video explains the declaration and use of modifiers.\n"
        },
        {
          "uuid": "bfaa19ee-63d9-423d-828c-a7f7fe5bf600",
          "title": "Events",
          "shortTitle": "events",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=jaMHPT-78HM",
          "subTopics": [
            "events-modifiers"
          ],
          "details": "In Solidity, you can use events to push data to outside consumers, like web frontends.\nThis video shows how to declare and emit events in Solidity.\n"
        },
        {
          "uuid": "f18d61c9-9680-4cac-991f-1a15a11525f9",
          "title": "Error Handling",
          "shortTitle": "Error Handling",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=1Mi1ub9bIv8",
          "subTopics": [
            "errors"
          ],
          "details": "Solidity uses state-reverting exceptions to handle errors. \nThis video covers how error handling in solidity is done using revert, require, assert and try/catch.\n"
        },
        {
          "uuid": "5793d857-a2e7-4345-a067-d16c7c8c4241",
          "title": "Structure of Smart contract",
          "shortTitle": "Contract Structure",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=yzcp594R92c",
          "subTopics": [
            "smart-contract"
          ],
          "details": "This video explains the typical layout of a Solidity source file: \n1) Pragma statement\n2) Imports\n3) Contract declaration\n4) Variable \n5) Function declarations\n"
        }
      ],
      "summaries": [
        {
          "title": "Structure of a smartcontract",
          "shortTitle": "contract structure",
          "key": "smart-contract",
          "details": "The source code of a solidity contract begins with a license identifier to avoid any potential legal issues that could arise if the code is published as open source. The compiler version is specified using the keyword \n`pragma` and can be placed anywhere within the contract, though it is generally considered best practice to specify it at the top of the document. For single-line comments, we need to use `//`. For multiline comments, we need to use `/*comments here */`. \nSolidity comments can also be written in `NatSpec` format. Developers use it for documenting return variables, functions, and so on. To define a single-line comment in this format, we need to use `///` for multiline, we need to use `/** comments here */`. \n`import` keyword is used for importing files from other resources\n\nSolidity has a special kind of function called a `constructor` function. This function will be called automatically when you deploy your contract. You can define a constructor function using the keyword 'constructor' followed by the function's code.\n\n```solidity\n//SPDX-License-Identifier:MIT \npragma solidity ^0.8.2; // compiler version is specified using the keyword pragma\n\nimport \"priceconverter.sol\"; // this is normal importing\nimport \"priceconverter.sol\" as pc; // if you want to import one file but with different name\nimport { price1 as p1, price2 } from \"storagefactory.sol\"; // If we want to import only specific variables or functions from a file\n\ncontract SolidityStructure {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n    // this is a single line comment\n\n    /* this is a \n        multi line comment */\n\n    /* msg.sender is the address that has called or initiated a function or created a transaction. \n            But at the time of deployment it will be the address of the deployer of the contract */\n\n    /// This is NatSpec single line comment\n\n    /**\n    This is NatSpec multi line comment\n    */\n}\n\n```\nIn the above snippet, the constructor function will only be called once when the contract is deployed. This function will assign the deployer address to the `owner`. `msg.sender` is the address that has called or \ninitiated a function or created a transaction. But at the time of deployment it will be the address of the deployer of the contract.\n"
        },
        {
          "title": "Statevariables and Functions",
          "shortTitle": "Functions",
          "key": "state-variables-and-functions",
          "details": "\nState variables are variables that are stored permanently on the blockchain. They can be declared as `constant` and `immutable`, but immutable can be redeclared in the constructor. Constant and immutable variables reduce the gas cost.\nFunctions in solidity are essentially just like any other programming language - they are pieces of code that can be executed by simply calling the function. Functions can be declared inside or outside of a contract. \nThe functions which are declared outside of the contract are referred to as free functions. Free functions don't have access to variables that are inside the contract and they also don't have visibility. \nThis means that we cannot add `public` and `external` keywords.\n\n`fallback` and `recieve` are special functions. The `fallback` will be executed if:\n1. None of the other functions match the function identifier \n2. If ether is transferred to the contract with some call data\n\nIf ether is sent to a contract without any call data, the receive function will be executed. If receive is not defined, fallback will be executed. The `fallback` and `receive` functions must be defined with the `payable` keyword and visibility. \nThere are two keywords which can restrict the state mutability of a function: `view` and `pure`. `view`will restrict the function to read-only but if `pure` is defined, that function will not be able to read or write.\n\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.5;\n\ncontract SimpleProgram {\n    uint public value = 23;\n    uint public answer = add(value, 1); // calling the free function add\n    address immutable owner;\n\n    constructor() {\n        owner = msg.sender; // redelcaring the immutable variable\n    }\n\n    uint public product = multiply(value, 2); // calling the function multiply\n\n    function multiply(uint a, uint b) public pure returns (uint) { // function inside the contract with pure keyword\n        return a * b;\n    } \n    // Data types of arguments and returning values should be defined for a function\n\n    receive() external payable { // recieve function declaration\n        setValue(24);\n    }\n\n    function setValue(uint x) internal {\n        value = x;\n    }\n\n    function check_value() public view returns (uint) {\n        // view keyword restrict the function check_a to read only\n        return value;\n    }\n\n    fallback() external payable { // fallback function declaration\n        setValue(12);\n    }\n\n\n}\n\nfunction add(uint a, uint b) pure returns (uint sum) {    // free function\n    sum = a + b;\n}\n\n```\n"
        },
        {
          "title": "Events and Function modifiers",
          "shortTitle": "Events and modifiers",
          "key": "events-modifiers",
          "details": "Events are a way of logging data in the blockchain. They are declared using the keyword `event` and logged using the keyword `emit`. Once they are logged, they can be viewed in etherscan if the smart contract has been deployed in \nEthereum or one of its testnets. Function modifiers are a declarative way of changing the behavior of functions. The modifier is declared using the keyword `modifier`. Function modifiers are added as a keyword to the functions. \nThey are used to check a condition before the function is executed.\nSyntax for declaring the modifier:\n```solidity\nmodifier Identifier {\n    //code comes here\n}\n```\nThe below snippet shows how to use events and function modifiers. whenever function `setValue` executes the event is logged as `emit Log(x,msg.sender)` defines emitting of the event with the message value and the senders address.\nThe `_;`is a special keyword inside the modifier which tells the compiler to execute the parent function i.e, in this case `setValue` function. \n\n```solidity\n//SPDX-License-Identifier:MIT\npragma solidity ^0.8.0;\n\ncontract FunctionModifiers {\n    address public immutable owner;\n    uint public favourite_number = 7;\n    event Log(uint , address );// declaration of the event\n    // Identifiers for event's arguments is not mandatory\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not owner\");// declaration of the modifier\n        _; // this will tell the compiler to execute the parent function\n    }\n\n    function setValue(uint x) public onlyOwner returns (uint v) { // adding modifier to the function\n        favourite_number = x;\n        emit Log(x,msg.sender); // event is logged using the emit keyword\n        v = x;\n    }\n}\n\n```\n"
        },
        {
          "title": "Error Handling",
          "shortTitle": "Error-handling",
          "key": "errors",
          "details": "Solidity uses state-reverting exceptions to handle errors. Such an exception reverts all changes made to the state in the current call (and all its sub-calls) and flags an error to the caller. Solidity has many functions for error handling. \nCompile time or runtime errors can occur. Error handling can be done using assert, require, revert, try-catch and custom errors.\n\n #### Assert \n The `assert` function creates an error of type `Panic(uint256)` when used. It is primarily employed to check for internal errors and conditions that must always evaluate to be true. If the condition in the assert statement fails, \n it implies that there is a bug in the smart contract. The assert function takes one required parameter, which is the condition, and an optional parameter of the type string.\n \n #### Require\n The `require` function is used to test for errors that usually occur, whereas the assert function is used to test for errors that should never happen. The require function takes one required parameter, which is a condition, \n and an optional string parameter.\n\n require exception is triggered for the following cases:\n * Calling require(x) where x evaluates to false.\n * If you perform an external function call targeting a contract that contains no code.\n * If you use revert() or revert(\"description\").\n * If your contract receives Ether via a public function without payable modifier.\n * If your contract receives Ether via a public getter function.\n\n #### Revert\n Revert is a function that is similar to require but does not evaluate any conditions. It is used to generate exceptions, display errors, and revert the function calls. Calling a revert statement implies an exception is thrown, \n the unused gas is returned, and the state reverts to its original state.\n\n The below code snippet explains how to use assert, revert and require.    \n \n ```solidity\n contract Errors{\n   address immutable public owner;\n   constructor(){\n       owner = msg.sender;\n   }\n   function foo(uint x)public view{\n       assert(msg.sender!= owner); // if caller of the function is not the owner exception is thrown \n       require(x==1,\"the value 0 is not supported\");// if the parameter equals one require exception is thrown and state is reverted\n       if(x>100){\n           revert(\"the value exceeded\");// state is reverted of the value of x exceed 100\n       }\n\n   }\n\n }\n ```\n"
        },
        {
          "title": "Custom Errors and try-catch",
          "shortTitle": "Custom Errors",
          "key": "custom-errors-and-try-catch",
          "details": "In a `try-catch` statement, the try block will execute some code. If it gets any errors, the caught statement will be executed. A failure in an external call can be caught using a try/catch statement.\nThe `try` keyword has to be followed by an expression representing an external function call or a contract creation (`new ContractName()`). One try block can have many catch blocks.\nCustom errors help to reduce gas costs as the error message can be customized. They are defined using the keyword `error`. `try-catch` must be defined inside a function.\n\nIn the below snippet we are defining a try-catch block for an external call. If the try block executes sucessfully the `getOwner` variable will be assugned a value which will be equal to the address of the account from which the contract\n`External contract` is deployed. If there is an error catch blocks will be executed. The custom error is defined as `Logic` in the below snippet. Custom error is thrown when the input/argument of the function `testCustom_error` is greater than 10. \n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.5;\n\ncontract Errors{\n    ExternalContract object;\n    error Logic(string message);// defining the custom error\n    address public getOwner;\n    function setupOject(ExternalContract addr) public{ // creating the object of the external contract\n        object = addr;\n    }\n  \n    function callExternalContract() public returns(string memory returnmessage){ \n        // data location must be specified for data types like arrays, structs and strings if it is passed as an argument to a function\n        try object.viewAdress() returns(address addressOwner){ // making external call using try catch\n            getOwner= addressOwner;\n            return string(\"sucess\");\n        }catch Error(string memory message){ \n            return message;\n        }catch Panic(uint){\n            return \"panic-error\";\n        }\n\n    }\n    \n    function testCustom_error(uint x) public pure {\n        if (x > 10) {\n            revert Logic(\"the value exceeded 10\");// state is reverted with the custom error Logic\n        }\n    }\n\n\n}\n\ncontract ExternalContract{ // this is our external\n    address public immutable owner;\n    constructor(){\n        owner = msg.sender;\n    }\n    function viewAdress() public view returns(address){\n        return owner;\n    }\n\n}\n\n```\n"
        }
      ]
    },
    {
      "title": "Types",
      "key": "data-types",
      "details": "This chapter explains the basics of data types used in Solidity.",
      "order": 1,
      "explanations": [],
      "questions": [
        {
          "uuid": "89128b13-bd0f-4887-85c4-1308dfbc3234",
          "type": "MultipleChoice",
          "content": "Which of the following are not valid data types in solidity?",
          "hint": "noHint",
          "explanation": "floating point data and character data types are not valid in solidity.",
          "answerKeys": [
            "B",
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "bool",
              "key": "A"
            },
            {
              "content": "float",
              "key": "B"
            },
            {
              "content": "address",
              "key": "C"
            },
            {
              "content": "char",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "5413170f-f8c0-40fd-b17a-9481650eaa72",
          "type": "SingleChoice",
          "content": "What is the default value of int data type in solidity?",
          "hint": "noHint",
          "explanation": "null and undefined do not exist in solidity.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "null",
              "key": "A"
            },
            {
              "content": "0",
              "key": "B"
            },
            {
              "content": "undefined",
              "key": "C"
            },
            {
              "content": "1",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "165cc35e-7d95-4273-a61a-621916e5ef05",
          "type": "SingleChoice",
          "content": "Which of the following statements is incorrect regarding data types in solidity?",
          "hint": "noHint",
          "explanation": "The range of uintx in solidity is $[0,2^x -1]$, the range of intx is $[-2^{x-1},2^{x-1}-1]$ , boolean values only take true/false values and address literals take 20 bytes hexadecimal values.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "The range of uint32 data type is from 0 upto $2^{32} -1$",
              "key": "A"
            },
            {
              "content": "Bool data type can only take true and false values.",
              "key": "B"
            },
            {
              "content": "The range of int256 data type is from $-2^{256}+1$ to $2^{256}-1$",
              "key": "C"
            },
            {
              "content": "address data type holds a 20 byte value",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f54382c5-2dfc-4cd8-9e29-5d764cf59d53",
          "type": "SingleChoice",
          "content": "Which of the following statements about address data type in solidity are not correct?",
          "hint": "address holds a 20 byte value.",
          "explanation": "address payable is same as address but with aditional members send and transfer.",
          "answerKeys": [
            "A",
            "B",
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "Address payable has a larger size compared to address.",
              "key": "A"
            },
            {
              "content": "Implicit type conversion from address payable to address are not allowed.",
              "key": "B"
            },
            {
              "content": "If you need a variable of type address and plan to send Ether to it, then declare its type as address payable.",
              "key": "C"
            },
            {
              "content": "Explicit conversion of data type byte 32 to address is allowed.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d5773538-949b-4909-b91e-5f035808b8bc",
          "type": "SingleChoice",
          "content": "Which of the following is not a valid member of type `address`?",
          "hint": "noHint",
          "explanation": "keccak256 is a globally available function in solidity used to calculate the `keccak256` hash of an input . balance , codehash and transfer are methods of the address type.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "balance",
              "key": "A"
            },
            {
              "content": "keccak256",
              "key": "B"
            },
            {
              "content": "codehash",
              "key": "C"
            },
            {
              "content": "transfer",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b6a45240-74b1-4243-b3b1-9c42c154be7e",
          "type": "MultipleChoice",
          "content": "Which of the following are true regarding constant and immutable variables in solidity?",
          "hint": "these variables cannot be modified after the contract has been constructed.",
          "explanation": "For constant variables, the value has to be a constant at compile time and it has to be assigned where the variable is declared whearas immutables are a little less restrictive and can be assigned an arbitrary value in the constructor of the contract or at the point of their declaration.",
          "answerKeys": [
            "A",
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "For constant variables, the value has to be fixed at compile-time. For immutable, value can be assigned at construction time.",
              "key": "A"
            },
            {
              "content": "Compared to regular state variables, the gas costs of constant & immutable variables are much higher.",
              "key": "B"
            },
            {
              "content": "Variables declared as immutable are a bit less restricted than those declared as constant.",
              "key": "C"
            },
            {
              "content": "Immutable variables can be assigned more than once.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b0c8e946-2740-499a-9863-3173f1dc8a52",
          "type": "SingleChoice",
          "content": "in solidity `0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF` is an example of-",
          "hint": "noHint",
          "explanation": "addresses holds 20 byte hexadecimal literals.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "address",
              "key": "A"
            },
            {
              "content": "uint",
              "key": "B"
            },
            {
              "content": "string",
              "key": "C"
            },
            {
              "content": "array",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "944228da-440e-43d3-b0b8-a9a3751aa5b9",
          "type": "SingleChoice",
          "content": "which of the following is not a valid `array` declaration?",
          "hint": "noHint",
          "explanation": "`type arrayName [ arraySize ];` declares an array of fixed size in Solidity,\n`type[] arrayName;` declares an array of dynamic size in solidity.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`uint arr[10];`",
              "key": "A"
            },
            {
              "content": "`int []arr;`",
              "key": "B"
            },
            {
              "content": "`uint arr[] = [1,2,3];`",
              "key": "C"
            },
            {
              "content": "`int [3]arr;`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "42d6e1ad-75b3-41a8-88d7-7aa7f958619f",
          "type": "SingleChoice",
          "content": "What will be the value of `arr[arr.length-2]` after execution of the following code?\n```\n        uint[] arr;\n        arr = [1,2,3];\n        arr.push(1);\n        arr.push(2);\n        delete arr[1];\n        arr.pop();\n```\n",
          "hint": "delete method does not change the length of the array.",
          "explanation": "`array.push(x)` is used to add element x to the end of the array , `array.length` returns the length of the array \nand `delete array[x]` deletes the item at index x of the array and leaves all other elements and the length of \nthe array untouched.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "1",
              "key": "A"
            },
            {
              "content": "undefined",
              "key": "B"
            },
            {
              "content": "2",
              "key": "C"
            },
            {
              "content": "3",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2865fa2d-80a9-468d-9332-ab73613c216e",
          "type": "MultipeChoice",
          "content": "Which of the following statements is correct about arrays in solidity ?",
          "hint": "arrays in solidity are homogenous.",
          "explanation": "`arrays` in solidity can store \"value-types\" like boolean , integers etc and can be declared with the new keyword. \nArray indexing in solidity starts with 0 like most other programming languages.\n",
          "answerKeys": [
            "B",
            "C",
            "D"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "They can hold values of different data types.",
              "key": "A"
            },
            {
              "content": "They can hold primitive data types like uint, bool , address , or string.",
              "key": "B"
            },
            {
              "content": "Array indexing in solidity starts with 0.",
              "key": "C"
            },
            {
              "content": "`uint arr[] = new uint[](3)` is a valid array declaration.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b16b49ad-c70d-4c19-a19f-b51521a8f3b0",
          "type": "MultipleChoice",
          "content": "Which of the following statements is correct about enums?",
          "hint": "Enums can have a maximum of 256 members.",
          "explanation": "The options in enum are represented by subsequent unsigned integer values starting from 0. Using `type(NameOfEnum).min` and `type(NameOfEnum).max` you can get the smallest and respectively largest value of the given enum.",
          "answerKeys": [
            "A",
            "C",
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "They require at least one member, and its default value when declared is the first member.",
              "key": "A"
            },
            {
              "content": "They cannot have more than 128 members.",
              "key": "B"
            },
            {
              "content": "Their options are represented by subsequent unsigned integer values starting from 0.",
              "key": "C"
            },
            {
              "content": "`type(NameOfEnum).min` gives the smallest value in the enum.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "663929a6-3a12-43fd-b0ff-ac07c2e34467",
          "type": "SingleChoice",
          "content": "Which of the following is not a reference type?",
          "hint": "noHint",
          "explanation": "enum is a value type.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "arrays",
              "key": "A"
            },
            {
              "content": "mapping",
              "key": "B"
            },
            {
              "content": "struct",
              "key": "C"
            },
            {
              "content": "enum",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d118157f-2d86-4ee3-bedc-de508017477a",
          "type": "MultipleChoice",
          "content": "Which of the following is not a valid data location for a reference data type in solidity?",
          "hint": "noHint",
          "explanation": "address is a value type in solidity whearas memory , storage and calldata are data locations for \"reference-types\".",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "memory",
              "key": "A"
            },
            {
              "content": "storage",
              "key": "B"
            },
            {
              "content": "address",
              "key": "C"
            },
            {
              "content": "calldata",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1e3a6ea0-7b36-4e11-98c5-d4fd9f3e49e1",
          "type": "SingleChoice",
          "content": "`uint[][5]` in solidity is -",
          "hint": "two dimensional arrays can be initialized in solidity.",
          "explanation": "An array of 5 dynamic arrays of uint is written as `uint[][5]`. The notation is reversed compared to some other \nlanguages. In Solidity, X[3] is always an array containing three elements of type X, even if X is itself an array. \nThis is not the case in other languages such as C.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "Incorrect way to initialize array",
              "key": "A"
            },
            {
              "content": "A dynamic array of 5 arrays",
              "key": "B"
            },
            {
              "content": "An array of 5 dynamic arrays",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "723b95b6-504c-41ff-9b16-22f22756fadd",
          "type": "SingleChoice",
          "content": "Which of the following is the correct way to compare two strings str1 and str2 in solidity?",
          "hint": "noHint",
          "explanation": "Solidity does not have string manipulation functions, but there are third-party string libraries. You can also \ncompare two strings by their keccak256-hash using  `keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))` \nand concatenate two strings using `string.concat(s1, s2)`.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`str1 == str2`",
              "key": "A"
            },
            {
              "content": "`keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))`",
              "key": "B"
            },
            {
              "content": "`string.concat(s1, s2)`",
              "key": "C"
            },
            {
              "content": "All of above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b4b39948-5ba0-4791-886f-84ebae031b46",
          "type": "SingleChoice",
          "content": "What does the following syntax do?\n```\n      using SafeMath for uint;\n```\n",
          "hint": "SafeMath is a library and can be imported in solidity.",
          "explanation": "Arithmetic operations in Solidity wrap on overflow. This can easily result in bugs. Using SafeMath reverts the transaction when an operation overflows.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Imports the SafeMath library",
              "key": "A"
            },
            {
              "content": "Makes uint variable immutable",
              "key": "B"
            },
            {
              "content": "Links SafeMath to uint types",
              "key": "C"
            },
            {
              "content": "Sets the SafeMath variable to an uint",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6d21e243-1d81-4946-8c3d-1e19df119599",
          "type": "SingleChoice",
          "content": "Which of the following is an example of int8?",
          "hint": "What is the range of values int8 can take?",
          "explanation": "int8 can take values from -127 to 128.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Null",
              "key": "A"
            },
            {
              "content": "-255",
              "key": "B"
            },
            {
              "content": "0",
              "key": "C"
            },
            {
              "content": "1000",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "9e320266-d211-42d2-9931-c3bc2e7401ac",
          "type": "SingleChoice",
          "content": "Which of the following is an example of a byte value?",
          "hint": "bytes can accept hexadecimal values.",
          "explanation": "The bytes data type in Solidity is a dynamically sized `byte[]` array and can accept hexadecimal values beginning with 0x.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`0x65`",
              "key": "A"
            },
            {
              "content": "True/False",
              "key": "B"
            },
            {
              "content": "Hello World!",
              "key": "C"
            },
            {
              "content": "`[10,20,30]`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "0251f4f5-c96b-4018-b33c-cf570ebfe638",
          "type": "SingleChoice",
          "content": "What is wrong with the following code ?\n```\n// SPDX-License-Identifier: GPL-3.0\n  pragma solidity >=0.4.16 <0.9.0;\n\n  contract C {\n      function f(uint len) public pure {\n          uint[] memory a = new uint[](7);\n          b[6] = 8;\n          b.push(5);\n  }\n}\n```\n",
          "hint": "noHint",
          "explanation": "Memory arrays cannot be extended during runtime. The member function push does not exist. If you need to resize your memory array, you need to create a new array with the desired length and copy every element from the old array.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It is not not possible to declare an array with new keyword",
              "key": "A"
            },
            {
              "content": "`b[6]=8` is incorrect assignment for a memory array",
              "key": "B"
            },
            {
              "content": "It is not not possible to use push function with a memory array",
              "key": "C"
            },
            {
              "content": "The code is correct",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f92bdc52-4d0f-44de-b763-0462f3fe65c7",
          "type": "SingleChoice",
          "content": "Statement 1- The array literal `[-1,1]` is invalid. \nStatement 2- Calling `push()` member function on an array can be used to append a zero-initialized element at the end of the array.\nWhich of the following options is correct?\n",
          "hint": "noHint",
          "explanation": "The array literal `[1, -1]` is invalid because the type of the first expression is uint8 while the type of the \nsecond is int8 and they cannot be implicitly converted to each other. To make it work, you can use `[int8(1), -1]`, \nfor example. Methods `.push()` and `.push(value)` can be used to append a new element at the end of the array, \nwhere .push() appends a zero-initialized element and returns a reference to it.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement 1 is true.",
              "key": "A"
            },
            {
              "content": "Statement 2 is true.",
              "key": "B"
            },
            {
              "content": "Both are true.",
              "key": "C"
            },
            {
              "content": "Neither is true.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8adbf18e-9fbb-416b-b0a0-b319e642b936",
          "type": "MultipleChoice",
          "content": "Which of the following statements is correct?",
          "hint": "noHint",
          "explanation": "It is not possible for a struct to contain a member of its own type, although the struct itself can be the value type of a mapping member or it can contain a dynamically-sized array of its type. Struct types can be used inside mappings and arrays and they can themselves contain mappings and arrays.",
          "answerKeys": [
            "B",
            "C"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It is possible for a struct to contain a member of its own type.",
              "key": "A"
            },
            {
              "content": "The dot operator is used to access members of a struct.",
              "key": "B"
            },
            {
              "content": "Struct types can be used inside mappings and arrays and they can themselves contain mappings and arrays.",
              "key": "C"
            },
            {
              "content": "None of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "49928b3a-750a-42e3-a358-274275fa82a8",
          "type": "SingleChoice",
          "content": "Which of the following statements is correct about mapping data type?",
          "hint": "noHint",
          "explanation": "Mappings can only have a data location of storage. The KeyType can be any built-in value type, bytes, string, or any contract or enum type. Other user-defined or complex types, such as mappings, structs or array types are not allowed. ValueType can be any type, including mappings, arrays and structs.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "User-defined or complex types, such as mappings, structs or array types are not allowed as key and \"value-types\" in a mapping.",
              "key": "A"
            },
            {
              "content": "Mappings can have any data location.",
              "key": "B"
            },
            {
              "content": "All primitive data types are allowed as key and value pairs.",
              "key": "C"
            },
            {
              "content": "All of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "861e7d61-22e2-48db-b6e9-5f95c4b0fbaa",
          "type": "SingleChoice",
          "content": "In the following code snippets where is implicit type conversion possible?",
          "hint": "noHint",
          "explanation": "In the example below, y and z, the operands of the addition, do not have the same type, but uint8 can be implicitly converted to uint16 and not vice-versa.  uint8 is convertible to uint16 and int128 to int256, but int8 is not convertible to uint256, because uint256 cannot hold values such as -1.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "uint8 x; uint16 y; uint32 z=x+y;",
              "key": "A"
            },
            {
              "content": "uint8 x; uint16 y; uint8 z=x+y;",
              "key": "B"
            },
            {
              "content": "int8 x; uint16 y; uint32 z=x+y;",
              "key": "C"
            },
            {
              "content": "Implicit Type conversion is not possible in Solidity.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e383c36b-6272-4467-ae2e-c69c22ce60bc",
          "type": "SingleChoice",
          "content": "What is the correct declaration for a mapping type ?",
          "hint": "noHint",
          "explanation": "mapping types use the syntax `mapping(KeyType => ValueType)` and variables of mapping type are declared using \nthe syntax `mapping(KeyType => ValueType)` VariableName`. The KeyType can be any built-in value type, bytes, string, \nor any contract or enum type. Other user-defined or complex types, such as mappings, structs or array types are \nnot allowed. ValueType can be any type, including mappings, arrays and structs.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "mapping-type"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`mapping(uint -> address) someMapping;`",
              "key": "A"
            },
            {
              "content": "`mapping(struct -> address) someMapping;`",
              "key": "B"
            },
            {
              "content": "`mapping (uint => address) someMapping;`",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "63af76dd-2db1-4b0b-bc49-9fa5deb0b6a5",
          "type": "MultipleChoice",
          "content": "Which of the following statements is correct about fixed point numbers?",
          "hint": "noHint",
          "explanation": "Signed and unsigned fixed point number of various sizes. Keywords ufixedMxN and fixedMxN, where M represents the number of bits taken by the type and N represents how many decimal points are available. M must be divisible by 8 and goes from 8 to 256 bits. N must be between 0 and 80, inclusive. ufixed and fixed are aliases for ufixed128x18 and fixed128x18, respectively.",
          "answerKeys": [
            "A",
            "B",
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "They can be declared with Keywords `ufixedMxN` and `fixedMxN`.",
              "key": "A"
            },
            {
              "content": "Fixed point numbers are not fully supported by Solidity yet. They can be declared, but cannot be assigned to or from.",
              "key": "B"
            },
            {
              "content": "M represents the number of bits taken by the type and N represents how many decimal points are available.",
              "key": "C"
            },
            {
              "content": "M must be divisible by 8 and goes from 2 to 128 bits. N must be between 0 and 16, inclusive.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "794197c0-6a38-49af-a8ce-52c116ee3cee",
          "type": "SingleChoice",
          "content": "Comparison operators like <= , >= are not applicable to which of the following value types?",
          "hint": "noHint",
          "explanation": " '!' , '&&' , '||' , '==' , '!=' work with booleans. Comparison operators like <=, < etc do not work with booleans in solidity .",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "bool",
              "key": "A"
            },
            {
              "content": "uint",
              "key": "B"
            },
            {
              "content": "int",
              "key": "C"
            },
            {
              "content": "address",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "68640698-1c5f-4afb-8164-fe55360e698a",
          "type": "SingleChoice",
          "content": "Regarding comparison of strings in solidity , based on the statements below , which of the following options is correct?\nStatement 1 - Compare with the use of hashes. \nStatement 2 - Check by comparing each character including the length check.\n",
          "hint": "Solidity does not have string manipulation functions.",
          "explanation": "For longer strings it is cost efficient to hash the string and then compare the byte value of the hashes.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement 1 is more gas efficient for longer strings than statement 2.",
              "key": "A"
            },
            {
              "content": "Statement 2 is more gas efficient for longer strings than statement 1.",
              "key": "B"
            },
            {
              "content": "Both statements give almost the same gas cost.",
              "key": "C"
            },
            {
              "content": "There is no gas cost in comparison between strings.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "05680353-3068-486e-ac07-ddc278b06a20",
          "type": "SingleChoice",
          "content": "Which of the following is not a valid address ?",
          "hint": "noHint",
          "explanation": "addresses hold 20 byte hexadecimal values.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9`",
              "key": "A"
            },
            {
              "content": "`0x577a6E294505A797976f218eFd751aB5557E1522`",
              "key": "B"
            },
            {
              "content": "`0xc0ffee254729296a45a3885639AC7E10F9d54979`",
              "key": "C"
            },
            {
              "content": "`0x1011526z3H3fg4445xx556tuoa72288884869aAzl`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "26ca32d3-bc08-41b9-b24a-9cee819a6a34",
          "type": "MultipleChoice",
          "content": "Which of the following is true about address in ethereum and solidity?",
          "hint": "address takes hexadecimal values . what are hexadecimal values?",
          "explanation": "An address is always prefixed with 0x as it is represented in hexadecimal format (base 16 notation). Numbers 0-9 and alphabets a-f are all valid characters in an ethereum address.",
          "answerKeys": [
            "A",
            "B",
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It corresponds to the last 20 bytes of the Keccak-256 hash of the public key.",
              "key": "A"
            },
            {
              "content": "An address is always prefixed with 0x as it is represented in hexadecimal format (base 16 notation).",
              "key": "B"
            },
            {
              "content": "Numbers 0-9 and alphabets a-z are all valid characters in an ethereum address.",
              "key": "C"
            },
            {
              "content": "The case sensitivity is used for checksum validation.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8b5b134a-af35-478c-bd53-8ddfb5471646",
          "type": "MultipleChoice",
          "content": "Which of the following statements is correct about send and transfer functions of the address value type?",
          "hint": "noHint",
          "explanation": "It is possible to query the balance of an address using the property balance and to send Ether (in units of wei) to a payable address using the transfer function. Send is the low-level counterpart of transfer.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Transfer is the low level counterpart of send.",
              "key": "A"
            },
            {
              "content": "Transfer and send are used to send ether (in units of ETH) to a payable address.",
              "key": "B"
            },
            {
              "content": "In order to make a safe ether transaction it is better to use transfer.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "939f30f4-dcfd-4dea-8c48-94e32a0079c5",
          "type": "SingleChoice",
          "content": "Consider the following statements.\nStatement 1 - code is used to get the EVM bytecode as a byte memory, codehash is used to get the Keccak-256 hash of that code (as a bytes32).\nStatement 2 - `keccak256(address.code)` is cheaper than using `address.codehash`.\nWhich of the following options is correct considering the code and codehash methods of the address type.\n",
          "hint": "noHint",
          "explanation": "Use .code to get the EVM bytecode as a bytes memory, which might be empty. Use .codehash get the Keccak-256 hash of that code (as a bytes32). Note that addr.codehash is cheaper than using keccak256(addr.code).",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Both Statement 1 and Statement 2 are correct.",
              "key": "A"
            },
            {
              "content": "Statement 1 is correct but Statement 2 is incorrect.",
              "key": "B"
            },
            {
              "content": "Statement 2 is correct but Statement 1 is incorrect.",
              "key": "C"
            },
            {
              "content": "Neither of the statements is correct.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "caa00c9b-61e5-4224-82fa-9a0bb613d436",
          "type": "MultipleChoice",
          "content": "Which of the following options is correct regarding a user defined value type defined by the syntax `type C is V ;` in solidity.",
          "hint": "noHint",
          "explanation": "A user defined value type is defined using type C is V, where C is the name of the newly introduced type and V has to be a built-in value type (the “underlying type”). The function C.wrap is used to convert from the underlying type to the custom type. Similarly, the function C.unwrap is used to convert from the custom type to the underlying type.The type C does not have any operators or bound member functions. In particular, even the operator == is not defined. Explicit and implicit conversions to and from other types are disallowed.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "V is the name of the newly introduced data type.",
              "key": "A"
            },
            {
              "content": "The type V does not have any operators or bound member functions. In particular, even the operator == is not defined.",
              "key": "B"
            },
            {
              "content": "The function `C.wrap` is used to convert from the underlying type to the custom type. Similarly, the function `C.unwrap` is used to convert from the custom type to the underlying type.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b0134cbb-b413-4e42-8030-7221df128b4e",
          "type": "MultipleChoice",
          "content": "In solidity , contract types are -",
          "hint": "noHint",
          "explanation": "Solidity Contracts are like a class in any other object-oriented programming language.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Similar to classes in object oriented languages.",
              "key": "A"
            },
            {
              "content": "Similar to functions in object oriented languages.",
              "key": "B"
            },
            {
              "content": "Reference types.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "9c4a6edd-ee00-43f2-a097-05fc166e243b",
          "type": "SingleChoice",
          "content": "Which of the following statements are correct regarding variable declaration in solidity?",
          "hint": "noHint",
          "explanation": "A variable name should not match with reserved keywords. Variable names must start with a letter or an underscore (_), and may contain letters from “a to z” or “A to Z” or digits from “0 to 9” and characters also. The name of variables are case sensitive.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "A variable name should not match with reserved keywords.",
              "key": "A"
            },
            {
              "content": "Variable names cannot start with underscore.",
              "key": "B"
            },
            {
              "content": "variables are case insensitive , var123 and VAR123 are same variables.",
              "key": "C"
            },
            {
              "content": "none of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "69254f63-d913-4863-a7b2-8398986ccd09",
          "type": "MultipleChoice",
          "content": "Which of the following is correct about contract types in solidity?",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Contracts support comparison operators.",
              "key": "A"
            },
            {
              "content": "The members of contract types are all the functions of the contract including all state variables.",
              "key": "B"
            },
            {
              "content": "A contract cannot create other contracts using the new keyword.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "270dfe5f-a833-472c-ad07-3ce1942780b0",
          "type": "MultipleChoice",
          "content": "Which among the following is  a valid data storage location for mapping type?",
          "hint": "noHint",
          "explanation": "Mappings can only have a data location of storage.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "mapping-type"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "memory",
              "key": "A"
            },
            {
              "content": "storage",
              "key": "B"
            },
            {
              "content": "calldata",
              "key": "C"
            },
            {
              "content": "staticcall",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "653b974e-d79d-4103-a2ff-57a86506ada3",
          "type": "MultipleChoice",
          "content": "The declaration below in solidity is an example of which type? \n   `function f() public payable returns (bytes4){}`\n",
          "hint": "noHint",
          "explanation": "`function f() public payable returns (bytes4){}` is a fuction declaration.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Contract type",
              "key": "A"
            },
            {
              "content": "Function type",
              "key": "B"
            },
            {
              "content": "Reference type",
              "key": "C"
            },
            {
              "content": "Mapping type",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "fec5256b-0f13-49b3-a01f-dd9c40543497",
          "type": "MultipleChoice",
          "content": "Which access classifier is used with a function type to only access it in the contract it is declared in ?",
          "hint": "private is a subset of internal and external is a subset of public.",
          "explanation": "public - all can access\nexternal - Cannot be accessed internally, only externally\ninternal - only this contract and contracts deriving from it can access\nprivate - can be accessed only from this contract\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "public",
              "key": "A"
            },
            {
              "content": "private",
              "key": "B"
            },
            {
              "content": "internal",
              "key": "C"
            },
            {
              "content": "external",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b6b96712-83df-49b7-8b54-cab1d3630e3d",
          "type": "MultipleChoice",
          "content": "In the context of memory arrays which of the following statements are true?",
          "hint": "noHint",
          "explanation": "Memory arrays with dynamic length can be created using the new operator. As opposed to storage arrays, it is not possible to resize memory arrays (e.g. the .push member functions are not available). The Solidity Smart Contract can use any amount of memory during the execution but once the execution stops, the Memory is completely wiped off for the next execution.",
          "answerKeys": [
            "A",
            "D"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "they can be declared with the syntax , `uint[] memory a = new uint[](size);`",
              "key": "A"
            },
            {
              "content": "to add an element to the array , `push()` function is used.",
              "key": "B"
            },
            {
              "content": "You can acess values in a memory array after execution of the smart contract.",
              "key": "C"
            },
            {
              "content": "They cost less gas compared to storage arrays.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "bb55a93a-05b2-4ea5-83b4-bd307cdf6c51",
          "type": "MultipleChoice",
          "content": "\"What will be the value of the following syntax executed in solidity?\n   `255 + (true ? 1 : 0)`\n",
          "hint": "The ternary operator is used in expressions of the form <expression> ? <trueExpression> : <falseExpression>. It evaluates one of the latter two given expressions depending upon the result of the evaluation of the main <expression>. If <expression> evaluates to true, then <trueExpression> will be evaluated, otherwise <falseExpression> is evaluated.",
          "explanation": "The result type is determined from the types of the two operands in the ternary operator, converting to their mobile type first if required. As a consequence, 255 + (true ? 1 : 0) will revert due to arithmetic overflow. The reason is that (true ? 1 : 0) is of uint8 type, which forces the addition to be performed in uint8 as well, and 256 exceeds the range allowed for this type.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "255",
              "key": "A"
            },
            {
              "content": "256",
              "key": "B"
            },
            {
              "content": "0",
              "key": "C"
            },
            {
              "content": "the above statement will revert.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "a2bc4929-787b-4184-959c-480659493663",
          "type": "SingleChoice",
          "content": "In the following code snippet which line will result in an error-\n  ```\n  // SPDX-License-Identifier: MIT\n  pragma solidity ^0.8.10;\n  contract C {\n\n      //line 1\n      uint public x = 1;\n\n      // line 2\n      function addToX(uint y) public pure returns (uint) {\n          return x + y;\n      }\n\n      // line 3\n      function add(uint i, uint j) public pure returns (uint) {\n          return i + j;\n      }\n  }\n```\n",
          "hint": "Check whether the function declaration is correct.",
          "explanation": "Pure declares that no state variable will be changed or read in a function. view tells us that by running the function, no data will be saved/changed. Here in line 2 a pure function is trying to read the data from a state variable. The declaration should have a view instead of pure.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Line 1",
              "key": "A"
            },
            {
              "content": "Line 2",
              "key": "B"
            },
            {
              "content": "Line 3",
              "key": "C"
            },
            {
              "content": "The code snippet will not give any error",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "487d03f1-4e30-447e-86e3-ec74ef4984bc",
          "type": "MultipleChoice",
          "content": "You have a list of teams and their respective scores in a tournament. You are trying to work up some logic in a contract in solidity to efficiently retrieve the scores . Which of the following data types should you use to keep track of the scores?",
          "hint": "Which data type can be used to store a grouping of data and has greater efficiency when you want to fetch some unique value.",
          "explanation": "A mapping is a table of keys and values (each with a pre-defined type). Fetching a piece of data from a mapping is far more efficient than fetching the same data from an array. To fetch data from an array requires iterating over the whole array until you find the element you're looking for.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "reference-types",
            "mapping-type"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "enum",
              "key": "A"
            },
            {
              "content": "Multi dimensional arrays",
              "key": "B"
            },
            {
              "content": "strings",
              "key": "C"
            },
            {
              "content": "mappings",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "4e60aee2-0a82-44f1-a173-17cf88872017",
          "type": "SingleChoice",
          "content": "On execution of the following code what will be the value of balance?\n```solidity\n   uint8 balance = 255;\n   balance++;\n```\n",
          "hint": "Think of the range of values uint 8 can have .",
          "explanation": "If you execute the code above the \"balance\" will be 0. This is a simple example of overflow. If you add 1 to binary 11111111, it resets back to 00000000. In Solidity 0.8, the compiler will automatically take care of checking for overflows and underflows.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "256",
              "key": "A"
            },
            {
              "content": "0",
              "key": "B"
            },
            {
              "content": "255",
              "key": "C"
            },
            {
              "content": "-255",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d9e1ab62-0af2-457b-b770-d21dc954b76d",
          "type": "MultipleChoice",
          "content": "Which of the following statements are correct in the context of storage and memory data locations ?",
          "hint": "Think of how storage and memory affects the gas cost and how the code can be optimized.",
          "explanation": "Every transaction on Ethereum Virtual Machine costs us some amount of Gas. The lower the Gas consumption the better is your Solidity code. The Gas consumption of Memory is not very significant as compared to the gas consumption of Storage. Therefore, it is always better to use Memory for intermediate calculations and store the final result in Storage.",
          "answerKeys": [
            "A",
            "B",
            "C"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Hard",
          "choices": [
            {
              "content": "Memory in solidity is a temporary storage.",
              "key": "A"
            },
            {
              "content": "Storage is persistent and holds data between function calls.",
              "key": "B"
            },
            {
              "content": "State variables and Local Variables of structs, array are always stored in storage by default. Function arguments are in memory.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "94432d54-9f7c-4b53-be49-314a4aa94d5a",
          "type": "SingleChoice",
          "content": "Look at the code snippet below,\n```solidity\n           pragma solidity ^0.5.0;\n           contract SolidityTest {\n             uint storedData;     \n             constructor() public {\n                 storedData = 10;   \n             }\n           }\n```\nWhat type of variable is storedData declared in the SolidityTest contract?\"\n",
          "hint": "noHint",
          "explanation": "State Variables , Variables whose values are permanently stored in a contract storage.\nLocal Variables , Variables whose values are present till function is executing.\nGlobal Variables , Special variables which exist in the global namespace used to get information about the blockchain.\n",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "reference-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "State Variables",
              "key": "A"
            },
            {
              "content": "Local Variables",
              "key": "B"
            },
            {
              "content": "global Variables",
              "key": "C"
            },
            {
              "content": "None of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6b728a07-8caf-47d0-b62d-2e97c5b2ff32",
          "type": "MultipeChoice",
          "content": "Which of the following is a valid enum declaration in solidity?",
          "hint": "there must be atleast one option in enum.",
          "explanation": "you cant use numbers (positive or negative) or boolean (true or false in lowercase) as members for an enum. However, True and False (Capitalized) are accepted.",
          "answerKeys": [
            "B",
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "`enum integers {  1 , 2 , 3 , 4 }`",
              "key": "A"
            },
            {
              "content": "`enum values { one , two , three }`",
              "key": "B"
            },
            {
              "content": "`enum myEnums { }`",
              "key": "C"
            },
            {
              "content": "`enum booleans { True , False }`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "3648ad26-bb00-458d-afaa-0762e70a5dbe",
          "type": "SingleChoice",
          "content": "Consider the following code snippet ,\n```solidity\n              pragma solidity ^0.5.0;\n              contractC {\n                function foo(uint a) pure public returns (uint){\n                  return a << 2;\n                }\n              }\n```\nWhat will be the output when a uint value 3 is passed in the function foo of the contract C?\"\n",
          "hint": "The Left Shift operator (<<) moves all the bits in its first operand to the left by the number of places specified in the second operand.",
          "explanation": "x << y is equivalent to the mathematical expression x * 2**y.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Hard",
          "choices": [
            {
              "content": "0",
              "key": "A"
            },
            {
              "content": "1",
              "key": "B"
            },
            {
              "content": "8",
              "key": "C"
            },
            {
              "content": "12",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "203d97e1-7194-4373-b943-d89d06e35126",
          "type": "MultipleChoice",
          "content": "Which of the following are valid literals for solidity data types?",
          "hint": "noHint",
          "explanation": "2.5e1 is an integer literal , \"foo\" \"bar\" is equivalent to “foobar” which is a string literal and hex\"001122FF\" is an example of  hexadecimal literal which are prefixed with the keyword hex.",
          "answerKeys": [
            "A",
            "B",
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`2.5e1`",
              "key": "A"
            },
            {
              "content": " `'foo' 'bar'` ",
              "key": "B"
            },
            {
              "content": "`hex\"001122FF\"`",
              "key": "C"
            },
            {
              "content": "None of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2bb12876-aee8-4cbd-8662-e193bb5503aa",
          "type": "SingleChoice",
          "content": "Variable packing is one way solidity optimizes gas costs in storage state variables . Consider the following two examples of variable declarations.\nExample 1 -\n  ```solidity\n         uint128 a;\n         uint256 b;\n         uint128 c;\n  ```\nExample 2 -\n  ```solidity\n         uint128 a;\n         uint128 c;\n         uint256 b;\n  ```\nWhich of the following statements are correct regarding variable packing in the above examples.\"\n",
          "hint": "Solidity contracts have contiguous 32 byte (256 bit) slots used for storage.",
          "explanation": "In example 1 the variables are not packed. If b was packed with a, it would exceed the 32 byte limit so it is instead placed in a new storage slot. The same thing happens with c and b. In example 2 the  variables are packed. Because packing c with a does not exceed the 32 byte limit, they are stored in the same slot.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Hard",
          "choices": [
            {
              "content": "Variables in both examples 1 and 2 are packed.",
              "key": "A"
            },
            {
              "content": "Variables in example 1 are packed but not in example 2.",
              "key": "B"
            },
            {
              "content": "Variables in example 2 are packed but not in example 1.",
              "key": "C"
            },
            {
              "content": "Variables in neither examples 1 and 2 are packed.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "47e3f7e4-b2e6-4c0f-acd7-e7c960203710",
          "type": "SingleChoice",
          "content": "Consider the following code snippet ,\n  ```solidity\n  // SPDX-License-Identifier: GPL-3.0\n  pragma solidity ^0.8.8;\n  contract test {\n    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\n\n    function foo() public pure returns (ActionChoices) {\n        return type(ActionChoices).max;\n    }\n  }\n  ```\nWhat will be the output when the function foo is called?\n",
          "hint": ".max is used to get the largest value of the given enum.",
          "explanation": "Under the hood, enums are integers, not strings. Solidity will automatically handle converting enums to ints.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "value-types"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "`0:uint8: 3`",
              "key": "A"
            },
            {
              "content": "`0:uint8: 0`",
              "key": "B"
            },
            {
              "content": "`0:string: “SitStill”`",
              "key": "C"
            },
            {
              "content": "`0:string: “GoLeft”`",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "a150cd2d-1888-4210-8bee-9411eb25e3bf",
          "title": "Introduction to Solidity Data types",
          "shortTitle": "Data Types Intro - 1",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=N1Jeeei_wtw",
          "subTopics": [
            "value-types",
            "reference-types",
            "mapping-type"
          ],
          "details": "In this video we're looking at the data types available in Solidity.\nThis video explains about the use of -\n* Value Types - Integers , Booleans etc \n* Reference Types - Structs , Arrays .\n* Mapping Type - Mapping.\n"
        },
        {
          "uuid": "ee869939-2186-42bb-a8a0-de3fd366862e",
          "title": "Solidity Tutorial - Variable Types",
          "shortTitle": "Variable Types",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=TNZLonjrLYE",
          "subTopics": [
            "value-types",
            "reference-types",
            "mapping-type"
          ],
          "details": "In this video we are looking at an overview of all the variable types in Solidity and how to declare them.\nThis video explains about all the variables that can be declared using types : \n* uint\n* bytes32\n* string\n* bytes\n* arrays\n* mappings\n* structs\n* enums\n"
        },
        {
          "uuid": "747a3dca-1ba1-421e-adc0-b75f32b5ae99",
          "title": "Master Solidity Variables, Data Types, and Structs Master Solidity",
          "shortTitle": "Data Types Intro - 2",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=HxlxNwgoN8w",
          "subTopics": [
            "value-types",
            "reference-types",
            "mapping-type"
          ],
          "details": "In this video we are looking at different solidity types and variables.\nThis video explains all the different variables that can be declared (state variables and Local Variables).\n"
        },
        {
          "uuid": "cb6cf918-b9ac-4c65-8506-f5a0bb3564bf",
          "title": "Solidity Tutorial, Arrays (Declare, Read, Update, Delete).",
          "shortTitle": "Arrays",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=MPBOnChpi0c&list=PLbbtODcOYIoE0D6fschNU4rqtGFRpk3ea&index=14",
          "subTopics": [
            "reference-types"
          ],
          "details": "This video explains how to - \n- Declare arrays\n- Add elements\n- Read elements\n- Update elements\n- Delete elements\n- Iterate through elements  \n\nThis video further explores the differences between-\n- Fixed-size and Dynamic size\n- Storage and memory arrays  \n\nand it also covers how to accept arrays argument in Solidity functions and return arrays from solidity functions.\n"
        },
        {
          "uuid": "f936c72d-9d71-4c05-bf38-3b827b0d95f5",
          "title": "Solidity Tutorial: Mappings (simple mappings, nested mappings, array in mappings...)",
          "shortTitle": "Mappings",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=U-wWqTq1zoQ&list=PLbbtODcOYIoE0D6fschNU4rqtGFRpk3ea&index=15",
          "subTopics": [
            "mapping-type"
          ],
          "details": "This video explains how to declare and manipulate mappings in Solidity. It also covers simple mappings but also advanced mappings like nested mappings and array inside mappings. \n"
        },
        {
          "uuid": "7834704f-0749-4457-bd5b-7531ea34ff99",
          "title": "Solidity Tutorial, Arrays (Declare, Read, Update, Delete).",
          "shortTitle": "Arrays",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=UkdU0cuAp9U&list=PLbbtODcOYIoE0D6fschNU4rqtGFRpk3ea&index=16",
          "subTopics": [
            "reference-types"
          ],
          "details": "Solidity Structs allow you to represent structured data. This video explains how to declare, instantiate (create), read, update and delete structs in Solidity.\nIt will also show some more advanced struct manipulation like how to declare an array of structs and how to declare a mapping of structs.\n"
        },
        {
          "uuid": "83565016-2bf9-4b07-a0a3-938cbe86749f",
          "title": "Solidity Tutorial, Arrays (Declare, Read, Update, Delete).",
          "shortTitle": "Arrays",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=5ED_6FasZ68&list=PLbbtODcOYIoE0D6fschNU4rqtGFRpk3ea&index=17",
          "subTopics": [
            "reference-types"
          ],
          "details": "Solidity Enums allow you to represent optional data.\nThis video covers how to declare enums, use enums, accept enums as argument in solidity functions.\n"
        }
      ],
      "summaries": [
        {
          "title": "Value Types",
          "shortTitle": "Value Types",
          "key": "value-types",
          "details": "The following types are called value types because variables of these types will always be passed by value, i.e. unlike reference types they are always copied when used in function arguments or asssignments.\n- Booleans\n  * They are declared using the keyword `bool`.\n  * The possible values are constants true and false.\n\n- Integers\n  * They are declared using keywords `int` , `uint` for signed and unsigned integers.\n  * Keywords `uint8` to `uint256` in steps of 8 are used to store unsigned integers with varying sizes in bits. Similarly , `int8` to `int256` for signed integers.\n  * For Example, uint32 is a 32 bit unsigned integer having range from 0 to $2^{32}-1$ whearas int32 is a 32 bit signed integer having range from $-2^{31}$ to $2^{31}-1$.\n  * For an integer type X, you can use `type(X).min` and `type(X).max` to access the minimum and maximum value representable by the type.\n  * Integers allow the use of comparision (<=, <, ==, !=, >=, >) , bit (&, |, ^ , ~) , arithmetic (+, -, *, /, %, ** ) and shift (<< , >>) operators.\n  * `x << y` is equivalent to the mathematical expression $x * 2^y$. `x >> y` is equivalent to the mathematical expression $x / 2^y$.\n\n- Fixed Point Numbers\n  * They are declared using keywords `fixed` , `ufixed`.\n  * Keywords ufixedMxN and fixedMxN, where M represents the number of bits taken by the type and N represents how many decimal points are available. M must be divisible by 8 and goes from 8 to 256 bits. N must be between 0 and 80, inclusive.\n  * Fixed point numbers are not fully supported by Solidity yet. They can be declared, but cannot be assigned to or from.\n\n- Addresses\n  * They can be declared using keywords `address` and `address payable`.\n  * address type hold a 20 byte value (size of an Ethereum address).\n  * address payable is same as address, but with the additional members transfer and send.\n  * address payable is an address you can send Ether to.\n  * Implicit conversions from `address payable` to `address` are allowed, whereas conversions from address to address payable must be explicit via` payable(<address>)`.\n  * It is possible to query the balance of an address using the property `balance` and to send Ether (in units of wei) to a payable address using the `transfer` function.\n  * `send` is the low-level counterpart of `transfer`.\n\n- Contract types\n  * Every contract defines its own type.\n  * You can implicitly convert contracts to contracts they inherit from.\n\n- Enums\n  * Enums are used create a user-defined type in Solidity.\n  * Enums restrict the variable with one of a few predefined values, these values of the enumerated list are called enums.\n  * Syntax to declare an enum is `enum <enumerator_name> {element 1, element 2,....,element n}`\n  * Enums require at least one member, and its default value when declared is the first member.\n  * Enums cannot have more than 256 members.\n  * The options in an enum are represented by subsequent unsigned integer values starting from 0.\n  * The default value of an enum when declared is its first member. \n\n- User Defined Value Types\n  * A user defined value type is defined using `type C is V`, where C is the name of the newly introduced type and V has to be a built-in value type (the “underlying type”). \n  * The function C.wrap is used to convert from the underlying type to the custom type.\n  * The function C.unwrap is used to convert from the custom type to the underlying type.\n  * The type C does not have any operators or bound member functions. \n\n- Function Types \n  * Function types are the types of functions.\n  * Function types are declared as `function (<parameter types>) {internal|external} [pure|view|payable] [returns (<return types>)]`.\n  * Internal functions can only be called inside the current contract.\n  * External functions consist of an address and a function signature and they can be passed via and returned from external function calls.\n  * View functions are read only function and do not modify the state of the block chain (view data on the block chain).\n  * Pure functions do not read and do not modify state of the block chain.   \n"
        },
        {
          "title": "Reference Types",
          "shortTitle": "Reference Types",
          "key": "reference-types",
          "details": "In Solidity, unlike value types that stores it own data, reference types do not store the data directly to the variable, they contain a pointer to another memory location that holds the real data.\nValues of reference type can be modified through multiple different names in contrast to value types where an independent copy is maintained whenever a variable of value type is used.\nWhile using a reference type a data location(where the variable is stored) has to be provided explicitly. Currently, reference types comprise of structs, arrays and mappings.\n \n - arrays\n   * Arrays can have a compile-time fixed size, or they can have a dynamic size.\n   * `type arrayName [ arraySize ];` declares an array of fixed size in Solidity.\n   * `type[] arrayName;` declares an array of dynamic size in solidity.\n   * Memory arrays with dynamic length can be created using the new operator eg `uint[] memory a = new uint[](7);` . As opposed to storage arrays, it is not possible to resize memory arrays.\n   * Arrays inside a function can only be declared with memory data location and are always of fixed size, so `uint[] memory newArray = new uint[](10);` is a valid array declaration inside a function.\n\n - bytes and strings as arrays\n   * Variables of type bytes and string are special arrays.\n   * The bytes type is similar to bytes1[], but it is packed tightly in calldata and memory. \n   * string is equal to bytes but does not allow length or index access.\n   * Solidity does not have string manipulation functions, but there are third-party string libraries.\n   * You can compare two strings by their keccak256-hash using `keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))` and concatenate two strings using `string.concat(s1, s2)`.\n\n - structs\n   * Structs in Solidity are used to create more complicated data types that have multiple properties.\n   * They are useful for grouping together related data.\n   * Syntax to declare a struct is -\n     ```solidity\n       struct <structure_name> {  \n         <data type> variable_1;  \n         <data type> variable_2; \n       }\n     ```\n   * For accessing any element of the structure the dot operator is used.\n   * The below example shows how to initialize a struct in solidity.\n       ```solidity\n         pragma solidity 0.8.15;\n         contract test {\n           // Declaring a structure\n           struct Course {\n               string title;\n               string subTopic;\n               uint id;\n           }\n           // Declaring a structure object\n           Course course1;\n         \n           // declaring a struct and assigning values to the fields\n           Course course2\n             = Course(\"Solidity Course\",\n                     \"No topic\",1);\n           \n           function setSubTopicopic() public{\n               course2.subTopic=\"Reference Types\";\n           }\n           function viewSubTopic() public view returns(string memory){\n               return course2.subTopic;\n           }\n         }\n       ```  \n   * In the above example the dot operator can be used inside the setTopic function to update the subtopic of Course struct.\n"
        },
        {
          "title": "Data location",
          "shortTitle": "Data location",
          "key": "data-location",
          "details": "* There are three data locations: memory, storage and calldata.\n* When placed in storage, a variable is written on the blockchain. Every contract has its own storage, so these variables are persistent. \n* If we want to store variables and later update or make changes to its state, we have to declare it using storage. We can update the variables declared with memory data location aswell inside a function but the data can be used only within the function and any modification will not persist outside the function execution. \n* State variables and Local Variables of structs, array are always stored in storage by default.\n* Variables stored in memory are declared inside a function. They are temporary and their lifetime is dependent on the runtime of the function they correspond to.\n* Calldata is also a temporary data location in Solidity. \n* Calldata acts like memory, in terms of its dependence on the functions execution however it is only available for external function call parameters.\n* When we call a function which takes an array with memory keword, the array is copied. This leads to more gas fee. However with calldata, the array is not copied, but also the data cannot be modified when declared with keyword calldata.     \n* Variables declared with memory data location are mutable (i.e. they can be overwritten and changed) whearas variables declared with calldata location are immutable and cannot be overwritten or changed.\n* The below example explains the differences between memory and calldata.\n  ```solidity\n    pragma solidity 0.8.15;\n\n    contract Test {\n        function memoryTest(string memory _exampleString) public pure returns (string memory) {\n            _exampleString = \"example\";  // You can modify memory\n            string memory newString = _exampleString;  // You can use memory within a function's logic\n            return newString;  // You can return memory\n        }\n        function calldataTest(string calldata _exampleString) external pure returns (string memory) {\n            // cannot modify _exampleString\n            return _exampleString; // but can return it\n        }\n    }\n  ```\n* Storage is the most expensive data location one can use. Then there is memory, with the cheapest being calldata.\n"
        },
        {
          "title": "Mapping Type",
          "shortTitle": "Mapping Type",
          "key": "mapping-type",
          "details": "Mapping in Solidity acts like a hash table or a dictionary. These are used to store the data in the form of key-value pairs.\n- Mapping types use the syntax `mapping(KeyType => ValueType)` and variables of mapping type are declared using the syntax `mapping(KeyType => ValueType) VariableName`.\n- The KeyType can be any built-in value type, bytes, string, or any contract or enum type. Other user-defined or complex types, such as mappings, structs or array types are not allowed.\n- ValueType can be any type, including mappings, arrays and structs.\n- Mappings can only have a data location of storage.\n"
        }
      ]
    },
    {
      "title": "Units and variables",
      "key": "units-variables",
      "details": "This chapter covers the units used in solidity and also discusses various functions available globally in Solidity and their properties.",
      "order": 2,
      "explanations": [
        {
          "key": "units",
          "shortTitle": "Units",
          "details": "### Ether Units\n  While using Ethereum, we may encounter different units, such as Wei and Gwei. In Solidity, we can use wei, gwei or ether to specify a subdenomination of Ether. \n  Wei is the smallest unit of measurement. One Wei is worth 0.000000000000000001 Ether (or $10^{18}$). Because it cannot deal with decimal numbers, the EVM (Ethereum Virtual Machine) employs Wei as its base unit. Gwei, another common unit, is 1000000000 Wei, or 0.000000001 (or $10^9$) Ether. \n  \n  Following are unit conversions on basis of 1 Wei\n  - `1 wei = 1;`\n  - `1 gwei = 1e9;`\n  - `1 ether = 1e18;`\n    \n### Time Units\n  After literal numbers, units of time can be specified by adding suffixes like seconds, minutes, hours, days, and weeks where seconds are the base unit. We can use seconds, minutes, hours, days and weeks as suffix to denote time. Lowest unit of time is `seconds`.  \n  \n  Below are some time unit examples from solidity. \n  - `1 seconds = 1;`\n  - `1 minutes = 60 seconds;`\n  - `1 hours = 60 minutes;`\n  - `1 day = 24 hours;`\n  - `1 week = 7 days;`  \n\n  On calling function `func` below, the value of `block.timestamp` returns 1661554329 seconds however the returned value will be 143558295494400 seconds because `block.timestamp` gets multiplied with 24*60*60 due to the `days` time denomination.\n\n  ```solidity\n    contract C\n    {\n      function func() public view returns(uint){\n          return block.timestamp * 1 days;\n      }\n    }\n  ```\n  After version 0.5.0, solidity no longer uses the suffix \"years\" for the reasons of leap units(i.e. leap year).\n",
          "title": "Units"
        },
        {
          "title": "Globally available Variables",
          "shortTitle": "Global Variables",
          "key": "global-variables",
          "details": "A Variable is basically a placeholder for the data which can be manipulated at runtime. Variables allow users to retrieve and change the stored information. There are special variables and functions which always exist in the global namespace and are mainly used to provide information about the blockchain or are general-use utility functions.\n\nThese are of various types having specific properties.\n  - Block and Transaction properties.\n  - ABI Encoding and Decoding functions.\n  - Members of bytes and string.\n  - Error handling methods.\n  - Mathematical and Cryptographic functions.\n  - Members of address type.\n  - Contract related.\n  - Type Information.\n"
        },
        {
          "title": "Block and Transaction properties",
          "shortTitle": "Block Properties",
          "key": "block-transaction",
          "details": "A key idea in Ethereum is the concept of blocks. Blocks serve as transactional containers. Multiple transactions are contained in a block. The number of transactions in each block varies depending on the gas limit and block size. A blockchain is created by chaining the blocks together. Each block has a parent block, and the header of each block contains the parent block's hash. Only the first block, also referred to as the genesis block, lacks a parent.\n\nBelow are block and transaction properties with their functionalities \n  - `blockhash(uint blockNumber) returns (bytes32)`: Gives hash of the given block and will only work for the 256 most recent block due to the reason of scalability.\n  - `block.basefee (uint)`: current blocks base fee.\n  - `block.chainid (uint)`: current chain id.\n  - `block.coinbase (address payable)`: current block miners address.\n  - `block.difficulty (uint)`: current block difficulty.\n  - `block.gaslimit (uint)`: current block gaslimit.\n  - `block.number (uint)`: current block number.\n  - `block.timestamp (uint)`: current block timestamp as seconds since unix epoch.\n  - `gasleft() returns (uint256)`: remaining gas.\n  - `msg.data (bytes calldata)`: complete calldata.\n  - `msg.sender (address)`: sender of the message (current call).\n  - `msg.sig (bytes4)`: first four bytes of the calldata (i.e. function identifier).\n  - `msg.value (uint)`: number of wei sent with the message.\n  - `tx.gasprice (uint)`: gas price of the transaction.\n  - `tx.origin (address)`: sender of the transaction (full call chain).\n\nThe code snippet below demonstrates the use of some of the Block and transaction properties.\n  ```solidity\n    pragma solidity ^0.8.0;\n\n    contract Block{\n        ///////// block functions //////////////\n\n        function basefee()public view returns(uint){\n            return block.basefee;\n        }//output: \"0\": \"uint256: 1\"\n\n        function chainid()public view returns(uint){\n            return block.chainid;\n        }//output: \"0\": \"uint256: 1\"\n\n        function coinbase()public view returns(address payable){\n            return block.coinbase;\n        }//output: \"0\": \"address: 0x8945A...\"\n\n        // try this with pragma solidity ^0.6.0;\n        // function gaselimit()public view returns(uint){\n        //     return block.gaselimit;\n        // }//output: \"0\": \"uint256: 1\"\n\n        function number()public view returns(uint){\n            return block.number;\n        }//output: \"0\": \"uint256: 2\"\n\n        function blockhash_()public view returns(bytes32){\n            return blockhash(number());\n        }//output: \"0\": \"bytes32: 0x0000000000000000000000000000000000000000000000000000000000000000\"\n\n        function timestamp()public view returns(uint){\n            return block.timestamp;\n        }//output: \"0\": \"uint256: 1667312686\"\n\n        function gasleft_()public view returns(uint256){\n            return gasleft();\n        }//output: \"0\": \"uint256: 2978818\"\n\n        /////////// msg functions //////////////\n\n        function data()public pure returns(bytes calldata){\n            return msg.data;\n        }//output: \"0\": \"bytes: 0x73d4a13a\"\n\n        function sender()public view returns(address){\n            return msg.sender;\n        }//output: \"0\": \"address: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4\"\n\n        function sig()public pure returns(bytes4){\n            return msg.sig;\n        }//output: \"0\": \"bytes4: 0x00a7029b\"\n\n        function value()internal view returns(uint){\n            return msg.value;\n        }//output: \"0\": \"uint256: 2978818\"\n\n        ////////// tx functions ////////////\n\n        function gasprice()public view returns(uint){\n            return tx.gasprice;\n        }//output: \"0\": \"uint256: 1\"\n\n        function origin()public view returns(address){\n            return tx.origin;\n        }//output: \"0\": \"address: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4\"\n\n    }\n\n  ```\nThe values of all members of msg can change for every external function call. In solidity `block.timestamp` and `blockhash` are sources of randomness are not secure. Timestamp and the blockhash can be influenced by the miners.\n"
        },
        {
          "title": "ABI Encoding and Decoding functions.",
          "shortTitle": "Encoding/Decoding",
          "key": "encoding-decoding",
          "details": "In the context of computer science, an ABI (Application Binary Interface) is an interface between two programme modules, most commonly between operating systems and user programmes. ABI, like API, defines the methods and structures used to interact with the binary contract at a lower level. The ABI instructs the function caller to encode the necessary information, such as function signatures and variable declarations, in a format that the EVM can understand in order to call that function in bytecode; this is known as ABI encoding.\n\nTo send data to the contract, we need to send it in a way that the contract can read it. That is, they need to be encoded. Solidity has  global variable i.e, abi that has an encode and decode method, so we can use it to encode the parameters of any function. \n\nThe encode/dicode method on the `abi` global variable in Solidity lets us easily encode/decode the parameters of any function.\n\nABI encoding is mostly automated, handled by compilers such as REMIX or wallets that interact with the blockchain. JSON is used to represent contract ABI. There are specific instructions for encoding and decoding a contract ABI.\n\n- `abi.encode(...) returns (bytes memory)`: ABI-encodes the given arguments.\n- `abi.decode(bytes memory encodedData, (...)) returns (...)`: ABI-decodes the given data, while the types are given in parentheses as second argument. \n\nExample: `(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))`\n\n- The example below demonstrates encoding and decoding.\n  ```solidity\n  contract Encode {\n    function encode(string memory _string1, uint _uint) public pure returns (bytes memory) {\n            return (abi.encode(_string1, _uint));\n        }\n    function decode(bytes memory data) public pure returns (string memory _str1, uint _number) {\n            (_str1, _number) = abi.decode(data, (string, uint));            \n        }\n    }\n  ```\n  On calling function `encode` with values (Hi , 5), returns bytes array \n  `0:bytes: 0x0000000000000000000000000000000000000000000000000000000000\n  0000400000000000000000000000000000000000000000000000000000000000000005\n  0000000000000000000000000000000000000000000000000000000000000003486920\n  0000000000000000000000000000000000000000000000000000000000`  \n  The encoded data can be decoded by calling function `decode` with the above bytes array.\n  The returned values are \n  ```\n    0:string: _str1 Hi\n    1:uint256: _number 5\n  ```\n- `abi.encodePacked(...) returns (bytes memory)`: Performs packed encoding of the given arguments.\n- `abi.encodeWithSelector(bytes4 selector, ...) returns (bytes memory)`: ABI-encodes the given arguments starting from the second and prepends the given four-byte selector.\n- `abi.encodeWithSignature(string memory signature, ...) returns (bytes memory)`: Equivalent to `abi.encodeWithSelector(bytes4(keccak256(bytes(signature))), ...)`.\n- `abi.encodeCall(function functionPointer, (...)) returns (bytes memory)`: ABI-encodes a call to functionPointer with the arguments found in the tuple. Performs a full type-check, ensuring the types match the function signature. Result `equals abi.encodeWithSelector(functionPointer.selector, (...))`abi.decode. `abi.encodeCall` not works with interfaces. \n\n```solidity\n  pragma solidity ^0.8.0;\n\n  interface IERC20 {\n      function transfer(address, uint) external;\n  }\n\n  contract ABI{\n      function packedEncoding(string memory str)public pure returns(bytes memory){\n          return abi.encodePacked(str);\n      }\n      // input: \"string str\": \"dodao\"\n      // output: \"0\": \"bytes: 0x646f64616f\"\n\n      function encodeWithSelector(bytes4 selector)public pure returns(bytes memory){\n          return abi.encodeWithSelector(selector);\n      }\n      // input: \"bytes4 selector\": \"0x00a7029b\"\n      // output: \"0\": \"bytes: 0x00a7029b\"\n\n      function encodeWithSignature(string memory sign)public pure returns(bytes memory){\n          return abi.encodeWithSignature(sign);\n      }\n      // input: \"string sign\": \"dodao\"\n      // output: \"0\":bytes: 0x8b1babe1\"\n\n      function encodeCall(address to, uint amount) external pure returns (bytes memory) {\n          // Typo and type errors will not compile\n          return abi.encodeCall(IERC20.transfer, (to, amount));\n      }\n      // input: \"address to\": \"0x9fA9594f233f14ac5B6Da660C3943b5925dB76bf\", \"uint256 amount\": \"10\"\n      // output: \"0\": \"bytes: 0xa9059cbb0000000000000000000000009fa9594f233f14ac5b6da660c3943b5925db76bf000000000000000000000000000000000000000000000000000000000000000a\"\n  }\n\n```\n"
        },
        {
          "title": "Mathematical and Cryptographic Functions",
          "shortTitle": "Math Functions",
          "key": "math-functions",
          "details": "### Mathematical Functions\n\nSolidity provide some inbuilt mahematical functions.\n\n- `addmod(uint x, uint y, uint k) returns (uint)`\n  This functions will compute the expression `(x + y) % k`. The addition is performed with arbitrary precision and does not wrap around at $2^{256}$.\n  \n  The code snippet below shows the use of the addmod functions.\n    ```solidity\n    contract C {\n      function foo() public pure returns(uint){\n          return addmod(1,4,3);\n      }\n    }\n    ``` \n  The function `foo` will return the modulous of `(1 + 4)` with 3 which is 2.\n\n- `mulmod(uint x, uint y, uint k) returns (uint)`\n  This function will compute the expression `(x * y) % k`. The multiplication is performed with arbitrary precision and does not wrap around at $2^{256}$.\n  \n  The code snippet below shows the use of the mulmod functions.\n    ```solidity\n    contract C {\n      function bar() public pure returns(uint){\n          return mulmod(5,7,3);\n      }\n    }\n    ```\n    The function `bar` will return the modulous of `(5 * 7)` with 3 which is 2.\n\n### Cryptographic Functions\n\n- `keccak256(bytes memory) returns (bytes32)`\n  keccak256 function will compute and return the Keccak-256 hash of the input. Keccak-256 is part of Solidity (SHA-3 Family). It computes the hash of an input to a fixed-length output, yielding a singular 32-byte hash from any number of inputs. It ca be used to create a deterministic, one-of-a-kind ID from a set of data\n  \n  This cryptographic hash function can only be used in one direction and cannot be reversed. It create cryptographic signature with a small size (by signing the hash instead of a larger input)\n\n- `sha256(bytes memory) returns (bytes32)`\n  This function will compute and return the SHA-256 hash of the input. It is weaker than Keccak-256.\n\n  ```solidity\n    pragma solidity ^0.5.12;\n\n    contract Hash\n    {\n      // Function to generate the hash value\n      function keccak256Hashing(string memory str)public pure returns (uint){\n        return uint(keccak256(abi.encodePacked(str)));\n      }\n        //input: \"string str\": \"dodao\"\n        //output: \"0\": \"uint256: 62920377089785550187964950488199234079585613826859085810147954743834678498217\"\n        \n        function sha256Hashing(bytes memory str)public pure returns(bytes32){\n            return sha256(str);\n        }\n        //input: \"bytes str\": \"0x00a7029b\"\n        //output: \"0\": \"bytes32: 0xdc7c72d57fc518d68eb821c27ca812a3b41a0a38ac1c0a38c5a1fca8259d67ac\"\n    }\n  ```\n"
        },
        {
          "title": "Members of bytes and string",
          "shortTitle": "bytes/string props",
          "key": "bytes-strings",
          "details": "### Strings\n\n  Strings are a reference type of data type in Solidity that stores the location of the data rather than directly storing the data into the variable. They are dynamic arrays that can hold a variety of characters such as numbers, special characters, spaces, and alphabets. Strings in Solidity use UTF-8 encoding to store data. Both Double quote(\" \") and Single quote(' ') can be used to represent strings in solidity, just like JavaScript.\n  \n  - `string.concat(...) returns (string memory)`: Concatenates variable number of string arguments to one string array.\n\n### Bytes\n  Bytes are 8-bit signed integers. Everything in memory is stored in bits that have binary values of 0 and 1. Solidity also includes a byte data type for storing data in binary format. In most programming languages, bytes are represented by a single data type. However, Solidity supports multiple byte types. It provides data types ranging from bytes1 to bytes32 inclusive, to represent different byte lengths as needed. Fixed sized byte arrays are value types that implement these.\n\n  - `bytes.concat(...) returns (bytes memory)`: \n    Concatenates variable number of bytes and bytes1, …, bytes32 arguments to one byte array.\n\n  The Contract C below demonstrates the use of `bytes.concat` and `string.concat` to concatenate two strings a and b.\n  ```solidity\n  contract C\n  {\n    function testStringConcat(string memory a,string memory b) public pure returns (string memory) {\n          return string.concat(a , b);\n      }\n\n      function testByteConcat(string memory a,string memory b) public pure returns (string memory){\n          return string(bytes.concat(bytes(a), \" \", bytes(b)));\n      } \n  }\n  ```\n"
        },
        {
          "title": "Error Handling Functions",
          "shortTitle": "Error Functions",
          "key": "error-handling",
          "details": "Solidity has a plethora of error-handling functions. Errors can occur during compile or runtime. Solidity is compiled to byte code, and a syntax error check occurs at compile time, whereas runtime errors are difficult to detect and occur primarily during contract execution. Out-of-gas error, data type overflow error, divide by zero error, array-out-of-index error, and so on are examples of runtime errors. Solidity had a single throw statement until version 4.10, so to handle errors, multiple if...else statements must be implemented for checking the values and throwing errors, which consumes more gas. After version 4.10, new error-handling constructs assert, require, and revert statements were added, and the throw function was made absolute.\n\n### Assert\n  Assert has the same syntax as the require statement. After evaluating the condition, it returns a boolean value. The programme will either continue to execute or throw an exception based on the return value. Instead of returning unused gas, the assert statement consumes the entire gas supply and then returns the state to its original state. Before the contract is executed, Assert is used to validate the current state and function conditions. \n  \n  Some cases with assert type exceptions\n    - An `assert` is called with a condition that yields a false result.\n    - A function's zero-initialized variable is called.\n    - Converting a large or negative value to an enum.\n    - A value is modulo or divided by zero.\n    - Accessing an array with an index that is either too large or too small.\n\n  - `assert(bool condition)`: \n    Causes a Panic error and thus state change reversion if the condition is not met - to be used for internal errors.\n\n### Require\n  The `require` statements declare the prerequisites for running the function, i.e. the constraints that must be met before executing the code. It takes a single argument and after evaluation returns a boolean value; it also has a custom string message option. If false, an exception is thrown and the execution is terminated. The unused gas is returned to the caller, and the state is reset to its original setting.\n  \n  - `require(bool condition)`: \n    reverts if the condition is not met - to be used for errors in inputs or external components.\n\n  - `require(bool condition, string memory message)`: \n    reverts if the condition is not met - to be used for errors in inputs or external components. Also provides an error message.\n\n### Revert\n  Revert is comparable to the require statement. It does not evaluate any condition or rely on any state or statement. It's used to throw exceptions, show errors, and revert the function call. This statement includes a string message that describes the problem with the exception's information. A revert statement implies that an exception is thrown, the unused gas is returned, and the state is reset to its original state. Revert is used to handle the same types of exceptions that require does, but with slightly more complex logic.\n\n  - `revert()`: \n    abort execution and revert state changes.\n\n  - `revert(string memory reason)`: \n    abort execution and revert state changes, providing an explanatory string.\n\nPlease gothrough the code for better understanding\n```solidity\n  pragma solidity ^0.6.0;\n\n  contract ErrorHandling{\n      // \"require\" \n      function Odd(uint n) public view returns(bool){\n          require(n % 2 != 0);\n          return true;\n      }\n      // input: 10\n      // output: \n      //     call to ErrorHandling.Odd errored: VM error: revert.\n      //     revert The transaction has been reverted to the initial state.\n\n      // input: 9\n      // output: \"0\": \"bool: true\"\n\n      bool result;\n      function assertCheck(uint n1, uint n2) public {\n          uint sum = n1 + n2;\n          assert(sum<=255);\n          result = true;\n          // return result;\n          // if return result used the below error happens \n          //     TypeError: Different number of arguments in return statement than in returns declaration.\n          //     return result;\n          //     ^-----------^\n      }\n\n      function checkResultAfter_assertCheck(uint n1, uint n2)public returns(bool){\n          assertCheck(n1,n2);\n          return result;\n      } \n      // input: 10, 20\n      // output: \"0\": \"bool: true\"\n\n      // input: 100, 200\n      // output: \"0\": \"bool: false\"\n      // transact to ErrorHandling.checkResultAfter_assertCheck errored: VM error: invalid opcode.\n      // The execution might have thrown.\n\n      function revertCheck(uint n1, uint n2) public view returns(string memory, uint){\n          uint sum = n1 + n2;\n          if(sum < 0 || sum > 255){\n              revert(\" Overflow Exist\");\n          }\n          else{\n              return (\"No Overflow\", sum);\n          }   \n      }\n      // input: 100, 200\n      // output: \"error\": \"Failed to decode output: Error: overflow (fault=\\\"overflow\\\", operation=\\\"toNumber\\\", value=\\\"3963877391197344453575983046348115674221700746820753546331534351508065746944\\\", code=NUMERIC_FAULT, version=bignumber/5.5.0)\"\n\n      // input: 10, 20\n      // output: \"0\": \"string: No Overflow\", \"1\": \"uint256: 30\"\n  }\n    \n```\n"
        },
        {
          "title": "Members of Address Type",
          "shortTitle": "Address Properties",
          "key": "address-properties",
          "details": "An address value type is intended to hold up to 20B, or 160 bits, the size of an Ethereum address. In fact, Solidity has two address value types: address and address payable. The distinction between the two is that address payable can send and receive Ether. An address can be used to obtain a balance using the.balance method and to transfer a balance using the.transfer method.\n\n- `<address>.balance (uint256)`:\n  Returns the balance of the Address in Wei. The function below is used to return the current balance of the sender.\n  ```solidity\n    function getBalance() public view returns(uint256){\n        return msg.sender.balance;\n    }\n  ```\n\n- `<address>.codehash (bytes32)`: the codehash of the Address.\n\n- `<address payable>.transfer(uint256 amount)`: \n  The receiving smart contract should have a fallback function defined or else the transfer call will throw an error. There is a gas limit of 2300 gas, which is enough to complete the transfer operation.\n  \n  The syntax of the transfer function looks like: `receivingAddress.transfer(amount);`. The transfer function fails when the balance of the sending smart contract is not large enough or the receiving contract rejects the payment. In a failure case, the transfer function reverts.\n\n- `<address payable>.send(uint256 amount) returns (bool)`: \n  Send is similar to transfer. But if the payment fails, it will not revert. Instead, it returns false. The failure handling is left to the calling contract. The syntax of the send function looks like: `receivingAddress.send(10);`. Send forwards 2300 gas to the receiving contract.\n\n```solidity\n  pragma solidity ^0.8.0;\n\n  contract Address{\n      //taking adress of popular NFT smart contract Crypto Punks\n      function balance(address add)public view returns(uint256){\n          return add.balance;\n      }\n      // input: \"address add\": \"0xe785E82358879F061BC3dcAC6f0444462D4b5330\"\n      // output: \"uint256: 0\"\n\n      function codehash(address add)public view returns(bytes32){\n          return add.codehash;\n      }\n      // input: \"address add\": \"0xe785E82358879F061BC3dcAC6f0444462D4b5330\"\n      // output: \"bytes32: 0x0000000000000000000000000000000000000000000000000000000000000000\"\n\n      function transfer(address payable add, uint256 amount)public{\n          add.transfer(amount);\n      }\n\n      function send(address payable add, uint256 amount)public returns(bool){\n          return add.send(amount);\n      }\n      // input: \"address add\": \"0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\", \"uint256 amount\": \"10\"\n      // output: \"bool: false\"\n  }\n```\n"
        },
        {
          "title": "Contract Related Functions",
          "shortTitle": "Contract Related",
          "key": "contract-related",
          "details": "`this` is the pointer to the current instance of the type derived from Address which is the current contract.\n\n`selfdestruct(address payable recipient)`: Destroy the current contract, after sending its funds to the given Address and end execution.\n\nplease gothrough the below code for better understanding\n```solidity\n  function destruct(address payable addr)public payable{\n    selfdestruct(addr);\n  }\n  // input: \"address addr\": \"0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\"\n  // output: \"null\"\n\n  function checkBalance(address payable addr)public view return(uint){\n    uint balance = address(this).balance;\n    return balance;\n  }\n  // input: \"address addr\": \"0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\"\n  // output: \"uint: 0\"\n\n```\n"
        },
        {
          "title": "Functions for Type Information",
          "shortTitle": "Type Information",
          "key": "type-info",
          "details": "The expression type(X) can be used to retrieve information about the type X.\nCurrently, there is limited support for this feature (X can be either a contract or an integer type).\nThe following properties are available for a contract type C:\n- `type(C).name`: The name of the contract.\n\n- `type(C).creationCode`: Memory byte array that contains the creation bytecode of the contract.\n\n- `type(C).runtimeCode`: Memory byte array that contains the runtime bytecode of the contract.\n\nIn addition to the properties above, the following properties are available for an interface type I: \n\n- `type(I).interfaceId`: A bytes4 value containing the EIP-165 interface identifier of the given interface I.\n\nThe following properties are available for an integer type T:\n\n- `type(T).min`: The smallest value representable by type T.\n- `type(T).max`: The largest value representable by type T.\n\nThe following code demonstrates the use of type(T). The function `foo` will return -128 which is the minimum value of `int8` value type and 255 which is the maximum value of `uint8` value type.\n\n```solidity\n  contract C {\n    function foo() public pure returns(int,uint){\n        return (type(int8).min,type(uint8).max);\n    }\n  }\n```\n"
        },
        {
          "title": "References",
          "shortTitle": "References",
          "key": "References",
          "details": "Units and Globally Available Variables\n  - https://docs.soliditylang.org/en/v0.8.16/units-and-global-variables.html\n  - http://man.hubwiz.com/docset/Solidity.docset/Contents/Resources/Documents/units-and-global-variables.html#units-and-globally-available-variables\n\nBlock and Transaction properties.\n  - https://www.geeksforgeeks.org/solidity-special-variables/\n\nABI Encoding and Decoding functions.\n  - https://www.quicknode.com/guides/smart-contract-development/what-is-an-abi\n  - https://coinsbench.com/solidity-tutorial-all-about-abi-46da8b517e7\n\nMembers of bytes and string.\n  - https://www.tutorialspoint.com/solidity/solidity_strings.htm\n\nError handling methods.\n  - https://www.geeksforgeeks.org/solidity-error-handling/#:~:text=Solidity%20is%20compiled%20to%20byte,of%2Dindex%20error%2C%20etc.\n\nCryptographic functions.\n  - https://www.geeksforgeeks.org/what-is-hashing-in-solidity/\n\nMembers of address type.\n  - https://docs.soliditylang.org/en/latest/units-and-global-variables.html#members-of-address-types\n"
        }
      ],
      "questions": [
        {
          "uuid": "49138998-5fbb-4437-b9cd-f92f8f11af94",
          "type": "MultipleChoice",
          "content": "Which of the following is a valid subdemonination of Ether in the latest version of Solidity?",
          "hint": "noHint",
          "explanation": "A literal number can take a suffix of `wei`, `gwei` or `ether` to specify a subdenomination of Ether. \nThe denominations `finney` and `szabo` have been removed in version 0.7.0.\n",
          "answerKeys": [
            "A",
            "B"
          ],
          "subTopics": [
            "units"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "wei",
              "key": "A"
            },
            {
              "content": "gwei",
              "key": "B"
            },
            {
              "content": "finney",
              "key": "C"
            },
            {
              "content": "szabo",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2ba13ded-426b-4dfd-b20c-3de783fcfdc3",
          "type": "SingleChoice",
          "content": "Which of the following is not a valid unit of time ?",
          "hint": "noHint",
          "explanation": "`seconds`, `minutes`, `hours`, `days` and `weeks` can be used to specify units of time.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "units"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`seconds`",
              "key": "A"
            },
            {
              "content": "`minutes`",
              "key": "B"
            },
            {
              "content": "`hours`",
              "key": "C"
            },
            {
              "content": "`years`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "44bf7f79-9ca9-4a32-89e6-bc3ff41633ea",
          "type": "SingleChoice",
          "content": "What is the value of 1 gwei?",
          "hint": "noHint",
          "explanation": "- Lowest unit is wei and $1e12$ represents $1 * 10^{12}$.\n  - `1 wei = 1;`\n  - `1 gwei = 1e9;`\n  - `1 ether = 1e18;`\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "units"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "1 gwei = 1 ether",
              "key": "A"
            },
            {
              "content": "1 gwei = $10^9$ ether",
              "key": "B"
            },
            {
              "content": "1 gwei = $10^9$ wei",
              "key": "C"
            },
            {
              "content": "1 gwei = $10^18$ wei",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "36ddb8ed-c494-473d-b894-31c11ea73a4a",
          "type": "SingleChoice",
          "content": "Which of the following properties is used to get information about the current block?",
          "hint": "noHint",
          "explanation": "`blockhash` gives the hash of the current block, `block.basefee` gives current blocks base fee and `block.gaslimit` gives the gaslimit of the current block.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "block-transaction"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`blockhash`",
              "key": "A"
            },
            {
              "content": "`basefee`",
              "key": "B"
            },
            {
              "content": "`gaslimit`",
              "key": "C"
            },
            {
              "content": "All of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "334cfbc3-4ab4-4134-bb3c-4cb9aa7dd1c4",
          "type": "MultipleChoice",
          "content": "Which of the following is true regarding block and transaction properties?",
          "hint": "noHint",
          "explanation": "`block.timestamp` and `blockhash` as a source of randomness are not secure. Timestamp and the blockhash can be influenced by the miners.\nThe block hashes are not available for all blocks for scalability reasons. You can only access the hashes of the most recent 256 blocks.\n`msg.value` contains the amount of wei (ether / 1e18) sent in the transaction.\nThe difficulty of a block is a measure of how difficult it is to mine a block.\n",
          "answerKeys": [
            "A",
            "B",
            "C"
          ],
          "subTopics": [
            "block-transaction"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "block.timestamp` and `blockhash` as a source of randomness are not secure.",
              "key": "A"
            },
            {
              "content": "The block hashes are not available for all blocks.",
              "key": "B"
            },
            {
              "content": "Block difficulty represents the ease with which a block can be mined.",
              "key": "C"
            },
            {
              "content": "msg.value contains the amount of ether sent in the transaction.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1dd1fc38-1188-4e1d-a085-83408f402893",
          "type": "MultipleChoice",
          "content": "Which of the following options is correct regarding the code below?\n```\n    function randMod() public view returns(uint){\n      return uint(keccak256(abi.encodePacked(block.timestamp))) % 2;\n    }\n```\n",
          "hint": "`block.timetamp` is current block timestamp as seconds which will change every second.",
          "explanation": "block.timestamp returns current block timestamp as seconds which will change every second so it can be used as a source of randomness. \nTaking the Keccak-256 hash of the value will result in a byte32 type random value whose modulous with 2 will give either 0 or 1.\nHowever it should not be used to make applications using randoms because the contract can be influenced by miners.\nA miner running a node, can publish a transaction only to his own node and not share it. \nThe functions `randMod` can be run until a function returns a winning value and then the miner can share the transaction.\n",
          "answerKeys": [
            "A",
            "C"
          ],
          "subTopics": [
            "block-transaction"
          ],
          "difficultyLevel": "Hard",
          "choices": [
            {
              "content": "The function `randMod` will return a random integer in the range [0,1].",
              "key": "A"
            },
            {
              "content": "The function `randMod` will return a random integer in the range [0,2].",
              "key": "B"
            },
            {
              "content": "`block.timestamp` should not be used to generate random numbers.",
              "key": "C"
            },
            {
              "content": "This function can be used to make a dApp where we generate an integer where a certain number is the winning number.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "4adfdac0-c48f-4803-88e1-1d22330ae2cc",
          "type": "MultipleChoice",
          "content": "What is `msg` in Solidity?",
          "hint": "noHint",
          "explanation": "The `msg` global variables in particular are special global variables that contain properties which allow access to the blockchain. \nFor instance, `msg.sender` is always the address where the current (external) function call came from.\nhe values of all members of msg, including msg.sender and msg.value can change for every external function call.\n",
          "answerKeys": [
            "A",
            "B",
            "D"
          ],
          "subTopics": [
            "block-transaction"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The `msg` is a special global variable that contain properties which allow access to the blockchain.",
              "key": "A"
            },
            {
              "content": "Values of all members of `msg` can change for every external function call.",
              "key": "B"
            },
            {
              "content": "Values of all members of `msg` cannot change for every external function call.",
              "key": "C"
            },
            {
              "content": "The `msg.sender` special global variable is used to obtain the current users address.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "3190aeb2-1d7d-4adb-950f-01cfda8d6164",
          "type": "SingleChoice",
          "content": "What does `abi` stand for?",
          "hint": "noHint",
          "explanation": "ABI stands for application binary interface.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "encoding-decoding"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "application binary interface",
              "key": "A"
            },
            {
              "content": "application binding interface",
              "key": "B"
            },
            {
              "content": "audio binary interface",
              "key": "C"
            },
            {
              "content": "application binding information",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "420bf665-0bd3-4b2c-860d-b0816126c974",
          "type": "SingleChoice",
          "content": "What is the need for encoding/decoding in Solidity?",
          "hint": "noHint",
          "explanation": "In general, an ABI is the interface between two program modules, one of which is often at the level of machine code. \nThe interface is the de facto method for encoding/decoding data into/out of the machine code.\nIt is very similar to API (Application Program Interface), a human-readable representation of a codes interface. \nABI defines the methods and structures used to interact with the binary contract, just like API does but on a lower-level.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "encoding-decoding"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "There is no need.",
              "key": "A"
            },
            {
              "content": "Data needs to be encoded in a machine readible format to communicate with a contract.",
              "key": "B"
            },
            {
              "content": "Encoding is necessary to make the data human readible.",
              "key": "C"
            },
            {
              "content": "ABI is exactly like API.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "54e85b5c-2de1-47ce-8abf-2e63f1f14f07",
          "type": "SingleChoice",
          "content": "A bytes array is given as followes which contains the abi encoding of an address and an int:\n```\n  0x0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4  \n  000000000000000000000000000000000000000000000000000000000000007f\n```\nCan you decode this string manually to retrieve the address and the int?\n",
          "hint": "Address holds a 20 byte value.",
          "explanation": "A quick analysis of the result shows us that it has 64 bytes.\nThis is because the encoding occurs in multiples of 32 bytes.\nThe first 32 bytes contain the address (20 bytes) and the other 32 bytes contain the integer, 7f. \nEncoding is always in hexadecimal, and 7f in hex is 127.\n",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "encoding-decoding"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4,127)",
              "key": "A"
            },
            {
              "content": "(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4,7)",
              "key": "B"
            },
            {
              "content": "(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4,7f)",
              "key": "C"
            },
            {
              "content": "(0x0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4,127)",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "fa48e97c-7b08-425e-be88-92aecf0ef81a",
          "type": "SingleChoice",
          "content": "what is the difference between abi.encode and abi.encodePacked?",
          "hint": "noHint",
          "explanation": "Through abi.encodePacked(), Solidity supports a non-standard packed mode where:\n- types shorter than 32 bytes are neither zero padded nor sign extended and\n- dynamic types are encoded in-place and without the length.\n- array elements are padded, but still encoded in-place.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "encoding-decoding"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "They use different methods for encoding.",
              "key": "A"
            },
            {
              "content": "Types encoded with encode get zero padded whearas with encodePacked they do not.",
              "key": "B"
            },
            {
              "content": "Types encoded with encodePacked get zero padded whearas with encode they do not.",
              "key": "C"
            },
            {
              "content": "There is no difference.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1c06be94-53cf-4b1b-8989-87f0aba557a7",
          "type": "SingleChoice",
          "content": "What does tx stand for?",
          "hint": "noHint",
          "explanation": "tx stands for \"transaction\".",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "block-transaction"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "tax",
              "key": "A"
            },
            {
              "content": "transaction",
              "key": "B"
            },
            {
              "content": "gas",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "74932f5f-8a08-4b5c-afc3-7d57c90111e1",
          "type": "SingleChoice",
          "content": "Which of the following is not a member of global variable `tx`?",
          "hint": "noHint",
          "explanation": "`tx.gasprice (uint)`: gas price of the transaction.  \n`tx.origin (address)`: sender of the transaction (full call chain).  \nwhearas gaslimit is a member of block, `block.gaslimit (uint)`: gives the current block gaslimit.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "block-transaction"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "gasprice",
              "key": "A"
            },
            {
              "content": "origin",
              "key": "B"
            },
            {
              "content": "gaslimit",
              "key": "C"
            },
            {
              "content": "None of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6a131770-4859-45e8-9a1a-0d5828648be5",
          "type": "MultipleChoice",
          "content": "Which of the following is not an available Mathematical function?",
          "hint": "noHint",
          "explanation": "The function addmod takes parameters (uint x, uint y, uint k) and will compute the expression `(x + y) % k`.\nThe function mulmod takes parameters (uint x, uint y, uint k) and will compute the expression `(x * y) % k`.\n",
          "answerKeys": [
            "B",
            "D"
          ],
          "subTopics": [
            "math-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "addmod",
              "key": "A"
            },
            {
              "content": "submod",
              "key": "B"
            },
            {
              "content": "mulmod",
              "key": "C"
            },
            {
              "content": "divmod",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "efcab7ee-106e-4a14-81c2-b71b4ec84a82",
          "type": "SingleChoice",
          "content": "Which of the following expressions will the function `mulmod(uint x, uint y, uint k) returns (uint)` compute?",
          "hint": "noHint",
          "explanation": "explanation",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "math-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`(x * y) * k`",
              "key": "A"
            },
            {
              "content": "`(x % y) * k`",
              "key": "B"
            },
            {
              "content": "`(x % k) * y`",
              "key": "C"
            },
            {
              "content": "`(x * y) % k`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "33896ba7-2f65-4dad-b611-5e019e2a10b1",
          "type": "SingleChoice",
          "content": "What is the output of the following function?\n```\nfunction func() public pure returns(uint){\n     return mulmod(addmod(4,5,2),7,2);\n  }\n```\n",
          "hint": "noHint",
          "explanation": "addmod(4,5,2) will evaluate (4+5)%2 which is equal to 1. mulmod of (1,7,2) is (1*7)%2 which is 1.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "math-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "3",
              "key": "A"
            },
            {
              "content": "0",
              "key": "B"
            },
            {
              "content": "1",
              "key": "C"
            },
            {
              "content": "None of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "56fd9c11-7f9c-4d57-973f-e91a9ae2d661",
          "type": "SingleChoice",
          "content": "Which of the following are valid cryptographic hashing functions?",
          "hint": "noHint",
          "explanation": "`keccak256(bytes memory) returns (bytes32)`: computes the Keccak-256 hash of the input.  \n`sha256(bytes memory) returns (bytes32)`: computes the SHA-256 hash of the input.  \n`ripemd160(bytes memory) returns (bytes20)`: compute RIPEMD-160 hash of the input.  \n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "math-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "keccak256",
              "key": "A"
            },
            {
              "content": "sha256",
              "key": "B"
            },
            {
              "content": "ripemd160",
              "key": "C"
            },
            {
              "content": "All of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "9a42f50c-2667-4677-b3f1-40d2a714e24e",
          "type": "MultipleChoice",
          "content": "Which of the following options is correct regarding the statements below?  \nStatement 1-The keccak256 (SHA-3 family) algorithm computes the hash of an input to a fixed length output. \nStatement 2- It can be decoded in reverse to retrieve the original input.\n",
          "hint": "noHint",
          "explanation": "The keccak256 (SHA-3 family) algorithm computes the hash of an input to a fixed length output. \nThe input can be a variable length string or number, but the result will always be a fixed bytes32 data type.\nIt is a one-way cryptographic hash function, which cannot be decoded in reverse.\n",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "math-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement 1 is true but Statement 2 is false.",
              "key": "A"
            },
            {
              "content": "Statement 2 is true but Statement 1 is false.",
              "key": "B"
            },
            {
              "content": "Both are true.",
              "key": "C"
            },
            {
              "content": "Neither is true.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "afb85d5c-a9f2-4271-8cb7-d04f9d66e2c3",
          "type": "MultipleChoice",
          "content": "Which of the following is true regarding keccak256 hash function?",
          "hint": "noHint",
          "explanation": "The input can be a variable length string or number, but the result of the hash function will always be a fixed bytes32 data type.\nThe slightest modification or change in the string results in a massive change in the hash digest.\n",
          "answerKeys": [
            "A",
            "C",
            "D"
          ],
          "subTopics": [
            "math-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Size of the output of the fuction does not depend on size of input.",
              "key": "A"
            },
            {
              "content": "Size of the output of the fuction depends on the size of input.",
              "key": "B"
            },
            {
              "content": "Small change in input results in massive change in output.",
              "key": "C"
            },
            {
              "content": "The output of the function is a bytes32 data type.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "abe82746-9aef-4683-b8a4-8149ed4d9261",
          "type": "MultipleChoice",
          "content": "A collision occurs in a hash function when two different inputs produce the same output. \nYou are calculating the hash of two strings using `keccak256(abi.encodePacked(_string1, _string2));`.\nWhich of the following options is correct?\n",
          "hint": "Is it possible for a input in `abi.encodePacked(_string1, _string2)` to produce similar output with a different input? \nThink of how encoding is done with `abi.encodePacked`.\n",
          "explanation": "Take for example the following inputs:\n(AAA, BBB) -> AAABBB,      \n(AA, ABBB) -> AAABBB  \nThey are supposed to be different from each other, but when concatenated as a single string, they actually will produce the same output.\nOn encoding the input with `abi.encode`, you will have padded zeroes while in abi.encodePacked you do not. Therefore with `abi.encodePacked`, there will always be a collision if the two strings of the two different inputs concatenate to the same string.\nIf there is likelihood of inputs resulting in outputs that can cause a collision it is recommended to use abi.encode instead of abi.encodePacked.\n",
          "answerKeys": [
            "B",
            "C",
            "D"
          ],
          "subTopics": [
            "math-functions"
          ],
          "difficultyLevel": "Hard",
          "choices": [
            {
              "content": "Collision is not possible with keccak256 hashing function.",
              "key": "A"
            },
            {
              "content": "There can be certain cases when the two strings will result in a collision.",
              "key": "B"
            },
            {
              "content": "Collision can be prevented using `abi.encode`.",
              "key": "C"
            },
            {
              "content": "Hashing is an important aspect of cryptographic security for digital wallets and transactions on the blockchain.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8bdd0f4b-fbb7-4524-abde-aa12cc1d19fb",
          "type": "MultipleChoice",
          "content": "Which of the following options is correct regarding tx.origin and msg.sender?\n",
          "hint": "noHint",
          "explanation": "The `tx.origin` global variable refers to the original external account that started the transactions.  \nmsg.sender refers to the immediate account (it could be external or another contract account) that invokes the function.\n",
          "answerKeys": [
            "A",
            "B",
            "D"
          ],
          "subTopics": [
            "block-transaction"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "The `tx.origin` global variable refers to the original external account that started the transactions.",
              "key": "A"
            },
            {
              "content": "msg.sender refers to the immediate account (it could be external or another contract account) that invokes the function.",
              "key": "B"
            },
            {
              "content": "Both functions can be used interchangeably.",
              "key": "C"
            },
            {
              "content": "Both can produce the same output when invoked.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "62cce1c3-0b4a-47f1-9e13-98748fa52266",
          "type": "SingleChoice",
          "content": "Which of the following cannot be used to concatenate two strings `a` and `b`?",
          "hint": "noHint",
          "explanation": "Solidity doesn't provide built-in string concatenation and string comparison. Comparision like (a==b) can also not be done.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "bytes-strings"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`a+b`",
              "key": "A"
            },
            {
              "content": "`string(bytes.concat(bytes(a),bytes(b)));`",
              "key": "B"
            },
            {
              "content": "`string(abi.encodePacked(a,' ',b));`",
              "key": "C"
            },
            {
              "content": "`string.concat(a,b);`",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "3fe8cd83-6d7e-4db7-9786-dd934513c65c",
          "type": "SingleChoice",
          "content": "Which of the following options is not correct regarding hashing functions?",
          "hint": "noHint",
          "explanation": "Keccak-256, a cryptographic function, is part of Solidity (SHA-3 Family). \nThis function computes the hash of an input to a fixed-length output, yielding a singular 32-byte hash from any number of inputs. \nEven the slightest alteration or modification to the string has a significant impact on the hash digest.\nThe SHA-256 is weaker than Keccak-256.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "math-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The SHA-256 is weaker than Keccak-256.",
              "key": "A"
            },
            {
              "content": "Even the slightest alteration or modification to the input string has a significant impact on the hash digest.",
              "key": "B"
            },
            {
              "content": "Keccak-256, a cryptographic function, is part of Solidity (SHA-256 Family).",
              "key": "C"
            },
            {
              "content": "None of these are correct.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "89ae4ee5-30ef-4927-82e1-8a3d390a401b",
          "type": "SingleChoice",
          "content": "Which of the following is not an error handling function?",
          "hint": "noHint",
          "explanation": "`assert`, `require`, `revert` is used for error handling in Solidity.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "error-handling"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "assert",
              "key": "A"
            },
            {
              "content": "require",
              "key": "B"
            },
            {
              "content": "revert",
              "key": "C"
            },
            {
              "content": "request",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "0271fb33-0019-47e5-94f2-aac7cd4144d2",
          "type": "SingleChoice",
          "content": "What is the unit of `tx.gasprice`?",
          "hint": "noHint",
          "explanation": "The unit is wei.\nWei is the lowest possible denomination that can be handled by Solidity.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "encoding-decoding"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Ether",
              "key": "A"
            },
            {
              "content": "wei",
              "key": "B"
            },
            {
              "content": "kwei",
              "key": "C"
            },
            {
              "content": "gwei",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "32cc38d2-e0f4-4169-ad09-267650411ed0",
          "type": "SingleChoice",
          "content": "Which of the following is the correct way to return the address of the current contract in a function?",
          "hint": "noHint",
          "explanation": "The `this` keyword in Solidity refers to the current contract. It is convertible to the address type using `address(this)`.\n",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "contract-related"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`return address(this);`",
              "key": "A"
            },
            {
              "content": "`return this;`",
              "key": "B"
            },
            {
              "content": "`return this.MyContract;`",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "3b965e9e-0976-4426-af2b-9f71b08c7cc2",
          "type": "MultipleChoice",
          "content": "What is the `this` keyword in Solidity?",
          "hint": "noHint",
          "explanation": "The `this` keyword in Solidity refers to the current contract. It is convertible to the address type using `address(this)`.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "contract-related"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The `this` keyword in Solidity refers to the current contract.",
              "key": "A"
            },
            {
              "content": "The `this` keyword in Solidity refers to the current contracts address.",
              "key": "B"
            },
            {
              "content": "The `this` keyword in Solidity refers to the instance of the function from where it is called.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ca4b7841-d73b-4630-9602-c4777553786e",
          "type": "SingleChoice",
          "content": "Which function is used to destroy a contract?",
          "hint": "noHint",
          "explanation": "`selfdestruct(address payable recipient)`: is used to destroy the current contract, sending its funds to the given Address and end execution.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "contract-related"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "suicide",
              "key": "A"
            },
            {
              "content": "revert",
              "key": "B"
            },
            {
              "content": "selfdestruct",
              "key": "C"
            },
            {
              "content": "assert",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "041f5a22-2efd-4ce9-baef-69c2243b4703",
          "type": "SingleChoice",
          "content": "What is the return type for keccak256 hash function?",
          "hint": "noHint",
          "explanation": "`keccak256(bytes memory) returns (bytes32)`: computes the Keccak-256 hash of the input in the form of a bytes32 type output.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "math-functions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "uint8",
              "key": "A"
            },
            {
              "content": "bytes20",
              "key": "B"
            },
            {
              "content": "uint 32",
              "key": "C"
            },
            {
              "content": "bytes32",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1fff2dea-d5a9-4b89-af31-cdf9147ef127",
          "type": "SingleChoice",
          "content": "How will you retrieve the current contracts balance?",
          "hint": "this keyword referss to the current contracts instance.",
          "explanation": "`this` keyword referss to the current contracts instance. \n`address(this)` will give the address of the current contract. `address(this).balance` will retrieve the balance associated with the current contract.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "contract-related"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "this.balance",
              "key": "A"
            },
            {
              "content": "address(this).balance",
              "key": "B"
            },
            {
              "content": "balance(this)",
              "key": "C"
            },
            {
              "content": "MyContract.balance",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "29189ccf-69f5-446a-a6b0-4a87d7854766",
          "type": "SingleChoice",
          "content": "Which of the following is not a way of sending ether?",
          "hint": "noHint",
          "explanation": "In Solidity, there are three ways in which one can send ether. Namely transfer(), send() and call().\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "address-properties"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "send",
              "key": "A"
            },
            {
              "content": "transfer",
              "key": "B"
            },
            {
              "content": "call",
              "key": "C"
            },
            {
              "content": "codehash",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "07cabeaa-d693-4346-9293-28e8b7aba346",
          "type": "MultipleChoice",
          "content": "Which of the following options is correct regarding send and transfer?",
          "hint": "noHint",
          "explanation": "Send is similar to transfer. But if the payment fails, it will not reverts.\n\"The syntax of the transfer function looks like: `receivingAddress.transfer(amount);`.\"\n",
          "answerKeys": [
            "A",
            "C"
          ],
          "subTopics": [
            "address-properties"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Send is similar to transfer. But if the payment fails, it will not revert.",
              "key": "A"
            },
            {
              "content": "Transfer is similar to send. But if the payment fails, it will not revert.",
              "key": "B"
            },
            {
              "content": "The syntax of the transfer function looks like: `receivingAddress.transfer(amount);`.",
              "key": "C"
            },
            {
              "content": "The syntax of the transfer function looks like: `transfer(receivingAddress,amount);`.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "25073a6e-60fe-43a3-b95b-9440e0a7c141",
          "type": "SingleChoice",
          "content": "What is the difference between transfer and call?",
          "hint": "noHint",
          "explanation": "- `address.transfer()`\n  - throws on failure.\n  - forwards 2,300 gas stipend, safe against reentrancy.\n- `address.call.value().gas()()`\n  - returns false on failure.\n  - forwards all available gas, allows specifying how much gas to forward.\n",
          "answerKeys": [
            "A",
            "B",
            "C"
          ],
          "subTopics": [
            "address-properties"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "transfer reverts if the send falis.",
              "key": "A"
            },
            {
              "content": "transfer forwards 2,300 gas stipend.",
              "key": "B"
            },
            {
              "content": "call forwards all available gas, allows specifying how much gas to forward.",
              "key": "C"
            },
            {
              "content": "call reverts on failure.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "0741a691-a8cb-48de-8148-59974b4804fc",
          "type": "SingleChoice",
          "content": "Which of the following is not correct?",
          "hint": "noHint",
          "explanation": "Send and transfer forwards 2300 gas to the receiving contract.\nSince the amount of gas forwarded to the called smart contract is very low, the called smart contract can easily run out of gas.\nUsing call allows for re-entrancy attacks. The receiver contract calls the function again where the call() statement is given. If the sender contract is improperly coded, it can result in draining larger amounts of funds from it than planned.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "block-transaction"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Both send and transfer have a gas limit of 2300 gas.",
              "key": "A"
            },
            {
              "content": "send/transfer is better than call.",
              "key": "B"
            },
            {
              "content": "transfer is hardcoded to prevent re-entrancy attacks while call is not.",
              "key": "C"
            },
            {
              "content": "As the amount of gas forwarded in send and transfer is very low, the called contract can run out of gas.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "de653a8b-fc0f-4509-a891-716f6ad316bc",
          "type": "SingleChoice",
          "content": "What is incorrect with the following expresion: `address(this).balance = 0`.",
          "hint": "`.balance` returns a uint256 type value.",
          "explanation": "You cannot do address(this).balance = 0 , because address(this).balance is a number not a variable.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "address-properties"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The expression is correct and will compile.",
              "key": "A"
            },
            {
              "content": "The expression will assign balance of current contracts address to 0.",
              "key": "B"
            },
            {
              "content": "The expression will give typeError.",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "295846f8-221a-474b-a5aa-916379f4e58f",
          "type": "SingleChoice",
          "content": "Which of the following options is correct regarding the statements below?\nStatement 1- `block.number` givess the the block on the blockchain where the contract is mined in.\nStatement 2- `block.number` also corresponds to the block number of the block which includes the transaction of ETH sent to a contract function.\n",
          "hint": "noHint",
          "explanation": "Any Solidity method call that changes the state is a transaction. \nTo log or return the block info of that transaction, you can use block.number. \nThis is possible because that method call can only take effect on the state once the block that the transaction belongs to is mined and upon mining, those properties expose all that info about that block.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "block-transaction"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Statement 1 is true but Statement 2 is false.",
              "key": "A"
            },
            {
              "content": "Statement 2 is true but Statement 1 is false.",
              "key": "B"
            },
            {
              "content": "Both are true.",
              "key": "C"
            },
            {
              "content": "Neither is true.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "fb264114-7251-4110-a42e-2cb91bdc89f1",
          "type": "SingleChoice",
          "content": "Which of the following is not a special variable available in the global namespace?",
          "hint": "noHint",
          "explanation": "There exist special variables like `msg`, `tx`, and `block` in solidity which exist in the global namespace and are mainly used to provide information about the blockchain.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "block-transaction"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "msg",
              "key": "A"
            },
            {
              "content": "tx",
              "key": "B"
            },
            {
              "content": "block",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "9af7c152-de7d-4b7b-b453-bfa78f89c9c7",
          "type": "SingleChoice",
          "content": "What does `abi.encodeWithSelector` do?",
          "hint": "noHint",
          "explanation": "ABI-encodes the given arguments starting from the second and prepends the given four-byte selector.\n`abi.encodePacked` doesn't do this. It does a packed encoding of all arguments combined.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "encoding-decoding"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It is similar to `abi.encodePacked(FUNC_SELECTOR, _param1, _param2)`.",
              "key": "A"
            },
            {
              "content": "ABI-encodes the given arguments starting from the second and prepends the given four-byte selector.",
              "key": "B"
            },
            {
              "content": "ABI-encodes all the the given arguments .",
              "key": "C"
            },
            {
              "content": "None of these.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8cdb0db5-30fd-4bf6-8c3a-181827a73d79",
          "type": "SingleChoice",
          "content": "Which of the following is equivalent to `abi.encodeWithSignature(string memory signature, ...)`?",
          "hint": "noHint",
          "explanation": "`abi.encodeWithSelector` ABI-encodes the given arguments starting from the second and prepends the given four-byte selector, \n`abi.encodeWithSignature(string memory signature, ...)` is equivalent to `abi.encodeWithSelector(bytes4(keccak256(bytes(signature))), ...)`.\n",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "encoding-decoding"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "`abi.encodeWithSelector(bytes4(keccak256(bytes(signature))), ...)`",
              "key": "A"
            },
            {
              "content": "`abi.encodePacked(signature, ...)`",
              "key": "B"
            },
            {
              "content": "`abi.encodeWithSelector(signature, ...)`",
              "key": "C"
            },
            {
              "content": "None of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "899f9f74-be50-4de5-bde6-4161418bfbc8",
          "type": "MultipeChoice",
          "content": "Why does `msg.sig` return first four bytes of the calldata as a function identifier?",
          "hint": "noHint",
          "explanation": "You can address in theory $2^{32}$ (4294967296 as 4 bytes have 32 bits) different methods in any single contract.\nIt seems enough for any possible contract, giving furthermore the presence of a code size limit of 24 kbytes or so (The major of them have five-to-twenty methods).\nChoosing 4 bytes is a reasonable choice because, the probability of a collision is very low so you are assured in any case of a lot of unique entries for methods in the single contract.\n",
          "answerKeys": [
            "A",
            "C"
          ],
          "subTopics": [
            "block-transaction"
          ],
          "difficultyLevel": "Hard",
          "choices": [
            {
              "content": "Using four bytes is a tradeoff as even big contracts have maximum five-to-twenty methods.",
              "key": "A"
            },
            {
              "content": "4 bytes can be used to denote any number of methods in a contract.",
              "key": "B"
            },
            {
              "content": "There can be a total of 4294967296 different methods in any single contract.",
              "key": "C"
            },
            {
              "content": "A collision can never happen using 4 bytes.",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "1b6f7a4a-5f9e-40f0-8259-7a029e372747",
          "title": "Global Variables",
          "shortTitle": "Global Variables",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=ryA86ZiSD-w",
          "subTopics": [
            "global-variables",
            "block-transaction"
          ],
          "details": "Global variables contain information about blockchain, transaction and caller of the function. \nThis video explains the use of some of the block and trasaction properties available in Solidity like `msg.sender`, `block.timestamp` and `block.number`.\n"
        }
      ],
      "summaries": [
        {
          "title": "Units",
          "shortTitle": "Units",
          "key": "units",
          "details": "- Ether Units\n  - In Solidity, we can use wei, gwei or ether to specify a subdenomination of Ether.\n  - Lowest unit is wei and $1e12$ represents $1 * 10^{12}$.\n  - `1 wei = 1;`\n  - `1 gwei = 1e9;`\n  - `1 ether = 1e18;`\n  - The following code snippet demonstrates a simple function to convert the total `wei` (default unit in Solidity) to Ether.\n    ```\n    contract C\n    {\n      function func() public view returns(uint){\n          uint bal = address(this).balance / 1 ether;\n          return bal;\n      }\n    }\n    ```\n\n- Time Units\n  - We can use seconds, minutes, hours, days and weeks as suffix to denote time.\n  - Lowest unit of time is `seconds`.\n  - `1 seconds = 1;`\n  - `1 minutes = 60 seconds;`\n  - `1 hours = 60 minutes;`\n  - `1 day = 24 hours;`\n  - `1 week = 7 days;`  \n  - On calling function `func` below, the value of `block.timestamp` returns 1661554329 seconds however the returned value will be 143558295494400 seconds because \n    `block.timestamp` gets multiplied with 24*60*60 due to the `days` time denomination.\n    ```\n        contract C\n        {\n          function func() public view returns(uint){\n              return block.timestamp * 1 days;\n          }\n        }\n    ```\n"
        },
        {
          "title": "Globally available Variables",
          "shortTitle": "Global Variables",
          "key": "global-variables",
          "details": "- There are special variables and functions which always exist in the global namespace and are mainly used to provide \n    information about the blockchain or are general-use utility functions.\n- These are of various types having specific properties.\n  - Block and Transaction properties.\n  - ABI Encoding and Decoding functions.\n  - Members of bytes and string.\n  - Error handling methods.\n  - Mathematical and Cryptographic functions.\n  - Members of address type.\n  - Contract related.\n  - Type Information.\n\nFew of the important functions of each type will be discussed in the following sections.\n"
        },
        {
          "title": "Block and Transaction properties",
          "shortTitle": "Block Properties",
          "key": "block-transaction",
          "details": "- `blockhash(uint blockNumber) returns (bytes32)`: Gives hash of the given block and will only work for the 256 most recent block due to the reason of scalability.\n- `block.basefee (uint)`: current blocks base fee.\n- `block.chainid (uint)`: current chain id.\n- `block.coinbase (address payable)`: current block miners address.\n- `block.difficulty (uint)`: current block difficulty.\n- `block.gaslimit (uint)`: current block gaslimit.\n- `block.number (uint)`: current block number.\n- `block.timestamp (uint)`: current block timestamp as seconds since unix epoch.\n- `gasleft() returns (uint256)`: remaining gas.\n- `msg.data (bytes calldata)`: complete calldata.\n- `msg.sender (address)`: sender of the message (current call).\n- `msg.sig (bytes4)`: first four bytes of the calldata (i.e. function identifier).\n- `msg.value (uint)`: number of wei sent with the message.\n- `tx.gasprice (uint)`: gas price of the transaction.\n- `tx.origin (address)`: sender of the transaction (full call chain).\n- The code snippet below demonstrates the use of some of the Block and transaction properties.\n  ```\n    contract C {\n      function blockInfo() public view returns(uint,uint,bytes32,address){\n          address sender=msg.sender;\n          uint blockNum=block.number;\n          uint blockTime=block.timestamp;\n          bytes32 hash=blockhash(blockNum);\n          return (blockNum,blockTime,hash,sender);\n      }\n    }\n  ```\n  The output of the function `blockInfo` is:-\n  ```\n    0:uint256: 27\n    1:uint256: 1661098178\n    2:bytes32: 0x0000000000000000000000000000000000000000000000000000000000000000\n    3:address: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4\n  ```\n- The values of all members of msg can change for every external function call.\n- `block.timestamp` and `blockhash` as a source of randomness are not secure. Timestamp and the blockhash can be influenced by the miners.\n"
        },
        {
          "title": "ABI Encoding and Decoding functions.",
          "shortTitle": "Encoding/Decoding",
          "key": "encoding-decoding",
          "details": "- To send data to the contract, we need to send it in a way that the contract can read it. That is, they need to be encoded.\n- Solidity has a global variable called abi that has an encode and decode method, so we can use it to encode the parameters of any function.\n- ABI stands for application binary interface. It's basically how you can encode Solidity contract calls for the EVM and, backwards, how to read the data out of transactions.\n- `abi.encode(...) returns (bytes memory)`: ABI-encodes the given arguments.\n- `abi.decode(bytes memory encodedData, (...)) returns (...)`: ABI-decodes the given data, while the types are given in parentheses as second argument. \n  Example: `(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))`\n- The example below demonstrates encoding and decoding.\n  ```\n  contract Encode {\n    function encode(string memory _string1, uint _uint) public pure returns (bytes memory) {\n            return (abi.encode(_string1, _uint));\n        }\n    function decode(bytes memory data) public pure returns (string memory _str1, uint _number) {\n            (_str1, _number) = abi.decode(data, (string, uint));            \n        }\n    }\n  ```\n  On calling function `encode` with values (Hi , 5), returns bytes array \n  `0:bytes: 0x0000000000000000000000000000000000000000000000000000000000\n  0000400000000000000000000000000000000000000000000000000000000000000005\n  0000000000000000000000000000000000000000000000000000000000000003486920\n  0000000000000000000000000000000000000000000000000000000000`  \n  The encoded data can be decoded by calling function `decode` with the above bytes array.\n  The returned values are \n  ```\n    0:string: _str1 Hi\n    1:uint256: _number 5\n  ```\n- `abi.encodePacked(...) returns (bytes memory)`: Performs packed encoding of the given arguments.\n- `abi.encodeWithSelector(bytes4 selector, ...) returns (bytes memory)`: ABI-encodes the given arguments starting from the second and prepends the given four-byte selector.\n- `abi.encodeWithSignature(string memory signature, ...) returns (bytes memory)`: Equivalent to `abi.encodeWithSelector(bytes4(keccak256(bytes(signature))), ...)`.\n- `abi.encodeCall(function functionPointer, (...)) returns (bytes memory)`: ABI-encodes a call to functionPointer with the arguments found in the tuple. Performs a full type-check, ensuring the types match the function signature. Result `equals abi.encodeWithSelector(functionPointer.selector, (...))`abi.decode.\n"
        },
        {
          "title": "Mathematical and Cryptographic Functions",
          "shortTitle": "Math Functions",
          "key": "math-functions",
          "details": "- `addmod(uint x, uint y, uint k) returns (uint)`\n  - This functions will compute the expression `(x + y) % k`.\n  - The code snippet below shows the use of the addmod functions.\n    ```\n    contract C {\n      function foo() public pure returns(uint){\n          return addmod(1,4,3);\n      }\n    }\n    ``` \n    The function `foo` will return the modulous of `(1 + 4)` with 3 which is 2.\n  - The addition is performed with arbitrary precision and does not wrap around at $2^{256}$.\n\n- `mulmod(uint x, uint y, uint k) returns (uint)`\n  - This function will compute the expression `(x * y) % k`.\n  - - The code snippet below shows the use of the mulmod functions.\n    ```\n    contract C {\n      function bar() public pure returns(uint){\n          return mulmod(5,7,3);\n      }\n    }\n    ```\n    The function `bar` will return the modulous of `(5 * 7)` with 3 which is 2.\n  - The multiplication is performed with arbitrary precision and does not wrap around at $2^{256}$.\n\n- `keccak256(bytes memory) returns (bytes32)`\n  - This function will compute and return the Keccak-256 hash of the input.\n  - Keccak-256 is part of Solidity (SHA-3 Family). \n  - This function computes the hash of an input to a fixed-length output, yielding a singular 32-byte hash from any number of inputs.\n  - This cryptographic hash function can only be used in one direction and cannot be reversed.\n\n- `sha256(bytes memory) returns (bytes32)`\n  - This function will compute and return the SHA-256 hash of the input.\n  - The SHA-256 is weaker than Keccak-256.\n"
        },
        {
          "title": "Members of bytes and string",
          "shortTitle": "bytes/string props",
          "key": "bytes-strings",
          "details": "- `bytes.concat(...) returns (bytes memory)`: \n  Concatenates variable number of bytes and bytes1, …, bytes32 arguments to one byte array.\n\n- `string.concat(...) returns (string memory)`: \n  Concatenates variable number of string arguments to one string array.\n\n- The Contract C below demonstrates the use of `bytes.concat` and `string.concat` to concatenate two strings a and b.\n  ```\n  contract C\n  {\n    function testStringConcat(string memory a,string memory b) public pure returns (string memory) {\n          return string.concat(a , b);\n      }\n\n      function testByteConcat(string memory a,string memory b) public pure returns (string memory){\n          return string(bytes.concat(bytes(a), \" \", bytes(b)));\n      } \n  }\n  ```\n"
        },
        {
          "title": "Error Handling Functions",
          "shortTitle": "Error Functions",
          "key": "error-handling",
          "details": "- `assert(bool condition)`: \n  Causes a Panic error and thus state change reversion if the condition is not met - to be used for internal errors.\n\n- `require(bool condition)`: \n  reverts if the condition is not met - to be used for errors in inputs or external components.\n\n- `require(bool condition, string memory message)`: \n  reverts if the condition is not met - to be used for errors in inputs or external components. Also provides an error message.\n\n- `revert()`: \n  abort execution and revert state changes.\n\n- `revert(string memory reason)`: \n  abort execution and revert state changes, providing an explanatory string.\n\n- Working and detailed explanation of all the functions has been covered in Chapter- `Your First Solidity Smart Contract` under subtopic `Error Handling`.\n"
        },
        {
          "title": "Members of Address Type",
          "shortTitle": "Address Properties",
          "key": "address-properties",
          "details": "- `<address>.balance (uint256)`:\n  Returns the balance of the Address in Wei. The function below is used to return the current balance of the sender.\n  ```\n  function getBalance() public view returns(uint256){\n      return msg.sender.balance;\n  }\n  ```\n\n- `<address>.codehash (bytes32)`:\n  the codehash of the Address.\n\n- `<address payable>.transfer(uint256 amount)`: \n  - The receiving smart contract should have a fallback function defined or else the transfer call will throw an error. There is a gas limit of 2300 gas, which is enough to complete the transfer operation.\n  - The syntax of the transfer function looks like: `receivingAddress.transfer(amount);`.\n  - The transfer function fails when the balance of the sending smart contract is not large enough or the receiving contract rejects the payment. In a failure case, the transfer function reverts.\n\n- `<address payable>.send(uint256 amount) returns (bool)`: \n  - Send is similar to transfer. But if the payment fails, it will not revert. Instead, it returns false. The failure handling is left to the calling contract.\n  - The syntax of the send function looks like: `receivingAddress.send(10);`.\n  - Send forwards 2300 gas to the receiving contract.\n"
        },
        {
          "title": "Contract Related Functions",
          "shortTitle": "Contract Related",
          "key": "contract-related",
          "details": "- `this`: `this` is the pointer to the current instance of the type derived from Address which is the current contract.\n- `selfdestruct(address payable recipient)`: Destroy the current contract, sending its funds to the given Address and end execution.\n"
        },
        {
          "title": "Functions for Type Information",
          "shortTitle": "Type Information",
          "key": "type-info",
          "details": "The expression type(X) can be used to retrieve information about the type X.\nCurrently, there is limited support for this feature (X can be either a contract or an integer type).\nThe following properties are available for a contract type C:\n- `type(C).name`\n  - The name of the contract.\n\n- `type(C).creationCode`\n  - Memory byte array that contains the creation bytecode of the contract.\n\n- `type(C).runtimeCode`\n  - Memory byte array that contains the runtime bytecode of the contract.\n\nIn addition to the properties above, the following properties are available for an interface type I: \n\n- `type(I).interfaceId`\n  - A bytes4 value containing the EIP-165 interface identifier of the given interface I.\n\nThe following properties are available for an integer type T:\n\n- `type(T).min`\n  - The smallest value representable by type T.\n\n- `type(T).max`\n  - The largest value representable by type T.\n\n- The following code demonstrates the use of type(T). The function `foo` will return -128 which is the minimum value of `int8` value type and 255 which is the maximum value of `uint8` value type.\n  ```\n  contract C {\n    function foo() public pure returns(int,uint){\n        return (type(int8).min,type(uint8).max);\n    }\n  }\n  ```\n"
        }
      ]
    },
    {
      "title": "Expressions and Control Structures",
      "key": "expression-control",
      "details": "This chapter covers how to write expressions and covers the various Control Structures like if/else , for etc.",
      "order": 3,
      "explanations": [
        {
          "title": "Decision Making",
          "shortTitle": "if/else statements",
          "key": "decision-making",
          "details": "If/else statements are used for making decisions and for checking conditions in order to run a program. If the compiler encounters an `if` statement, it checks the condition(s) specified in that statement. \nIf the condition(s) are true, it executes the code inside the body of the `if` statement. If the condition(s) are false, the compiler jumps to the next line after the block. The compiler will check all \nthe `if` statements but it is not the case with `else`. The `else` block is executed if and only if all of the preceding `if`statements in the code block are false. We can have multiple `if` blocks, but we can have only one `else` block under an `if` block. \nThe `else` statement can be defined only when the `if` statement is defined prior to it and they should be continuous - no other codes should lie in between `if` and `else` blocks. If/else statements can be declared only inside functions or function modifiers. \nIf/else statments are very useful to handle the logic of our code.\n\nIf/else statements in Solidity are similar to other programming languages like JavaScript and Python, but the main difference is that type conversion from non-boolean to boolean is not available in Solidity. \nThis means that `if (1)` is not a valid statement in Solidity. We can also have single line if/else statements. \n\nsyntax for if/else statements\n```\nif(expression//condition){\n//body\n}\nif(condition) body; single line if statement\nelse {\n  body of else block\n}\n\n```\nExample of a contract demonstrating the usage of if/else statements.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.5;\n\ncontract DecisionMaking {\n    event Log(string message);\n\n    function checkValue(uint x) public {\n        if (x > 100) { // if statement-1\n            emit Log(\"x is greater than hundred\");\n        }\n        if (x > 50 && x <= 100) // if statement-2\n            emit Log(\"x is greater than fifty but less than hundred\");\n        if (x > 1 && x <= 50) { // if statement-3\n            emit Log(\"x is greater than one but less than fifty\");\n        } else emit Log(\"x is less than 1\"); // else statement-1\n        if (x == 0) emit Log(\"x is equal to zero\"); // if statement-4\n        else {\n            emit Log(\"x is not equal to zero\"); // else statement-2\n        }\n    }\n}\n```\nThe code snippet above defines the if/else blocks inside the function `checkValue`. When the function is called with an argument, every if block will be validated. The compiler checks all the `if` blocks and then goes \nto the `else` statement if none of the `if` blocks validate to true. For example if the value of `x` is 20 the `if statement-3` is executed and as well as `else statement-2` is executed. If the value of `x` is 0 `else statement-1` is executed\nbecause all the if statements above it fails the condition. Similarly `if statement-4` is also executed as the condition is true.\n"
        },
        {
          "title": "For, While, Do While Loops",
          "shortTitle": "Loops",
          "key": "loops-for-while-do",
          "details": "- for Loops\nFor loops are used to iterate and loop through different conditions. You can define for loops only inside a function or function modifier, similar to if/else statements.\nFor loop is defined by the keyword `for`. It takes three parameters, two of which are optional and one required. The parameters are seperated by semi-colon. The first parameter is optional, where variables can be initialized. \nThe second parameter is a condition that belongs to the data type boolean. If this condition fails, the loop will terminate. The third parameter is also optional and can be used for incrementing and decrementing values or altering \nthem as needed. Anything can be done in the optional parameters - for example, in the first parameter we can do operations instead of initializing variables, and in the third parameter we can initialize variables or do other operations.\n\n** Working of for loop\nThe compiler will execute the first parameter of the for loop only once. It will then check the condition and, if it's true, execute the body of the for loop. After executing the third parameter, it will check the condition again. \nThis process repeats until the condition is false.\n\nLoops usually have three parameters, with the first parameter being executed only once at the start of the loop, the second parameter being the condition which is validated for the whole iteration of the loop, and the third parameter \nbeing executed for every iteration except the first iteration. If the condition inside the loop is always true, however, the loop will become an infinite loop and the program will crash.\n\nsyntax of the for loop \n```solidity\nfor(first parameter;second parameter(condition);third parameter){\n  body of the for loop\n}\n```\n\nAn example of using for loop in solidity\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.5;\n\ncontract Loops {\n    uint public sum = 0;\n\n    function Summation(uint n) public { // this function will do summation till n and add it to the variable sum\n        for (uint i = 0; i <= n; i++) {// for loop is used for iterating till n\n            sum += i; \n        }\n    }\n}\n\n```\nThe value of the `sum` variable is initially set to zero. When the `Summation` function is called with any positive integer as an argument, the for loop starts executing. The value of `i` is set to zero and the compiler \nchecks for the condition `i<=n`. If that condition is true, it will execute the body and then execute the third parameter (`i++`). It will then check the condition again to see if it is true. If so, the process will repeat. \nThe loop will only terminate if the condition is not met, which in this case is when `i>n`. Upon completion of the loop, we should get a sum that is equal to the summation of 0 to n.\n\n- while loop \nWhile loops are very similar to `for` loops in that they can be used for iteration. The main difference between the two types of loops is that while loops only take one parameter instead of three. The parameter passed into a while loop is a condition. \nIf that condition is not met, the while loop will terminate. The while loop is defined using the keyword `while`. The while loop will continue to execute until the condition is true. However, if the given condition is always true, \nit will become an infinite loop and the program will crash.\n\nsyntax for while loop\n```solidity\nwhile(condition){\n//body of while loop\n}\n```\nAn example of using while loop in solidity\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.5;\n\ncontract Loops {\n    uint public evensum = 0;\n\n    function sumEven(uint n) public {// this function will do summation of even numbers till n\n        uint i = 0;\n        while (i <= n) {  // while loop is used for iteration\n            if (i % 2 == 0) sum += i; // if statement for filtering even numbers till n\n            i++;\n        }\n    }\n}\n\n```\nIn the code snippet above, we have initialized a variable called `evensum` with a value of zero. The function `sumEven` is called with a positive integer, and \nif the condition `i<=n` is true, the while loop will start executing. The loop will continue until the condition is no longer true - in this case, when `i>n`. \nThis code results in the sum of all even numbers from 0 to n.\n\n- Do-While loop\nDo while loops are completely similar to while loop the main difference is the do while loop is executed atleast one time. Do-while loop is executed once for even false condition.\nsyntax for do while loop\n```solidity\ndo{\n  body of the do while loop\n}while(condition); // semi-colon is necessary\n\n```\nExample showing how to use do while loop.\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.5;\n\ncontract Loops {\n    uint public i = 0;\n\n    function doWhile() public {\n        do { // do while loop is used for iteration\n            i++;\n        } while (1 > 2); // false condition\n    }\n}\n\n```\nIn the above code, we have initialized `i=0`. When the function `doWhile` gets called, it executes the do-while loop. Even though the condition `1>2` is false, the loop will execute for at least one time, \nmeaning the value of `i` will be one when the function is called once. If the function is called `n` times, the loop will execute `n` times and thus the value of `i` will be `n`.\nWe have used a false condition to demonstrate how do-while loops work.\n\nIn general, it's best to minimize the use of loops in Solidity code in order to reduce gas fees. By avoiding loops, you can save a lot of gas because it prevents computationally-heavy operations.\n"
        },
        {
          "title": "Break, Continue and return keywords",
          "shortTitle": "Keywords",
          "key": "keywords",
          "details": "- Break\nBreak is a keyword which is used to break or terminate the running loop. It is a very useful keyword. In some situation we need to terminate the loop after a certain condition is met in that case we may use\n`break` keyword. Break keyword is used inside loops mostly with if/else statements. When compiler encounters break keyword it jumps out of the loop.\n\nexample showing the usage of break keyword\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.5;\n\ncontract Keywords {\n    uint[] numbers = [1, 2, 3, 4, 5];\n    event elementcheck(string message);\n\n    function checkNumber(uint n) public {\n        for (uint i = 0; i < n; i++) {\n            if (numbers[i] == n) {\n                emit elementcheck(\"element is found\");\n                break;\n            }\n        }\n    }\n}\n\n```\nIn the code snippet provided, `numbers` is an array of unsigned integers. If `checkNumber` is called with a positive number as an argument, the for loop will be executed and the if condition will validate the condition `numbers[i]==n`.\nIf that condition is satisfied,  the event will be emitted and the loop will be terminated using the break keyword.\n\n- Continue\nThe `continue` keyword is used to skip an iteration of a loop. In some cases, we need to skip an iteration of the loop when certain conditions are met. If the compiler encounters the `continue` keyword, it will jump to \nthe next iteration of the loop. This means that the control is transferred to the loop check condition. If the condition is true, the next iteration starts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.5;\n\nexample showing the usage of continue keyword\ncontract Keywords {\n    uint public sumeven = 0;\n\n    function summationOfEven(uint n) public {\n        // this function will sum even numbers from one to n\n        for (uint i = 0; i <= n; i++) {\n            if (i % 2 != 0) {\n                continue; // continue keyword helps skipping the odd numbers in this case\n            } else {\n                sumeven += i;\n            }\n        }\n    }\n\n    function reset() public {\n        // rests the value of sumeven to zero\n        sumeven = 0;\n    }\n}\n\n```\nIn the code snippet above, we have initialized `sumeven=0`. When the function `summationOfEven` is called with a positive integer n, the for loop is executed. If the condition `i%2!=0` is satisfied, \nthe keyword `continue` will transfer control to the loop check condition and start the next iteration. In this case, `continue` helps us to skip iterations of odd numbers.\n\n- Return \nReturn is a keyword which is used to return values/objects from a function. Whenever `return` is called the function will stop execution and return the value provided in the return statement.\nWe can return values from a function in two ways: One way is to normally return the value using the `return` keyword. Another way is to define a return variable and assign the return value to that\nvariable. The function `add` below defines a return variable `sum`. \n\nTherefore, we can return the value by just assigning the value to the sum as shown in the below snippet.\n```solidity\nfunction1(uint x)public returns(uint){\n  return x%2; returning using the return keyword\n}\n\nfunction2(uint y)public returns(uint answer){\n  answer = y%2; // returning the value by assigning return variable answer\n}\n\n```\nIn the above snippet both the functions performs same operation when an argument is passed to but they are returning values it in different ways.\n\nExample of using return keyword \n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.5;\n\ncontract Keywords {\n    function sum(uint a, uint b) public pure returns (uint, uint, uint, uint) {\n        return (a + b, b % a, a % b, a * b);\n    }\n}\n```\n"
        },
        {
          "title": "Internal and External function calls",
          "shortTitle": "Function calls",
          "key": "function-calls",
          "details": "- Internal function calls\nInternal function calls are function calls that happen inside the contract. You can do an internal function call by directly using the function's identifier. Recursive calling also counts as an internal function call.\nThese function calls are translated into simple jumps inside the EVM. This has the effect that the current memory is not cleared, i.e. passing memory references to internally-called functions is very efficient. \nYou can use the function's identifier to do an internal function call, no matter where the function is defined. As long as it's defined in the contract, the internal function call will take place. \nYou can call internal functions at any point in your code - for example, you could use them as other function's arguments, or inside if/else statements.\n\nexample of an internally called function is shown below\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.5;\n\ncontract FunctionCall {\n    uint public addition = add(1, 2);\n    uint public product = multiply(add(2, 3), add(2, 1));\n\n    function add(uint a, uint b) public pure returns (uint output) {\n        output = a + b;\n    }\n\n    function multiply(uint a, uint b) public pure returns (uint) {\n        return a * b;\n    }\n\n    function validate() public {\n        if (add(1, 2) <= multiply(1, 3)) {\n            addition = 100;\n        }\n    }\n}\n\n```\nIn the snippet above, we make four internal function calls. The first call is `add(1,2)` and the second and third calls are made within the argument of the function call `product`.\n\n\n- External function calls\nExternal function calls are basically function calls to other contracts. In order to make an external function call, the parent contract should have defined the object of the callable contract and the \ndeployed address of the callable contract should be assigned to the created contract object. External function calls can be made using `object.functionIdentifier` - for example `g.send(8)`, where `g` is the \nobject of the callable contract and `send` is a function of that contract. For error handling during external calls, we use try/catch statements.\n\nexample of an external call is shown below\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.5;\n\ncontract CallerContract {\n    ExternalContract call;\n\n    function set(ExternalContract addr) external {\n        call = addr;// setting the contract object\n    }\n\n    function callSend(address payable addr) public {// address should be payable\n        call.send(addr);\n    }\n}\n\ncontract ExternalContract {\n    function send(address payable addr) external payable {\n        (bool sucess, ) = addr.call{value: 100}(\"\"); //sending 100 wei\n        require(sucess, \"transaction failed\"); \n    }\n\n    receive() external payable {}\n}\n\n```\nIn the code snippet above, we are calling the `send` function in the `ExternalContract` using the `CallerContract`. To do this, we first create a contract object of `ExternalContract` by its deployed address. \nWe then make an external call, setting the deployed address to the contract object `call`. The `call.send` function will send ether (in wei) to the address provided in the argument. However, before making the external call, \nwe need to make sure that the `ExternalContract` has some ether in it, so that it can send ether. Hence, we send ether to the `ExternalContract` before making the external call. The `ExternalContract` should have ether more \nthan the sending value i.e, ether should be more than 100 wei in this case. \n"
        }
      ],
      "questions": [
        {
          "uuid": "1e754d66-092a-438f-b75e-8fc637f6cee9",
          "type": "SingleChoice",
          "content": "What will happen if we declared `else` statement without any if statement?",
          "hint": "Else statement",
          "explanation": "Else statement can be defined only when the `if` statement is defined prior to it and they should be continuous i.e, no codes should lie between them.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "decision-making"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Compiler checks for the condition in the else statement",
              "key": "A"
            },
            {
              "content": "It will be executed",
              "key": "B"
            },
            {
              "content": "Error message will appear",
              "key": "C"
            },
            {
              "content": "Nothing will happen",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d3983125-28ed-4af6-857e-7c3dc9ed136a",
          "type": "MultipleChoice",
          "content": "Which of the following is/are correct?",
          "hint": "noHint",
          "explanation": "We can have multiple `if` statements continuosly but only one else statement after a single or multiple `if` statement.",
          "answerKeys": [
            "A",
            "D"
          ],
          "subTopics": [
            "decision-making"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "We can have multiple `if` statements continously",
              "key": "A"
            },
            {
              "content": "We can have only one `if` statement continuously",
              "key": "B"
            },
            {
              "content": "We can have multiple `else` statement under `if` statements continously",
              "key": "C"
            },
            {
              "content": "We can have only one `else` statement under `if` statements continuously",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "86e9b299-6751-4ed5-adf8-d1af7fe2b2ab",
          "type": "SingleChoice",
          "content": "Can we define `else if` block in Solidity?",
          "hint": "Doesn't exist",
          "explanation": "Else if doesn't exist in solidity. `Else if` is also a statement like `if` but it will be executed only if all of the preceding `if` or `else if` statements in the code block are false. Else if do exist in other programming langiages like c,c++, JavaScript.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "decision-making"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Else if block can be defined but only inside the struct",
              "key": "A"
            },
            {
              "content": "Else if block doesn't exist in Solidity so we can't define it",
              "key": "B"
            },
            {
              "content": "Else if can be defined but only above the `if` block",
              "key": "C"
            },
            {
              "content": "Else if can be defined but only below the `else` block",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7eb527f6-5464-419c-a459-7806e4021efc",
          "type": "SingleChoice",
          "content": "Is it possible to convert non-boolean to boolean in solidity example `if(1)`?",
          "hint": "Boolean",
          "explanation": "We cannot do type conversion from non-boolean to boolean in solidity",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "decision-making"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "No",
              "key": "A"
            },
            {
              "content": "Yes",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "e42f5064-acfd-400a-9c6d-87f4d28e0c8f",
          "type": "MultipleChoice",
          "content": "What is the datatype inside the paranthesis of an `if` statement?",
          "hint": "noHint",
          "explanation": "The paranthesis in if statement contains a condition so the data type should be either true or false hence it is boolean value.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "decision-making"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Int",
              "key": "A"
            },
            {
              "content": "String",
              "key": "B"
            },
            {
              "content": "Boolean",
              "key": "C"
            },
            {
              "content": "Address",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "5bfe6b20-4efc-48f8-a981-49d86534ff19",
          "title": "title",
          "shortTitle": "short title",
          "type": "YoutubeVideo",
          "url": "url",
          "subTopics": [
            "decision-making"
          ],
          "details": "details\n"
        }
      ],
      "summaries": [
        {
          "title": "Control Structure",
          "shortTitle": "Control Structure",
          "key": "decision-making",
          "details": "- if/else\n- for\n- while\n- do\n- break,continue\n- return\n"
        },
        {
          "title": "Function Calls",
          "shortTitle": "Function Calls",
          "key": "func-call",
          "details": "- Internal Function Calls\n- External Function Calls\n"
        }
      ]
    },
    {
      "title": "Object-Oriented Programming (OOP) Concepts in Solidity",
      "key": "oops",
      "details": "Solidity is an object-oriented programming language . This chapters explains how solidity implements various object oriented paradigms like abstraction , inheritance , polymorphism , encapsulation etc.",
      "order": 4,
      "explanations": [
        {
          "title": "OOPS Intro",
          "shortTitle": "OOPS Intro",
          "key": "oops-intro",
          "details": "A programming paradigm called OOP (object-oriented programming) is based on the idea that objects can contain data \nand code. Data can be found in the form of attributes or properties, and code can be found in the form of methods.\n\nSolidity is used as an object-oriented programming language to implement smart contracts on different blockchain \nplatforms, most notably Ethereum. Here in this section, we will discuss various concepts, i.e., belonging to OOPs \nin contex of Solidity and vice versa.\n"
        },
        {
          "title": "Understanding Encapsulation in Solidity",
          "shortTitle": "Encapsulation",
          "key": "encapsulation",
          "details": "Encapsulation is the mechanism of manipulating the scope of variables and functions, i.e.; it prevents the variable from being \naccessed outside the scope.\n\nSyntax\n```solidity\n// Unlike in Java,\n// the data type comes before the visibility modifier in Solidity\nuint public num;\n// <data type> <visibility> <variale name>;\n```\n\nState variables only have three possible visibility modifiers; public, internal, or private, whereas a function's \nvisibility can be set to external, public, internal, or private. State variables are not covered by the keyword \nexternal.\n\n```solidity\n  pragma solidity ^0.5.0;\n\n  contract Parent {\n    uint num = 10;\n    uint public public_num = 100;\n    uint internal internal_num = 200;\n\n    // uint external external_num = 300;\n    // ParserError: Expected identifier but got 'external'\n    // uint external external_num = 300;\n    //      ^------^\n\n    // Remark: We can't declare external variable/state in solidty.\n\n    uint private private_num = 400;\n\n    function get_public() public view returns(uint){\n        return public_num;\n    }\n\n    function get_private() private view returns(uint){\n        return private_num;\n    }\n\n    function get_internal() internal view returns(uint){\n        return internal_num;\n    }\n\n    function get_external() external view returns(uint){\n        uint num1 = get_private();\n        return num1;\n    }\n  }\n```\n### Visibility Modifiers\n- Public objects can be accessed from outside, inside of the contract, as well as via message also. One need to \n  declare a method as public during declaration. While creation of public variable getter function are created. As \n  setter function is not created for the same external functions can't modify the variable.     \n- Internal objects can only be accessed by internal or derived methods. External methods can't access the same. \n- External objects can be accessed by external contract but not inside the same contract instance. These can not \n  be inherited. \n- Private is most restricted object scope. It can only be accessed internally from the current contract instance. One\n  can not access the same by derived methods. A function or variable that has its visibility set to private is not \n  rendered invisible on the blockchain. It merely limits its access to function covered by the contract.\n\n```solidity\n  contract Child is Parent{\n\n  // uint c = get_private();\n  // DeclarationError: Undeclared identifier.\n  // uint c = get_private();\n  //          ^---------^\n\n  // Remark: From the above error, it is understood that the private functions are \n  //         not accessible in the child class. \n\n\n  // uint d = get_external();\n  // DeclarationError: Undeclared identifier. Did you mean \"get_internal\"?\n  // uint d = get_external();\n  //          ^----------^\n\n  // Remark: From the above error, we learned that the external functions could be \n  //         accessed after deployment, not even in the child class.\n\n    function add_private() private view returns(uint){\n        uint a = get_public();\n        uint b = get_internal();\n        return a+b;\n    }\n\n    function add_public() public view returns(uint){\n        uint c = add_private();\n        // accessing the function within the contract Child\n        return c;\n    }\n\n    function square_internal() internal view returns(uint){\n        return num**2;\n    }\n\n  }\n```\n```solidity\n  contract Caller { \n\n    Child ch = new Child();\n  // creating Child contract object\n\n  // uint e = ch.add_private();\n  // TypeError: Member \"add_private\" not found or not visible after argument-dependent lookup in contract Child.\n  //     uint e = ch.add_private();\n  //             ^------------^\n\n  // uint f = ch.square_internal();\n  // TypeError: Member \"square_internal\" not found or not visible after argument-dependent lookup in contract Child.\n  // uint f = ch.square_internal();\n  //         ^----------------^\n\n  // Remark: i. From the above two errors, we learned that the private function is not visible outside of the\n  //              contract through object call also.\n  //         ii. Internal functions are not accessible out side the contract inheritance hierarchy.   \n\n    function get_external() public view returns(uint){\n        return ch.get_external();\n        // external function can be accessed outside of the contract i.e., here we access the same through ch object. \n    }// returns 400\n\n    function add_public() public view returns(uint){\n        return ch.add_public();\n        // public functions can be accessed every where. \n    }// returns 300  \n  }\n```\n"
        },
        {
          "title": "Inheritance in Solidity",
          "shortTitle": "Inheritance",
          "key": "inheritance",
          "details": "Inheritance is a way to expand usefulness of a contract by defining multiple related contracts through parent-child \nrelationship.  \n\nThe contract having no incoming inheritance or from which other contrcats inherit features is known as Base contract. \nWhile the contract having atleast one incoming inheritance or which inherits features are known as Derived contract. \n\nSyntax\n```solidity\n  contract <Derived Contract Name> is <Base Contract Name>{\n  }\n```\nAll non-private members, including state variables and internal methods, are accessible to derived contracts. However, \nusing this is prohibited. Function calls made with super give preference to the majority of derived contracts when \nthere are multiple inheritances. Function overriding is permitted as long as the function signature is maintained. \n\nThe compilation will fail if the output parameters are different. The super keyword or the super contract name can \nbe used to invoke a super contract's function. \n\nSoility supports four types of Inheritance. \n\n#### Single Inheritance\nIn Single or single-level inheritance, the functions, and variables of one base contract are inherited to only one \nderived contract.\n\n```solidity\n  pragma solidity ^0.5.0;\n  /* Graph of inheritance\n      Parent\n        |\n      Child\n  */\n\n\n  contract Parent{\n      uint internal num;\n\n      function addition(uint a, uint b) external {\n          num = a+b;\n      }\n  }\n\n  contract Child is Parent{\n      // inheriting from parent contract i.e., Parent.\n      function get_sum() public view returns(uint){\n          return num;\n      }\n  }\n\n  contract Caller{\n      Child ch = new Child();\n\n      function setNum(uint a, uint b) public returns(uint){\n          //setting num value\n          ch.addition(a,b);\n          return ch.get_sum();\n      }\n  }\n```\n\n#### Multi-level Inheritance\nThe multi-level inheritance includes the involvement of at least two or more than two contracts. One contract inherits \nthe features from a parent contract and the newly created sub-contract becomes the base contract for another new contract.\n```solidity\n  pragma solidity ^0.5.0;\n\n  /* Graph of inheritance\n      SuperParent\n          | \n      Parent\n          | \n      SubParent \n          |\n      Child\n  */\n  contract SuperParent{\n      uint internal num;\n      uint internal b = 20;\n      uint internal a = 10;\n\n      function add(uint n, uint m) external {\n          num = n+m;\n      }\n  }\n\n  contract Parent is SuperParent{\n      // inheriting from parent contract i.e., SuperParent.\n      function multiply() external {\n          num = num*b; // num = num*20\n      }\n  }\n\n  contract SubParent is Parent{\n      // inheriting from parent contract i.e., Parent.\n      function subtract() external {\n          num = num-a; // num = num-10\n      }\n  }\n\n  contract Child is SubParent{\n      // inheriting from parent contract i.e., SubParent.\n      function get_num() public view returns(uint){\n          return num;\n      }\n  }\n\n  contract Caller{\n      Child ch = new Child();\n      function setNum(uint a, uint b) public returns(uint){\n          //setting num value\n          // for input of a=100, b=200\n          ch.add(a,b);//num=300\n          ch.subtract();//num=290\n          ch.multiply();//num=5800\n          return ch.get_num();\n      }//returns 5800 for input of (100,200)\n  }\n\n```\n\n#### Hierarchical Inheritance\nIn Hierarchical Inheritance single contract acts as a base contract for multiple derived contracts. It is mostly \nused when a common functionality is used in different places.\n\n```solidity\n  pragma solidity ^0.8.0;\n\n  /* Graph of inheritance\n      SuperParent\n      /           \\\n    Parent1       Parent2\n  /       \\        /\n  Child1  Child2  Child3\n\n  */\n\n  contract SuperParent {\n      function find() public pure virtual returns (string memory) {\n          return \"SuperParent\";\n      }\n  }\n\n  contract Parent1 is SuperParent {\n      // Override SuperParent.find()\n      function find() public pure virtual override returns (string memory) {\n          return \"Parent1\";\n      }\n  }\n\n  contract Parent2 is SuperParent {\n      // Override SuperParent.find()\n      function find() public pure virtual override returns (string memory) {\n          return \"Parent2\";\n      }\n  }\n\n  // When a function defined multiple times in different contracts is called, parent contracts \n  // are searched from right to left and in depth-first order.\n\n  contract Child3 is Parent2, Parent1 {\n      // Child3.find() returns \"Parent1\"\n      // since Parent1 is the right most parent contract with function find()\n      function find() public pure override(Parent2, Parent1) returns (string memory) {\n          return super.find();\n      }\n  }\n\n  contract Child2 is Parent1, Parent2 {\n      // Child2.find() returns \"Parent2\"\n      // since Parent2 is the right most parent contract with function find()\n      function find() public pure override(Parent1, Parent2) returns (string memory) {\n          return super.find();\n      }\n  }\n\n  // Inheritance must be sorted from \"most base-like\" to \"most derived.\"\n  // Changing the order of SuperParent and Parent1 will result in a compilation error.\n  contract Child1 is SuperParent, Parent1 {\n      function find() public pure override(SuperParent, Parent1) returns (string memory) {\n          return super.find();\n      }\n\n  }\n\n```    \n#### Multiple Inheritance\nIn Multiple Inheritance a single contract can be inherited from one or more contracts.\n\n```solidity\n  pragma solidity ^0.8.0;\n\n  /* Graph of inheritance\n    Parent1   Parent2\n          \\  /\n          Child\n  */\n\n  contract Parent1{\n      uint internal num;\n      function sum(uint n, uint m) external{\n          num = n+m;\n      }\n  }\n\n  contract Parent2{\n      string name;\n      function assignName(string memory nm) external{\n          name = nm;\n      }\n  }\n\n  contract Child is Parent1, Parent2{\n      // inheriting from both parent contracts i.e., Parent1 & Parent2.\n      function getNum() public view returns(uint){\n          return num;\n      }\n      function getName() public view returns(string memory){\n          return name;\n      }\n  }\n\n  contract Caller{\n      Child ch = new Child();\n      function getNumName(uint n, uint m) public returns(uint, string memory){\n          // For n=100, m=200\n          ch.sum(n,m);// num=300\n          ch.assignName(\"DoDAO\");// name=\"DoDAO\"\n          return (ch.getNum(),ch.getName());\n      }// returns (300,\"DoDAO\")\n  }\n```\nC3 Linearization, also known as Method Resolution Order (MRO), is a technique that Solidity uses to enforce a \nparticular order in graphs of base contracts. The contract level declaration order determines the order of \nexecution. The order in which you call/pass arguments up from the constructor's signature has no bearing on it.\n"
        },
        {
          "title": "Polymorphism in Solidity",
          "shortTitle": "Polymorphism",
          "key": "polymorphism",
          "details": "Polymorphism describes the concept of being able to access objects of different types through the same interface. This interface can be implemented independently by each type.\n\n### Function polymorphism\nFunction polymorphism refers to expressing multiple functions within the same contract or inheriting contracts with \nthe same name. The parameter data types differ between functions. They also alter the number of parameters. Return \ntypes are not considered in a meeting to define valid function signatures for polymorphism; function declaration \ncannot be overloaded by functions that differ only in return type. Method overloading is another term for function \npolymorphism.\n\n```solidity\n  pragma solidity ^0.5.0;\n\n  contract methodOverloading {\n\n      // function to get value of \n      // the unsigned integer variable \n      function getData(uint _n) public pure returns(uint){\n          return _n;\n      }\n\n      // Function to get value \n      // of the string variable\n      function getData(string memory _str) public pure returns(string memory){\n          return _str;\n      }\n  }\n```\n### Contract polymorphism\nContract polymorphism refers to using multiple contract instances interchangeably when the contracts are related by \ninheritance. Contract polymorphism allows using parent contract instances to call the child contract function.\n\n```solidity\n  pragma solidity ^0.5.0;\n\n  contract parent{  \n    uint internal sum;\n\n    // Function to set the value of\n    // internal state variable sum\n    function setValue(uint _num1, uint _num2) public {\n      sum = _num1 + _num2;\n    }\n\n    // Function to return a value 10\n    function getValue() public view returns(uint) {\n      return 10;\n    }\n  }\n\n  contract child is parent{\n\n    // Function getValue overloaded\n    // to return internal state\n    // variable sum defined in the\n    // parent contract\n    function getValue() public view returns(uint) {\n      return sum;\n    }\n  }\n\n  // Defining calling contract\n  contract ContractPolymorphism {\n\n    // Creating object\n    parent pc = new child();\n\n    // Function to set values\n    // of 2 unsigned integers\n    function getInput(uint _num1, uint _num2) public {\n      pc.setValue(_num1, _num2);\n    }\n\n    // Function to get value of\n    // internal state variable sum\n    function getSum() public view returns(uint){\n      return pc.getValue();\n    }\n  }\n```\n"
        },
        {
          "title": "Abstraction in Solidity",
          "shortTitle": "Abstraction",
          "key": "abstraction",
          "details": "Abstraction allows the user to build more complex logic on top of the provided abstraction(abstract contracts) without having to understand \nor even consider all the hidden complexity.\n\n### Abstract Contracts\nIn Solidity the contracts having at least one function that do not have its implementation or not provided arguments \nfor all the base contract constructors. One can also consider a contract to be abstract if we do not intend to \ncreate one directly. An abstract contract can be declared using the abstract keyword. \n\n```solidity\n  pragma solidity ^0.4.19;\n\n  abstract contract Parent {\n      function sum(uint256 a, uint256 b) public returns (uint256);\n  }\n\n  contract Child is Parent {\n      function sum(uint256 a, uint256 b) public returns (uint256) { return a+b; }\n  }\n``` \nAbstract contracts are used as base contracts, allowing child contracts to inherit and use their functions. The abstract \ncontract defines the structure of the contract, and any derived contract inherited from it should provide an \nimplementation for the incomplete functions; if the derived contract does not provide an implementation for the \nincomplete functions, it will be marked as abstract as well. One cannot create an instance of an abstract contract.\n\n```solidity\n  // SPDX-License-Identifier: GPL-3.0\n  pragma solidity ^0.8.0;\n\n  // Creating an abstract contract\n  abstract contract AbstractContract {\n      uint256 public num;\n      constructor(uint256 n ){\n          num = n;\n      }\n\n      function getNum() public virtual view returns (uint256){\n          return num;\n      }\n      function setNum(uint256 n) public virtual {}\n  }\n\n  // Child contract inheriting an abstract parent contract 'AbstractContract'\n  contract DerivedContract is AbstractContract {\n      string public name;\n      constructor(string memory nm  ,uint256  n) AbstractContract(n) {\n        name = nm;\n      }\n      function getName() public view returns (string memory){\n          return name;\n      }\n      // Calling functions inherited\n    // from abstract contract\n      function getNum() public override virtual view returns (uint256){\n          return 67;\n      }\n    // Defining functions inherited from abstract parent contract\n      function setNum(uint256 n ) public override virtual {\n          num = n;\n      }\n  }\n\n  contract Caller{\n      DerivedContract dc = new DerivedContract(\"DoDAO\",70);\n      function getData() public view returns(string memory, uint){\n          return (dc.getName(), dc.getNum());\n      }// returns (\"DoDAO\", 67)\n\n  }\n```\n### Interfaces\nInterfaces are similar to abstract contracts, which are created by using an interface keyword. It does not have any \ndefinitions, state variables, constructors, or functions with implementations; instead, they only contain function \ndeclarations, implying that functions in interfaces do not have any statements. They can inherit from other interfaces \nbut not from other contracts. An interface may contain enums and structs that can be accessed using the interface \nname dot notation.Interface functions can only be of the external type.    \n\n```solidity\n  // SPDX-License-Identifier: GPL-3.0\n  pragma solidity 0.4.19;\n\n  // Creating an interface contract\n  interface interfaceContract {\n    function getName(string name) public view returns(string memory);\n    function mul(uint n,uint m) public view returns(uint);\n  }\n\n  // Child contract inheriting\n  // an interface parent\n  // contract 'interfaceContract'\n  contract derivedContract is interfaceContract{\n    // Defining functions inherited from interface parent contract\n    function mul(uint n,uint m) public view returns(uint){\n      return n*m;\n    }\n    function getName(string name) public view returns(string memory){\n      return \"DoDAO\";\n    }\n\n  }\n\n  contract Caller{\n    // Creating an instance of\n    // an interface contract\n    interfaceContract obj;\n\n    // Creating an object of\n    // child contract\n    function call() public{\n      obj = new derivedContract();\n    }\n\n    // Calling functions inherited\n    // from interface contract\n    function getValues() public view returns(uint){\n      uint n = obj.mul(10, 20);\n      obj.getName(\"Interface\");\n      return n;\n    }// returns 200\n  }\n```\n"
        },
        {
          "title": "Libraries in Solidity",
          "shortTitle": "Library",
          "key": "library",
          "details": "Libraries are similar to Contracts in that they are intended to be reused. A Library is a collection of functions \nthat other contracts can use.\n\n### Creating library**\n\n```solidity\nlibrary <libraryName> {\n    // block of code\n}\n```\n\nIn Solidity, a library is a stateless entity. Unlike smart contracts, state variables cannot be defined in a library; \nlibrary functions are not permitted to alter or modify the state of a smart contract. It does not change the state of \nthe contract; calling a library function consumes no gas. Hence it can only implement pure or view functions. An \nexternal scope cannot access a library. The other contracts can call them, but they are not accessible from outside \nthe deployment.\n\nLet have a look upon how to use libraries in solidity. \n\n### Deploying library\n\n```solidity\n  // import <libraryName> from “./library-file.sol”;\n\n  // Solidity program to demonstrate \n  // how to deploy a library\n  pragma solidity ^0.5.0;\n\n  // Defining Library\n  library LibraryExample {\n      function pow(uint a, uint b) public view returns (uint, address) {\n          return (a ** b, address(this));\n      }\n  }\n\n  // library deployed with for keyword\n\n  contract LibExample {\n\n    // Deploying library using \n    // \"for\" keyword\n    using LibraryExample for unit;\n    address owner = address(this);\n\n    function getPow(uint num1, uint num2) public view returns (uint, address) {\n        return num1.pow(num2);\n    }\n  }\n\n  // library can be used without for keyword\n\n  contract LibExample2{\n\n    // Deploying library without using \n    // \"for\" keyword\n\n    function getPow(uint num1, uint num2) public view returns (uint, address) {\n          return LibraryExample.pow(num1, num2);\n    }\n  }\n```\n\nThe library is an independent entity that can not inherit any other library or contract. No other entity/library/contract \ncan inherit a library. A library is unable to provide fallback or payable functions.\n"
        }
      ],
      "questions": [
        {
          "uuid": "bd6b88a6-ea79-4745-8a9e-3fcccf36a7ab",
          "type": "SingleChoice",
          "content": "The feature in object-oriented programming that allows the same operation to be carried out differently, depending on the object, is",
          "hint": "noHint",
          "explanation": "Polymorphism is an ability to process data in more than one form.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "polymorphism"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Inheritance",
              "key": "A"
            },
            {
              "content": "Polymorphism",
              "key": "B"
            },
            {
              "content": "Overriding",
              "key": "C"
            },
            {
              "content": "Overloading",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f02bba8b-1836-4052-abdb-cb58f6f30554",
          "type": "SingleChoice",
          "content": "Consider the following two statements related to inheritance * (a)A publicly derived class is a subtype of its base class. * (b)Inheritance provides for code reuse.",
          "hint": "noHint",
          "explanation": "A publicly derived class is a subtype of its base class and Inheritance provides for code reuse.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "inheritance"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Both the statements (a) and (b) are correct.",
              "key": "A"
            },
            {
              "content": "Statements (a) is correct and statement (b) is incorrect.",
              "key": "B"
            },
            {
              "content": "Statements (a) is incorrect and statement (b) is correct.",
              "key": "C"
            },
            {
              "content": "Both the statements (a) and (b) are incorrect.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "4c08743a-6381-4508-9575-bd315a9dd1d0",
          "type": "SingleChoice",
          "content": "Abstraction and encapsulation are fundamental principles that underlie the object oriented approach to software development. What can you say about the following two statements ? * I. Abstraction talks about bundling data and methods together in one contract. * II. Encapsulation allows us to consider complex ideas while ignoring irrelevant detail that would confuse us.",
          "hint": "noHint",
          "explanation": "Encapsulation allows us to focus on what something does without considering the complexities of how it works. Abstraction allows us to consider complex ideas while ignoring irrelevant detail that would confuse us. So, option (A) is correct.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "inheritance",
            "encapsulation"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Neither I nor II is correct.",
              "key": "A"
            },
            {
              "content": "Both I and II are correct.",
              "key": "B"
            },
            {
              "content": "Only I is correct.",
              "key": "C"
            },
            {
              "content": "Only II is correct.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ab278067-188b-4087-8dee-6b64e300aaaf",
          "type": "SingleChoice",
          "content": "Which one of the following are essential features of object oriented language? * A. Abstraction and encapsulation * B. Strictly-typed * C. Type-safe property coupled with sub-type rule * D. Polymorphism in the presence of inheritance",
          "hint": "noHint",
          "explanation": "Abstraction, Encapsulation, Polymorphism and Inheritance are the essential features of a OOP Language.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "inheritance",
            "encapsulation",
            "polymorphism"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "A and B only",
              "key": "A"
            },
            {
              "content": "A, D and B only",
              "key": "B"
            },
            {
              "content": "A and D only",
              "key": "C"
            },
            {
              "content": "A, C and B only",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "46a72ca3-f513-417c-bf3e-099c9610f7e9",
          "type": "SingleChoice",
          "content": "Which objects can only be accessed internally from the current contract instances?",
          "hint": "noHint",
          "explanation": "- Private properties can only be accessed internally from the current contract instances.\n- Internal properties can be accessed from child contracts, but not from external contracts.\n- Private properties can't be accessed even from child contracts.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "encapsulation"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "public",
              "key": "A"
            },
            {
              "content": "private",
              "key": "B"
            },
            {
              "content": "internal",
              "key": "C"
            },
            {
              "content": "external",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "5d6b3cca-0774-4bea-90bc-c0fb6bb0c0c0",
          "type": "SingleChoice",
          "content": "Which of the following does not belong to state visibility?",
          "hint": "noHint",
          "explanation": "- Values of state variables are permanently stored in the contract storage. Each function has its own scope, and state variables should always be defined outside of that scope.\n- Only functions can be marked external. External functions are part of the contract interface and can be called from other contracts and transactions. They can't be called internally. This leads to external functions being cheaper to execute.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "encapsulation"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "Public",
              "key": "A"
            },
            {
              "content": "Internal",
              "key": "B"
            },
            {
              "content": "Private",
              "key": "C"
            },
            {
              "content": "External",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6fdde9f4-9853-413c-a110-7c4ee6c8aabb",
          "type": "SingleChoice",
          "content": "The process of defining multiple contracts related to each other through parent-child relationships is called?",
          "hint": "noHint",
          "explanation": "- Inheritance is the process of defining multiple contracts that are related to each other through parent-child relationships. \n- The contract that is inherited is called the parent contract and the contract that inherits is called the child contract.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "inheritance"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Abstraction",
              "key": "A"
            },
            {
              "content": "Encapsulation",
              "key": "B"
            },
            {
              "content": "Inheritance",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "79ff51fb-9703-44ea-bf0d-a092cea80e17",
          "type": "SingleChoice",
          "content": "Solidity uses to force a specific order in graphs of base contracts is known as",
          "hint": "noHint",
          "explanation": "- C3 linearization is consistent with three properties: a consistent extended precedence graph, preservation of local precedence order, and. fitting a monotonicity criterion\n- Solidity follows C3 Linearization.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "inheritance"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "C1 Linearization",
              "key": "A"
            },
            {
              "content": "Method Revolution Order",
              "key": "B"
            },
            {
              "content": "C3 Linearization",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "3c8b8711-b120-46db-9bc8-46d6fa292dae",
          "type": "SingleChoice",
          "content": "Which of the following inheritance does not belongs to solidity?",
          "hint": "noHint",
          "explanation": "- Hybrid inheritance is a combination of single, multiple inheritance and hierarchical inheritance.\n- There is no Hybrid inheritance concept avialable in solidity. \n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "inheritance"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "Single Inheritance",
              "key": "A"
            },
            {
              "content": "Hybrid Inheritance: A combination of single, multiple inheritance and hierarchical inheritance.",
              "key": "B"
            },
            {
              "content": "Hierarchical Inheritance: A parent has more than one child class/contract",
              "key": "C"
            },
            {
              "content": "Multiple Inheritance",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "0d4494ae-27cf-40d7-bb43-071a9c11833a",
          "type": "SingleChoice",
          "content": "Which of the following explain about Multi-level Inheritance?",
          "hint": "noHint",
          "explanation": "Multi-level inheritance is similar to single inheritance, but it has levels of the relationship between the parent and the child.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "inheritance"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "A single contract can be inherited from one or more contracts.",
              "key": "A"
            },
            {
              "content": "Single contract acts as a base contract for multiple derived contracts.",
              "key": "B"
            },
            {
              "content": "Multiple levels of the parent-child relationship.",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "672fcc59-0567-436f-8eaf-c43858082344",
          "type": "SingleChoice",
          "content": "Which of the following is a inbuilt library of solidity?",
          "hint": "noHint",
          "explanation": "Dapp-bin was created by Ethereum includes interesting and useful libraries like DoublyLinkedList, StringUtils, IterableMapping, etc.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "library"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Dapp-bin",
              "key": "A"
            },
            {
              "content": "Matplotlib",
              "key": "B"
            },
            {
              "content": "Seaborn",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ed3525c5-5e27-49b2-9975-7e421099e239",
          "type": "SingleChoice",
          "content": "Which of the below solidity keyword is used while importing library.",
          "hint": "noHint",
          "explanation": "- `for` keyword is used to attach library functions to any type\n-  `<libraryName> for <dataType>: libraryName is the name of the desired library to import, dataType is the variable type for which we want to access the library`\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "library"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "of",
              "key": "A"
            },
            {
              "content": "for",
              "key": "B"
            },
            {
              "content": "apply",
              "key": "C"
            },
            {
              "content": "match",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2233d367-dd48-40d5-aeac-44a3a606578d",
          "type": "SingleChoice",
          "content": "Which of the below property is incorrect about libraries in solidity?",
          "hint": "noHint",
          "explanation": "All the properties are correct regarding library in solidity.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "library"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It does not have state variables.",
              "key": "A"
            },
            {
              "content": "It can not inherit any element.",
              "key": "B"
            },
            {
              "content": "It can not be inherited",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "42152571-7564-440b-83c5-79cb91a6c4a7",
          "type": "SingleChoice",
          "content": "Choose the correct description about the popular solidity library OpenZeppelin.",
          "hint": "noHint",
          "explanation": "OpenZeppelin Contracts helps you minimize risk by using battle-tested libraries of smart contracts for Ethereum and other blockchains.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "library"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Includes many modular libraries that are very useful for implementation like ArrayUtils, Token, CrowdSale, Vesting, StringUtils, LinkedList, Wallet, etc.",
              "key": "A"
            },
            {
              "content": "Includes interesting and useful libraries like DoublyLinkedList, StringUtils, IterableMapping, etc.",
              "key": "B"
            },
            {
              "content": "Includes other supporting libraries are Roles, MerkleProof, ECDSA, Math, Address, SafeERC20, ERC165Checker, SafeMath, Arrays, etc which protects from overflow.",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "40d58c0b-7475-41f7-abf8-c9af2646f78b",
          "type": "SingleChoice",
          "content": "Choose the data type that can not be used in solidity library.",
          "hint": "noHint",
          "explanation": "Library in solidity can implement some data types like struct and enums which are user-defined, and constant variables that are stored in a stack of Ethereum, not in storage.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "encapsulation"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "struct",
              "key": "A"
            },
            {
              "content": "enums",
              "key": "B"
            },
            {
              "content": "constant variables",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "46bab6f7-0612-4b6d-9b09-3e3d8f4db9c4",
          "type": "SingleChoice",
          "content": "Which of the following can not be declared inside a library in solidity?",
          "hint": "noHint",
          "explanation": "Libraries do not have any storage thus it cannot hold state variables, fallback or payable functions also cannot be created inside the library as it cannot store ethers.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "encapsulation"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "state variable",
              "key": "A"
            },
            {
              "content": "fallback",
              "key": "B"
            },
            {
              "content": "None",
              "key": "C"
            },
            {
              "content": "Both A and B",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d608a41e-befd-4633-b74d-aef833e1f8e6",
          "type": "SingleChoice",
          "content": "Which type of functions can be called directly from outside of the library.",
          "hint": "noHint",
          "explanation": "Functions of the library can be called directly when they do not modify the state variables i.e. only pure and view functions can be called from outside of the library.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "library"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "pure",
              "key": "A"
            },
            {
              "content": "view",
              "key": "B"
            },
            {
              "content": "Both A and B",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "5112f0d8-19b8-4140-ae06-ae1309acd783",
          "type": "SingleChoice",
          "content": "Find the incorrect property about Interface.",
          "hint": "noHint",
          "explanation": "You can't put any state variables inside Interfaces, because interfaces define contracts which can be implemented in various ways. T",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "inheritance"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Interface can not have any function with implementation.",
              "key": "A"
            },
            {
              "content": "Functions of an interface can be only of type external.",
              "key": "B"
            },
            {
              "content": "Interface can not have constructor.",
              "key": "C"
            },
            {
              "content": "Interface can have state variables.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "3f034ef2-066b-404a-9a3b-dc0992e37d37",
          "type": "SingleChoice",
          "content": "Functions of Interface can be only of type",
          "hint": "noHint",
          "explanation": "Functions of Interface can be only of type external.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "inheritance"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "public",
              "key": "A"
            },
            {
              "content": "external",
              "key": "B"
            },
            {
              "content": "private",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "60a66ec6-4e7d-4791-986a-738c68363dee",
          "type": "SingleChoice",
          "content": "From where an interface can inherit?",
          "hint": "noHint",
          "explanation": "An interface can inherit from other interfaces, but they can’t inherit from other contracts.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "inheritance"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "other interface",
              "key": "A"
            },
            {
              "content": "other contract",
              "key": "B"
            },
            {
              "content": "Both A and B",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "3add6edb-45d2-45a5-ad44-0414d7aada76",
          "type": "SingleChoice",
          "content": "Which of the following data type can be used in an interface?",
          "hint": "noHint",
          "explanation": "An interface can have enum, structs which can be accessed using interface name dot notation.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "inheritance"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "enum",
              "key": "A"
            },
            {
              "content": "struct",
              "key": "B"
            },
            {
              "content": "Both A and B",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "c4b24502-802b-4cc1-a172-0737b32ccfeb",
          "type": "SingleChoice",
          "content": "Select the correct property regarding abstract contracts.",
          "hint": "noHint",
          "explanation": "- Abstract contracts are contracts that have at least one function without its implementation. \n- When we don’t intend to create a contract directly we can consider the contract to be abstract.\n- An instance of an abstract cannot be created.\n",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "inheritance"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "Abstract contracts are contracts that have at least one function without its implementation.",
              "key": "A"
            },
            {
              "content": "When we don’t intend to create a contract directly we can consider the contract to be abstract.",
              "key": "B"
            },
            {
              "content": "An instance of an abstract cannot be created.",
              "key": "C"
            },
            {
              "content": "All of these",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "41899c0d-e985-42b6-b532-34760b1d1d2b",
          "type": "SingleChoice",
          "content": "If the derived contract of an abstract contract is also not implementing the incomplete functions then that derived contract will also be marked as",
          "hint": "noHint",
          "explanation": "- The abstract contract defines the structure of the contract and any derived contract inherited from it should provide an implementation for the incomplete functions.\n- If the derived contract is also not implementing the incomplete functions then that derived contract will also be marked as abstract.\n",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "inheritance"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "interface",
              "key": "A"
            },
            {
              "content": "abstract",
              "key": "B"
            },
            {
              "content": "library",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "67c5c94c-42f8-4c65-a2dc-a7cdc121db6a",
          "type": "SingleChoice",
          "content": "Which of the following keyword is used to declare an abstract contract?",
          "hint": "noHint",
          "explanation": "An abstract contract is declared using the abstract keyword.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "inheritance"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "interface",
              "key": "A"
            },
            {
              "content": "library",
              "key": "B"
            },
            {
              "content": "abstract",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "4d443bb2-d84b-475e-8337-55ab3fcb4d33",
          "type": "SingleChoice",
          "content": "Which of the below statement is correct regarding constructor in solidity?",
          "hint": "noHint",
          "explanation": "Solidity provides a constructor declaration inside the smart contract and it invokes only once when the contract is deployed and is used to initialize the contract state.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "constructor"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "A constructor can be called multiple times.",
              "key": "A"
            },
            {
              "content": "A constructor can not accept arguments.",
              "key": "B"
            },
            {
              "content": "A constructor can be invoked only once.",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "60ad4e34-501c-4039-a3bb-da0a5730a52b",
          "type": "SingleChoice",
          "content": "Which of the following key word is used to declare a constructor?",
          "hint": "noHint",
          "explanation": "A Constructor is defined using a constructor keyword without any function name followed by an access modifier.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "constructor"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "pragma",
              "key": "A"
            },
            {
              "content": "abstract",
              "key": "B"
            },
            {
              "content": "interface",
              "key": "C"
            },
            {
              "content": "constructor",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8e9bf2dd-0481-4edf-88db-5dfad785f513",
          "type": "SingleChoice",
          "content": "Choose the correct statement from below options about constructor in solidity.",
          "hint": "noHint",
          "explanation": "- A parameter value can be defined at the run time in a constructor.\n- Constructor can also restrict the method call.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "constructor"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "A parameter value can be defined at the run time in a constructor.",
              "key": "A"
            },
            {
              "content": "A constructor can also restrict method call.",
              "key": "B"
            },
            {
              "content": "Both A and B",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2ad6f765-fb79-458e-841c-f1ae5cc4f9c1",
          "type": "SingleChoice",
          "content": "Ways of calling parent contract's constructor",
          "hint": "noHint",
          "explanation": "There are two ways of calling a parent contract’s constructor i.e. Direct Initialization and Indirect Initialization.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "constructor",
            "inheritance"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "Direct Initialization: This method is used to initialize the constructor of the parent class.",
              "key": "A"
            },
            {
              "content": "Indirect Initialization: By using Base(string(abi.encodePacked(_info, _info))) is done to initialize the constructor of the base class.",
              "key": "B"
            },
            {
              "content": "Both A and B",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6e67e159-1acf-4df7-95f7-be2e2ea61629",
          "type": "SingleChoice",
          "content": "If the child contract is not passing any parameter to the parent’s constructor the child contract will become",
          "hint": "noHint",
          "explanation": "If the child contract is not passing any parameter to the parent’s constructor the child contract will become an abstract contract.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "inheritance",
            "constructor"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "library",
              "key": "A"
            },
            {
              "content": "interface",
              "key": "B"
            },
            {
              "content": "abstract contract",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "c909f776-9923-4e74-b489-98e302e4da2e",
          "type": "SingleChoice",
          "content": "Solidity keyword to declare a constructor is",
          "hint": "noHint",
          "explanation": "'constructor' keyword is used to declare a constructor",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "constructor"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "const",
              "key": "A"
            },
            {
              "content": "constructor",
              "key": "B"
            },
            {
              "content": "construct",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "9324eacb-ffe2-437e-a85d-40f80543815e",
          "type": "SingleChoice",
          "content": "How to call a constructor in contract.",
          "hint": "noHint",
          "explanation": "Constructor invokes only once when the contract is deployed and is used to initialize the contract state.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "constructor"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Constructor are called from other functions in the solidity.",
              "key": "A"
            },
            {
              "content": "It get invoked only once when the contract is deployed.",
              "key": "B"
            },
            {
              "content": "Constructor can't restrict the method call.",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6ff16f09-7170-416b-948d-991e7ddcc4b4",
          "type": "SingleChoice",
          "content": "Which of the following is not belongs to polymorphism in solidity?",
          "hint": "noHint",
          "explanation": "Solidity supports two types of polymorphism, Function Polymorphism, and Contract Polymorphism.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "polymorphism"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Function Polymorphism",
              "key": "A"
            },
            {
              "content": "Variable Polymorphism",
              "key": "B"
            },
            {
              "content": "Contract Polymorphism",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "60e9111a-fa13-47c4-ac5e-5c8a4508dcea",
          "type": "SingleChoice",
          "content": "Function Polymorphism is also known as",
          "hint": "noHint",
          "explanation": "Function Polymorphism is also known as method overloading.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "polymorphism"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "method calling",
              "key": "A"
            },
            {
              "content": "method overriding",
              "key": "B"
            },
            {
              "content": "method overloading",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "abb0ca8a-6082-40f5-a4e7-85ea1e31dec7",
          "type": "SingleChoice",
          "content": "In function polymorphism, functions are differ by",
          "hint": "noHint",
          "explanation": "In function polymorphism, multiple functions are declared having the same name within the same contract or inheriting contract. Functions differ on the basis of the number of parameters or parameter datatypes.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "polymorphism"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "number of parameters",
              "key": "A"
            },
            {
              "content": "function name",
              "key": "B"
            },
            {
              "content": "access modifier",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "56639933-4852-4f0e-b9ac-893e5eb3cce7",
          "type": "SingleChoice",
          "content": "\"Declaration of function cannot be overload by functions that differ only in return type in solidity.\" The statement is",
          "hint": "noHint",
          "explanation": "- We can have multiple definitions for the same function name in the same scope. The definition of the function must differ from each other by the types and/or the number of arguments in the argument list. \n- We cannot overload function declarations that differ only by return type.\n",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "polymorphism"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "True",
              "key": "A"
            },
            {
              "content": "False",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "7390eb9d-f096-44e9-82c4-93cfe8786885",
          "type": "SingleChoice",
          "content": "Using multiple contract instances interchangeably when they are related to each other by using inheritance is known as",
          "hint": "noHint",
          "explanation": "Contract polymorphism means using multiple contract instances interchangeably when they are related to each other by using inheritance.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "polymorphism"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Method overloading",
              "key": "A"
            },
            {
              "content": "Contract Polymorphism",
              "key": "B"
            },
            {
              "content": "Both A and B",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e6ea1839-6aa6-431b-a354-60175b35a938",
          "type": "SingleChoice",
          "content": "Which of the following explains polymorphism",
          "hint": "noHint",
          "explanation": "Polymorphism is an ability to process data in more than one form. Like any other programming language Solidity also supports polymorphism.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "polymorphism"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "An ability to process data in more than one form.",
              "key": "A"
            },
            {
              "content": "The mechanism of manipulation of the scope of variables.",
              "key": "B"
            },
            {
              "content": "Way of extending the functionality of a program, used to separate the code, reduces the dependency, and increases the re-usability of the existing code.",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "da6462e4-8e42-4768-a9b9-78b723168303",
          "type": "SingleChoice",
          "content": "Is it accurate that private variables are truly private?",
          "hint": "noHint",
          "explanation": "No, Only the EVM has access to private information (Ethereum Virtual Machine, the part of Ethereum that executes smart contracts). On the other hand, smart contract data is stored on the Ethereum blockchain, which is open to the world. Anyone can read secret variables of smart contracts using a particular tool for analyzing blockchain data.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "encapsulation"
          ],
          "difficultyLevel": "High",
          "choices": [
            {
              "content": "Yes",
              "key": "A"
            },
            {
              "content": "No",
              "key": "B"
            }
          ]
        },
        {
          "uuid": "9678bd2b-b38d-41b5-a25a-a48401d8df1b",
          "type": "SingleChoice",
          "content": "Which of types belongs to libraries avialable in solidity",
          "hint": "noHint",
          "explanation": "There are 2 types of libraries\n- Deployed- They have their own address, and several other smart contracts can use them.\n- Embedded- They don’t have their own address and are deployed as part of the code of the smart contract that uses them.\n",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "library"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Deployed",
              "key": "A"
            },
            {
              "content": "Embedded",
              "key": "B"
            },
            {
              "content": "Both A and B",
              "key": "C"
            },
            {
              "content": "None",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "048a44ca-13d8-11ed-861d-0242ac120002",
          "title": "Understanding Encapsulation in Solidity",
          "shortTitle": "Encapsulation",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=thADMg9cKPM",
          "subTopics": [
            "encapsulation"
          ],
          "details": "In this video we're looking at the inheritance in Solidity.\nThis video explains about\n- Visibility\n- What is Function modifier\n"
        },
        {
          "uuid": "7e6c6d52-76e5-44f1-90da-a722a07689dc",
          "title": "Understanding Encapsulation in Solidity",
          "shortTitle": "Encapsulation",
          "type": "YoutubeVideo",
          "url": "https://https://www.youtube.com/watch?v=tfk25O-5Ppg",
          "subTopics": [
            "encapsulation"
          ],
          "details": "In this video we're looking at the inheritance in Solidity.\nThis video explains about\n- Visibility\n- What is Function modifier\n"
        },
        {
          "uuid": "048a4f74-13d8-11ed-861d-0242ac120002",
          "title": "Inheritance in Solidity",
          "shortTitle": "Inheritance",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=LwKIEj60dks",
          "subTopics": [
            "inheritance"
          ],
          "details": "In this video we're looking at the inheritance in Solidity.\nThis video explains about\n- Inheritance with example\n- Smart contract intraction\n"
        },
        {
          "uuid": "048a50be-13d8-11ed-861d-0242ac120002",
          "title": "Polymorphism in Solidity",
          "shortTitle": "Polymorphism",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=l_E5F5qnbtk",
          "subTopics": [
            "polymorphism"
          ],
          "details": "In this video we're looking at the polymorphism in Solidity.\nThis video explains about\n- polymorphism with example\n- Contract function intraction\n"
        },
        {
          "uuid": "241e570b-10a8-4856-b344-9641f19af397",
          "title": "Polymorphism in Solidity",
          "shortTitle": "Polymorphism",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=-ByfpJIqm-Y",
          "subTopics": [
            "polymorphism"
          ],
          "details": "In this video we're looking at the polymorphism in Solidity.\nThis video explains about\n- polymorphism with example\n- Contract function intraction\n"
        },
        {
          "uuid": "048a51e0-13d8-11ed-861d-0242ac120002",
          "title": "Constructor for Solidity",
          "shortTitle": "Constructor",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=ADVifGOanVU",
          "subTopics": [
            "constructor"
          ],
          "details": "In this video we're looking at the constructor in Solidity.\nThis video explains about\n* How to declare a constructor in Solidity\n* Differences between a constructor and regular functions\n* How to call a parent constructor from an inherited contract\n"
        },
        {
          "uuid": "048a52ee-13d8-11ed-861d-0242ac120002",
          "title": "Abstraction in Solidity",
          "shortTitle": "Abstraction",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=iAB_6ZwqGG0",
          "subTopics": [
            "inheritance"
          ],
          "details": "In this video we're looking at the abstraction in Solidity.\nThis video explains about\n* How to declare an Abstract Contract\n* Abstract Contract Explained\n* How to use Interfaces\n"
        },
        {
          "uuid": "048a55a0-13d8-11ed-861d-0242ac120002",
          "title": "Libraries in Solidity",
          "shortTitle": "Libraries",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=25MLAnIzXRw",
          "subTopics": [
            "library"
          ],
          "details": "In this video we're looking at the libraries in Solidity.\nThis video explains about\n- Simple example with pure function\n- Advanced example with a struct\n- Deployed vs Embedded libraries\n"
        }
      ],
      "summaries": [
        {
          "title": "Understanding Encapsulation in Solidity",
          "shortTitle": "Encapsulation",
          "key": "encapsulation",
          "details": "It refers to the bundling of data, along with the methods that operate on that data, into a single unit.\nIt refers to the mechanism of manipulating the scope of variables, i.e., restricting the variable's access outside the scope.\n\nSyntax\n  ```solidity\n  // Unlike in Java,\n  // the data type comes before the visibility modifier in Solidity\n  uint public num;\n  // <data type> <visibility> <variale name>;\n  ```\n\n- Public\n  * These objects can be accessed internally and externally as well as via messages also.\n  * External methods can inherit public elements.\n  * A getter function is generated automatically when a public variable is created.\n  * However, no setter function is created, implying that the external function can not modify the variable.\n\n- Internal\n  * As the name suggests, Internal objects can be accessed by internal or derived methods but cannot be accessed by external.\n  * Only a base contract and a derived contract have their access.\n\n- Private\n  * Private objects can only be accessed internally from the current contract instances.\n  * They cannot be accessed by derived methods also.\n\n- External\n  * These objects can be accessed externally but not internally, i.e., current contract instances cannot access it.\n  * They cannot be inherited.\n\nState Variable visibility\n  - Public\n  - Internal\n  - Private\n\nFunction visibility\n  - External\n  - Public\n  - Internal\n  - Private\n\nOne should always use the principle of least privilege when determining which level of visibility to use.\n"
        },
        {
          "title": "Understanding Inheritance in Solidity",
          "shortTitle": "Inheritance",
          "key": "inheritance",
          "details": "Inheritance is the process of defining multiple contracts related to each other through parent-child relationships.\n\nSolidity supports inheritance between smart contracts.\n  * Base contract: The contract from which other contracts inherit features.\n  * Derived contract: The contract which inherits the features.\n  * Simply, they are referred to as parent-child contracts.\n\nSyntax\n  ```solidity\n    contract <Derived Contract Name> is <Base Contract Name>{\n  }\n  ```\n\nSolidity provides different types of inheritance.\n  - Single Inheritance\n    * In Single or single-level inheritance, the functions, and variables of one base contract are inherited to only one derived contract.\n    \n  - Multi-level Inheritance\n    * Very similar to single inheritance.\n    * Instead of just a single parent-child relationship, there are multiple levels of the parent-child relationship.\n\n  - Hierarchical Inheritance\n    * Here, a single contract acts as a base contract for multiple derived contracts.\n    * It is mostly used when a common functionality is used in different places.\n\n  - Multiple Inheritance\n    * Here, a single contract can be inherited from one or more contracts.\n  \nNote : Solidity follows the path of Python and uses C3 Linearization, also known as Method Resolution Order (MRO), to force a specific order in graphs of base contracts. The order of execution is determined by order of the declaration at the contract level. It has nothing to do with the order you call/pass arguments up from the constructor's signature.\n"
        },
        {
          "title": "Polymorphism in Solidity",
          "shortTitle": "Polymorphism",
          "key": "polymorphism",
          "details": "It is an ability to process data in more than one form.\n\nSolidity supports two types of polymorphism.\n  - Note\n    - Function overriding\n      * When the base class and derived class have member functions with exactly the same name, same return-type, and same arguments list.\n    \n    - Function overloading\n      * A set of different functions that happen to have the same name differ by their parameters.\n\n  - Function polymorphism\n    * It is also known as method overloading.\n    * Multiple functions are declared to have the same name within the same contract or inheriting the contract.\n    * Functions differ based on the number of parameters or parameter datatypes.\n    * Declaration of function cannot be overloaded by functions that differ only in return type.\n  \n    ```solidity\n      // Solidity program to demonstrate\n      // Function Polymorphism\n      pragma solidity ^0.5.0;\n        \n      // Contract definition\n      contract methodOverloading {\n        \n          // function to get value of \n          // the unsigned integer variable \n          function getData(uint _n) public pure returns(uint){\n              return _n;\n          }\n            \n          // Function to get value \n          // of the string variable\n          function getData(string memory _str) public pure returns(string memory){\n              return _str;\n          }\n      }\n    ```\n  - Contract polymorphism\n    * Using multiple contract instances interchangeably when they are related to each other by using inheritance.\n\n    ```solidity\n    // Solidity program to demonstrate Contract Polymorphism\n    pragma solidity >=0.4.22 <0.6.0;\n\n    contract parent{  \n      uint internal sum;\n      \n      // Function to set the value of\n      // internal state variable sum\n      function setValue(uint _num1, uint _num2) public {\n        sum = _num1 + _num2;\n      }\n\n      // Function to return a value 10\n      function getValue() public view returns(uint) {\n        return 10;\n      }\n    }\n\n    // Defining child contract\n    contract child is parent{\n      \n      // Function getValue overloaded\n      // to return internal state\n      // variable sum defined in the\n      // parent contract\n      function getValue() public view returns(uint) {\n        return sum;\n      }\n    }\n\n    // Defining calling contract\n    contract ContractPolymorphism {\n      \n      // Creating object\n      parent pc = new child();\n        \n      // Function to set values\n      // of 2 unsigned integers\n      function getInput(uint _num1, uint _num2) public {\n        pc.setValue(_num1, _num2);\n      }\n\n      // Function to get value of\n      // internal state variable sum\n      function getSum() public view returns(uint){\n        return pc.getValue();\n      }\n    }\n    ```\n"
        },
        {
          "title": "Constructor for Solidity",
          "shortTitle": "Constructor",
          "key": "constructor",
          "details": "It is a special method in any object-oriented programming language that gets called whenever an object of a class is initialized.\nSolidity provides a constructor declaration inside the smart contract, and it invokes only once when the contract is deployed and is used to initialize the contract state.\nThe compiler creates a default constructor if there is no explicitly defined constructor.\n\nSyntax\n  ```solidity\n  constructor() <Access Modifier> {         \n  }\n  ```\n\nNote\n  * It is very useful in a smart contract, a parameter value can be defined at the run time and can also restrict the method call.\n  * Constructor overloading is not supported in Solidity; it only allows one constructor at a time.\n"
        },
        {
          "title": "Abstraction in Solidity",
          "shortTitle": "Abstraction",
          "key": "abstraction",
          "details": "Hiding the implementation details and showing only important/useful parts to the user.\n\n  - Abstract Contract\n    * These are contracts that have partial function definitions. One cannot create an instance of an abstract contract.\n    * It must be inherited by a child contract for utilizing its functions.\n    * Abstract contracts help define a contract's structure, and any class inheriting from it must ensure to provide an implementation for them.\n    * If the child contract does not provide the implementation for incomplete functions, even its instance cannot be created.\n    * A contract becomes an abstract class if it has functioned without implementation.\n    * There is no Solidity-provided keyword to mark a contract as abstract.\n  \n  - Interface\n    * These are like abstract contracts, but there are differences.\n    * Interfaces cannot contain any definition.\n    * They can only contain function declarations, which means functions in interfaces cannot contain any code.\n    * An interface can contain only the signature of functions.\n\n    ```solidity\n    // Solidity program to\n    // demonstrate the working\n    // of the interface\n\n    pragma solidity ^0.5.0;\n    interface InterfaceExample{\n      function getStr() public view returns(string memory);\n    }\n\n    // Contract that implements interface\n    contract thisContract is InterfaceExample{\n\n      // Function definitions of functions\n      // declared inside an interface\n      function getStr() public view returns(string memory){\n        return \"GeeksForGeeks\";\n      }\n    }\n    ```\n"
        },
        {
          "title": "Libraries in Solidity",
          "shortTitle": "Library",
          "key": "library",
          "details": "- Highlights\n  * A library has functions that can be called by other contracts. \n  * Deploying a common code by creating a library reduces the gas cost. \n  * Functions of the library can be called directly when they do not modify the state variables i.e. only pure and view   functions can be called from outside of the library. \n  * It cannot be destroyed because it is assumed as stateless. \n  * The library does not have state variables, it cannot inherit any element and cannot be inherited.\n\n- Creating library\n  ```solidity\n  library <libraryName> {\n      // block of code\n  }\n  ```\n\n- Deploying library\n\n  ```solidity\n  // import <libraryName> from “./library-file.sol”;\n\n  // Solidity program to demonstrate \n  // how to deploy a library\n  pragma solidity ^0.5.0;\n\n  // Defining Library\n  library LibraryExample {\n      function pow(uint a, uint b) public view returns (uint, address) {\n          return (a ** b, address(this));\n      }\n  }\n\n  // library deployed with for keyword\n\n  contract LibExample {\n      \n    // Deploying library using \n    // \"for\" keyword\n    using LibraryExample for unit;\n    address owner = address(this);\n      \n    function getPow(uint num1, uint num2) public view returns (uint, address) {\n        return num1.pow(num2);\n    }\n  }\n\n  // library can be used without for keyword\n\n  contract LibExample2{\n\n    // Deploying library without using \n    // \"for\" keyword\n    \n    function getPow(uint num1, uint num2) public view returns (uint, address) {\n          return LibraryExample.pow(num1, num2);\n    }\n  }\n  ```\n"
        }
      ]
    }
  ]
}